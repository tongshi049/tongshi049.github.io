<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-15T20:56:55.775Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maximum Length of Repeated Subarray</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ718/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ718/</id>
    <published>2019-04-15T20:40:57.000Z</published>
    <updated>2019-04-15T20:56:55.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-718-maximum-length-of-repeated-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-718-maximum-length-of-repeated-subarray"></a> LeetCode Q 718 - Maximum Length of Repeated Subarray</h1><p>Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.<br><strong>Note:</strong></p><ol><li>&lt;= len(A), len(B) &lt;= 1000</li><li>&lt;= A[i], B[i] &lt; 100</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Since a common subarray of A and B must start at some A[i] and B[j], let <code>dp[i][j]</code> be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know <code>dp[i][j] = dp[i-1][j-1] + 1</code>. Also, the answer is <code>maxLen(dp[i][j]</code>) over all i, j.</p><p><strong>Time Complexity:</strong> O(M * N);</p><p><strong>Space Complexity:</strong> O(M * N);</p><p><strong>M, N</strong>: length of A, B</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][B.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) </span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">res = Math.max(res, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="an-optimized-solution"><a class="markdownIt-Anchor" href="#an-optimized-solution"></a> An Optimized Solution</h3><p>We can <strong>optimize the space complexity.</strong><br><code>dp[i][j] = dp[i-1][j-1] + 1</code> --&gt; <code>maxLen[i][j]</code> only depends on <code>maxLen[i-1][j-1]</code>, so you only need to keep <code>maxLen[i-1][j-1]</code> which is one element.<br>Therefore, we use maxLenTemp to keep <code>maxLen[i-1][j-1]</code> and traverse the matrix diagonally.</p><p><strong>Time Complexity:</strong> O(M * N);</p><p><strong>Space Complexity:</strong> O(1);</p><p><strong>M, N</strong>: length of A, B</p><p><strong>Code: Optimzed Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxLenTemp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>, n = i; m &lt; A.length &amp;&amp; n &lt; B.length; m++, n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[m] == B[n]) &#123;</span><br><span class="line">maxLenTemp++;</span><br><span class="line">res = Math.max(res, maxLenTemp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLenTemp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxLenTemp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = i, n = <span class="number">0</span>; m &lt; A.length &amp;&amp; n &lt; B.length; m++, n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[m] == B[n]) &#123;</span><br><span class="line">maxLenTemp++;</span><br><span class="line">res = Math.max(res, maxLenTemp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLenTemp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-718-maximum-length-of-repeated-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-718-maximum-length-of-repeated-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 718 - Maximum Length of Repeated Subarray&lt;/h1&gt;
&lt;p&gt;Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;= len(A), len(B) &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;&amp;lt;= A[i], B[i] &amp;lt; 100&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Linked List Cycle II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ142/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ142/</id>
    <published>2019-04-15T19:52:15.000Z</published>
    <updated>2019-04-15T20:09:17.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-142-linked-list-cycle-ii"><a class="markdownIt-Anchor" href="#leetcode-q-142-linked-list-cycle-ii"></a> LeetCode Q 142 - Linked List Cycle II</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ListNode slow = head, fast = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line"><span class="keyword">if</span> (slow == fast)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != slow) &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-142-linked-list-cycle-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-142-linked-list-cycle-ii&quot;&gt;&lt;/a&gt; LeetCode Q 142 - Linked List Cycle II&lt;/h1&gt;
&lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;p&gt;To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Do not modify the linked list.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ287</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ287/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ287/</id>
    <published>2019-04-15T19:34:50.000Z</published>
    <updated>2019-04-15T20:01:45.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-287-find-the-duplicate-number"><a class="markdownIt-Anchor" href="#leetcode-q-287-find-the-duplicate-number"></a> LeetCode Q 287 - Find the Duplicate Number</h1><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Note</strong>:<br>You <strong>must not</strong> modify the array (assume the array is read only).<br>You must use only constant, <strong>O(1) extra space</strong>.<br>Your runtime complexity should be less than O(n^2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1"><a class="markdownIt-Anchor" href="#method-1"></a> Method 1:</h3><p>We traverse the array, we regard each number in the array as the position, then we mark the number in that position to be negative. Then if the number in that position has already been nagetive, that means we have already visited that position. Then we find the duplicates.</p><p>For example,<br>array: [1, 3, 4, 2, 2]</p><ul><li>visit 1st number (i.e. 1), change the number in position 1 to be netaetive, then the array becomes [-1, 3, 4, 2, 2]</li><li>visit 2nd number (i.e. 3), change the number in position 3 to be netaetive, then the array becomes [-1, 3, -4, 2, 2]</li><li>visit 3rd number (i.e. 4), change the number in position 4 to be netaetive, then the array becomes [-1, 3, -4, -2, 2]</li><li>visit 4th number (i.e. 2), change the number in position 2 to be netaetive, then the array becomes [-1, -3, -4, -2, 2]</li><li>visit 5th number (i.e. 2), we find the number in position 2 is negative, then 2 is the duplicates we want to find.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[Math.abs(nums[i]) - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> Math.abs(nums[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[Math.abs(nums[i]) - <span class="number">1</span>] \*= -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line">        num = Math.abs(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2"><a class="markdownIt-Anchor" href="#method-2"></a> Method 2:</h3><p>This solution is similar to find the solution of the node where the cycle begins. This question can be found in <a href="/2019/04/15/leetcodeQ142/" title="Linked List Cycle II">Linked List Cycle II</a></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">slow = nums[slow];</span><br><span class="line">fast = nums[nums[fast]];</span><br><span class="line">&#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pointer1 = nums[<span class="number">0</span>], pointer2 = slow;</span><br><span class="line"><span class="keyword">while</span> (pointer1 != pointer2) &#123;</span><br><span class="line">pointer1 = nums[pointer1];</span><br><span class="line">pointer2 = nums[pointer2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pointer1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-3-binary-search"><a class="markdownIt-Anchor" href="#method-3-binary-search"></a> Method 3: Binary Search</h3><p>At first the search space is numbers between 1 to n. Each time I select a number mid (which is the one in the middle) and count all the numbers equal to or less than mid. Then if the count is more than mid, the search space will be [1 mid] otherwise [mid+1 n]. I do this until search space is only one number.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= mid) count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= mid) </span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">right = mid; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-287-find-the-duplicate-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-287-find-the-duplicate-number&quot;&gt;&lt;/a&gt; LeetCode Q 287 - Find the Duplicate Number&lt;/h1&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;br&gt;
You &lt;strong&gt;must not&lt;/strong&gt; modify the array (assume the array is read only).&lt;br&gt;
You must use only constant, &lt;strong&gt;O(1) extra space&lt;/strong&gt;.&lt;br&gt;
Your runtime complexity should be less than O(n^2).&lt;br&gt;
There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>First Bad Version</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ278/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ278/</id>
    <published>2019-04-15T19:27:50.000Z</published>
    <updated>2019-04-15T19:33:43.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-278-first-bad-version"><a class="markdownIt-Anchor" href="#leetcode-q-278-first-bad-version"></a> LeetCode Q 278 - First Bad Version</h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>boolean isBadVersion(version)</code> which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">// `boolean isBadVersion(int version)`; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (isBadVersion(mid))</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-278-first-bad-version&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-278-first-bad-version&quot;&gt;&lt;/a&gt; LeetCode Q 278 - First Bad Version&lt;/h1&gt;
&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;boolean isBadVersion(version)&lt;/code&gt; which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>H-Index II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ275/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ275/</id>
    <published>2019-04-15T19:17:17.000Z</published>
    <updated>2019-04-15T19:27:31.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-275-h-index-ii"><a class="markdownIt-Anchor" href="#leetcode-q-275-h-index-ii"></a> LeetCode Q 275 - H-Index II</h1><p>Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is to search for the first index from the sorted array so that :<br>citations[index] &gt;= length(citations) - index.<br>And return (length - index) as the result.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = citations.length - <span class="number">1</span>, len = citations.length;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;  <span class="comment">//  (left &lt; right) --&gt; [0, 0] won't pass </span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (citations[mid] == len - mid)</span><br><span class="line"><span class="keyword">return</span> len - mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; len - mid)</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len - left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-275-h-index-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-275-h-index-ii&quot;&gt;&lt;/a&gt; LeetCode Q 275 - H-Index II&lt;/h1&gt;
&lt;p&gt;Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Merge k Sorted Lists</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ23/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ23/</id>
    <published>2019-04-15T18:33:17.000Z</published>
    <updated>2019-04-15T19:14:21.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-23-merge-k-sorted-lists"><a class="markdownIt-Anchor" href="#leetcode-q-23-merge-k-sorted-lists"></a> LeetCode Q 23 - Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><em><strong>k</strong></em>: number of sorted linked lists;<br><em><strong>N</strong></em>: Total number of nodes in all k linked lists.</p><h3 id="method-1-heap-sort"><a class="markdownIt-Anchor" href="#method-1-heap-sort"></a> Method 1: Heap Sort</h3><p><strong>Time Complexity: O(Nlogk)</strong></p><p>The comparison cost will be reduced to O(log k) for every pop and insertion to priority queue. But finding the node with the smallest value just costs O(1) time.</p><p><strong>Space Complexity: O(N) + O(k)</strong></p><p>O(N): Creating a new linked list costs space, i.e. the result.<br>O(k): Build heap.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// build the heap</span></span><br><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a.val - b.val));</span><br><span class="line"><span class="keyword">for</span> (ListNode node: lists) &#123;</span><br><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span>) pq.offer(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), prev = dummy;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">ListNode temp = pq.poll();</span><br><span class="line">prev.next = temp;</span><br><span class="line">prev = temp;</span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) pq.offer(temp.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-merge-lists-with-divide-and-conquer"><a class="markdownIt-Anchor" href="#method-2-merge-lists-with-divide-and-conquer"></a> Method 2: Merge Lists with Divide And Conquer</h3><p><strong>Time Complexity: O(Nlogk)</strong></p><p>We can merge two sorted linked list in O(n) time, where n is the total number of two lists.<br>Sum up the merge process and we can get O(Nlogk).</p><p><strong>Space Complexity: O(1)</strong><br>No extra space is required.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">ListNode node1 = merge(lists, left, mid);</span><br><span class="line">ListNode node2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> mergeHelper(node1, node2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeHelper</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) <span class="keyword">return</span> node2;</span><br><span class="line">    <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) <span class="keyword">return</span> node1;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), prev = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">            prev.next = node1;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = node2;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) prev.next = node2;</span><br><span class="line">    <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) prev.next = node1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-23-merge-k-sorted-lists&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-23-merge-k-sorted-lists&quot;&gt;&lt;/a&gt; LeetCode Q 23 - Merge k Sorted Lists&lt;/h1&gt;
&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Merge Sort" scheme="http://yoursite.com/tags/Merge-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Intersection of Two Arrays II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ350/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ350/</id>
    <published>2019-04-15T17:14:04.000Z</published>
    <updated>2019-04-15T18:44:55.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-350-intersection-of-two-arrays-ii"><a class="markdownIt-Anchor" href="#leetcode-q-350-intersection-of-two-arrays-ii"></a> LeetCode Q 350 - Intersection of Two Arrays II</h1><p>Given two arrays, write a function to compute their intersection.<br><strong>Note:</strong></p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><p><strong>Follow up:</strong></p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li><li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sort-two-pointers"><a class="markdownIt-Anchor" href="#method-1-sort-two-pointers"></a> Method 1: Sort + Two Pointers</h3><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1); Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">            list.add(nums1[i]);</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: list) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-hashmap"><a class="markdownIt-Anchor" href="#method-2-hashmap"></a> Method 2: HashMap</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums1) &#123;</span><br><span class="line">        map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">            map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: list) </span><br><span class="line">        res[index++] = num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-to-3rd-follow-up-question"><a class="markdownIt-Anchor" href="#solution-to-3rd-follow-up-question"></a> Solution to 3rd follow-up question:</h3><ul><li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p></li><li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p></li></ul><p>It is a classical question in database perspective. External sort is a trick used to implement <code>JOIN</code>, basically called sort-merge join. A detailed explanation of <strong>External sorting</strong> can be found in <a href="https://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="noopener">wekipedia</a>.</p><ul><li><p><strong>External sorting</strong> is a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory, usually a hard disk drive. Thus, external sorting algorithms are external memory algorithms and thus applicable in the external memory model of computation.</p></li><li><p>External sorting algorithms generally fall into two types, <strong>distribution sorting</strong>, which resembles quicksort, and <strong>external merge sort</strong>, which resembles merge sort. The latter typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.</p></li><li><p>External sorting algorithms can be analyzed in the external memory model. In this model, <strong>a cache or internal memory of size M</strong> and an unbounded external memory are divided into <strong>blocks of size B</strong>, and the running time of an algorithm is determined by the number of memory transfers between internal and external memory. Like their cache-oblivious counterparts, asymptotically optimal external sorting algorithms achieve a running time (in <strong>Big O notation</strong>) of</p></li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>B</mi></mfrac><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mi>M</mi><mi>B</mi></mfrac></msub><mfrac><mi>N</mi><mi>B</mi></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{N}{B}O(log_{\frac{M}{B}}\frac{N}{B}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.734335em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5064649999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>For example, for sorting 900 megabytes of data using only 100 megabytes of RAM:</p><ol><li>Read 100 MB of the data in main memory and sort by some conventional method, like quicksort.</li><li>Write the sorted data to disk.<br>Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.</li><li>Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)</li><li>Perform a <strong>9-way merge</strong> and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally – because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed. We can do the <strong>n-way merge</strong> like <a href="/2019/04/15/leetcodeQ23/" title="Merge k Sorted Lists">Merge k Sorted Lists</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-350-intersection-of-two-arrays-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-350-intersection-of-two-arrays-ii&quot;&gt;&lt;/a&gt; LeetCode Q 350 - Intersection of Two Arrays II&lt;/h1&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;/li&gt;
&lt;li&gt;The result can be in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;/li&gt;
&lt;li&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;/li&gt;
&lt;li&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Intersection of Two Arrays</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ349/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ349/</id>
    <published>2019-04-15T17:04:20.000Z</published>
    <updated>2019-04-15T17:16:24.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-349-intersection-of-two-arrays"><a class="markdownIt-Anchor" href="#leetcode-q-349-intersection-of-two-arrays"></a> LeetCode Q 349 - Intersection of Two Arrays</h1><p>Given two arrays, write a function to compute their intersection.<br><strong>Note:</strong></p><ul><li>Each element in the result must be unique.</li><li>The result can be in any order.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-use-two-set"><a class="markdownIt-Anchor" href="#method-1-use-two-set"></a> Method 1: Use Two Set</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; duplicates = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums1) </span><br><span class="line">        set.add(num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(num))</span><br><span class="line">            duplicates.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[duplicates.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: duplicates)</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-sort-two-arrays-and-use-two-pointers-to-find-duplicates"><a class="markdownIt-Anchor" href="#method-2-sort-two-arrays-and-use-two-pointers-to-find-duplicates"></a> Method 2: Sort two arrays, and use two pointers to find duplicates</h3><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1); Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span> || temp[index - <span class="number">1</span>] != nums1[i]) </span><br><span class="line">                temp[index++] = nums1[i];</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; index; m++) </span><br><span class="line">        res[m] = temp[m];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-349-intersection-of-two-arrays&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-349-intersection-of-two-arrays&quot;&gt;&lt;/a&gt; LeetCode Q 349 - Intersection of Two Arrays&lt;/h1&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each element in the result must be unique.&lt;/li&gt;
&lt;li&gt;The result can be in any order.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Longest Increasing Subsequence</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ300/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ300/</id>
    <published>2019-04-15T16:23:23.000Z</published>
    <updated>2019-04-15T17:03:52.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-300-longest-increasing-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-300-longest-increasing-subsequence"></a> LeetCode Q 300 - Longest Increasing Subsequence</h1><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-dynamic-programming"><a class="markdownIt-Anchor" href="#method-1-dynamic-programming"></a> Method 1: Dynamic Programming</h3><p><strong>Time Complexity: O(n^2)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>); <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) </span><br><span class="line">dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-binary-search"><a class="markdownIt-Anchor" href="#method-2-binary-search"></a> Method 2: Binary Search</h3><p><strong>We can find the length as follows:</strong><br>input array: [10, 9, 2, 5, 3, 7]<br>helper array (tails): [0, 0, 0, 0, 0, 0]</p><ul><li>tails: [0, 0, 0, 0, 0, 0], len = 0;</li><li>tails: [10, 0, 0, 0, 0, 0], len = 1;</li><li>tails: [9, 0, 0, 0, 0, 0], len = 1;</li><li>tails: [2, 0, 0, 0, 0, 0], len = 1;</li><li>tails: [2, 5, 0, 0, 0, 0], len = 2;</li><li>tails: [2, 3, 0, 0, 0, 0], len = 2;</li><li>tails: [2, 3, 7, 0, 0, 0], len = 3;</li></ul><p><strong>Our strategy determined by the following conditions.</strong></p><ul><li>Case 1: If nums[i] is largest among all end candidates of active lists, we will clone the largest active list, and extend it by A[i].</li><li>Case 2: If nums[i] is in between, we will find a list with largest end element that is smaller than A[i]. Clone and extend this list by A[i]. We will discard all other lists of same length as that of this modified list.</li></ul><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="comment">// use bineary searth to find the largest tail i, that num &lt;= tail[i];</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = len;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (tails[mid] &lt; num) </span><br><span class="line">i = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">j = mid;</span><br><span class="line">&#125;</span><br><span class="line">tails[i] = num; <span class="comment">// update the tail </span></span><br><span class="line"><span class="keyword">if</span> (i == len) len++; <span class="comment">// case 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-300-longest-increasing-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-300-longest-increasing-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 300 - Longest Increasing Subsequence&lt;/h1&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Size Subarray Sum</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ209/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ209/</id>
    <published>2019-04-14T17:36:58.000Z</published>
    <updated>2019-04-14T17:53:03.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-209-minimum-size-subarray-sum"><a class="markdownIt-Anchor" href="#leetcode-q-209-minimum-size-subarray-sum"></a> LeetCode Q 209 - Minimum Size Subarray Sum</h1><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sliding-window"><a class="markdownIt-Anchor" href="#method-1-sliding-window"></a> Method 1: Sliding Window</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, minLength = Integer.MAX_VALUE, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">sum += nums[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt; s) &#123;</span><br><span class="line">minLength = Math.min(minLength, right - left + <span class="number">1</span>);</span><br><span class="line">sum -= nums[left++];</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-binary-search"><a class="markdownIt-Anchor" href="#method-2-binary-search"></a> Method 2: Binary Search</h3><p>Since the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don’t have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices.</p><p>As to NLogN solution, logN immediately reminds you of binary search. In this case, you cannot sort as the current order actually matters. How does one get an ordered array then? Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search</p><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) sums[i] = nums[i - <span class="number">1</span>] + sums[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> minLength = Integer.MAX_VALUE</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> end = binarySearch(sums, i + <span class="number">1</span>, sums.length - <span class="number">1</span>, s + sums[i]);</span><br><span class="line"><span class="keyword">if</span> (end == sums.length) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> (end - i &lt; minLength) minLength = end - i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] sums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (sums[lo] + sums[hi]) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= key) </span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-209-minimum-size-subarray-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-209-minimum-size-subarray-sum&quot;&gt;&lt;/a&gt; LeetCode Q 209 - Minimum Size Subarray Sum&lt;/h1&gt;
&lt;p&gt;Given an array of &lt;strong&gt;n&lt;/strong&gt; positive integers and a positive integer &lt;strong&gt;s&lt;/strong&gt;, find the minimal length of a &lt;strong&gt;contiguous&lt;/strong&gt; subarray of which the sum ≥ s. If there isn’t one, return 0 instead.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum II - Input array is sorted</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ167-1/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ167-1/</id>
    <published>2019-04-14T17:35:27.000Z</published>
    <updated>2019-04-14T17:36:21.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-167-two-sum-ii-input-array-is-sorted"><a class="markdownIt-Anchor" href="#leetcode-q-167-two-sum-ii-input-array-is-sorted"></a> LeetCode Q 167 - Two Sum II - Input array is sorted</h1><p>Given an array of integers that is already <em><strong>sorted in ascending order</strong></em>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1"><a class="markdownIt-Anchor" href="#method-1"></a> Method 1</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (numbers[idx1] + numbers[idx2] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[idx1] + numbers[idx2] &gt; target)</span><br><span class="line">            idx2--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;idx1 + <span class="number">1</span>, idx2 + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-167-two-sum-ii-input-array-is-sorted&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-167-two-sum-ii-input-array-is-sorted&quot;&gt;&lt;/a&gt; LeetCode Q 167 - Two Sum II - Input array is sorted&lt;/h1&gt;
&lt;p&gt;Given an array of integers that is already &lt;em&gt;&lt;strong&gt;sorted in ascending order&lt;/strong&gt;&lt;/em&gt;, find two numbers such that they add up to a specific target number.&lt;/p&gt;
&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find Peak Element</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ162/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ162/</id>
    <published>2019-04-14T17:09:42.000Z</published>
    <updated>2019-04-14T17:33:12.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-162-find-peak-element"><a class="markdownIt-Anchor" href="#leetcode-q-162-find-peak-element"></a> LeetCode Q 162 - Find Peak Element</h1><p>A peak element is an element that is greater than its neighbors.<br>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that nums[-1] = nums[n] = -∞.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) </span><br><span class="line">right = mid;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-162-find-peak-element&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-162-find-peak-element&quot;&gt;&lt;/a&gt; LeetCode Q 162 - Find Peak Element&lt;/h1&gt;
&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;br&gt;
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.&lt;br&gt;
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;br&gt;
You may imagine that nums[-1] = nums[n] = -∞.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Count Complete Tree Nodes</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ222/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ222/</id>
    <published>2019-04-14T16:08:19.000Z</published>
    <updated>2019-04-14T17:30:53.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-222-count-complete-tree-nodes"><a class="markdownIt-Anchor" href="#leetcode-q-222-count-complete-tree-nodes"></a> LeetCode Q 222 - Count Complete Tree Nodes</h1><p>Given a complete binary tree, count the number of nodes.</p><p><strong>Note</strong>:<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1"><a class="markdownIt-Anchor" href="#method-1"></a> Method 1</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The time complexity of this method O(n). We can do it better as follows.</p><h3 id="method-2"><a class="markdownIt-Anchor" href="#method-2"></a> Method 2</h3><p>First, use divide and conquer to find the number of nodes.<br>We use <code>height(root) == height(root.right) - 1</code> to check if the child is a complete tree.</p><ul><li>If it is, then we can let <code>root = root.right</code>and find the number of nodes in the right child.</li><li>If it isn’t, then we can let <code>root = root.left</code> and find the number of nodes in the left child.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return countNodesRecursive(root);</span></span><br><span class="line"><span class="keyword">return</span> countNodesIterative(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodesRecursive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> height = getHeight(root);</span><br><span class="line"><span class="keyword">return</span> height &lt; <span class="number">0</span> ? <span class="number">0</span> : getHeight(root.right) == height - <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; height) + countNodes(root.right) : (<span class="number">1</span> &lt;&lt; (height - <span class="number">1</span>)) + countNodes(root.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodesIterative</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>, height = getHeight(root);</span><br><span class="line"><span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (getHeight(root.right) == height - <span class="number">1</span>) &#123;</span><br><span class="line">count += <span class="number">1</span> &lt;&lt; height;</span><br><span class="line">root = root.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count += <span class="number">1</span> &lt;&lt; (height - <span class="number">1</span>);</span><br><span class="line">root = root.left;</span><br><span class="line">&#125;</span><br><span class="line">height--; <span class="comment">// don't forget this.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="keyword">null</span> ? -<span class="number">1</span> : <span class="number">1</span> + getHeight(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-222-count-complete-tree-nodes&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-222-count-complete-tree-nodes&quot;&gt;&lt;/a&gt; LeetCode Q 222 - Count Complete Tree Nodes&lt;/h1&gt;
&lt;p&gt;Given a complete binary tree, count the number of nodes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;br&gt;
Definition of a complete binary tree from Wikipedia:&lt;br&gt;
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Search a 2D Matrix II</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ240/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ240/</id>
    <published>2019-04-14T16:03:51.000Z</published>
    <updated>2019-04-14T16:39:16.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-240-search-a-2d-matrix-ii"><a class="markdownIt-Anchor" href="#leetcode-q-240-search-a-2d-matrix-ii"></a> LeetCode Q 240 - Search a 2D Matrix II</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Begin our search at the top right corner of the matrix.</p><ul><li>If the target is large than this number, then we find numbers below it.</li><li>If the target is small than this number, then we find numbers on the left of it.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &lt; target)</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-240-search-a-2d-matrix-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-240-search-a-2d-matrix-ii&quot;&gt;&lt;/a&gt; LeetCode Q 240 - Search a 2D Matrix II&lt;/h1&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted in ascending from left to right.&lt;/li&gt;
&lt;li&gt;Integers in each column are sorted in ascending from top to bottom.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Search a 2D Matrix</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ74/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ74/</id>
    <published>2019-04-12T21:35:15.000Z</published>
    <updated>2019-04-14T16:04:30.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-74-search-a-2d-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-74-search-a-2d-matrix"></a> LeetCode Q 74 - Search a 2D Matrix</h1><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We can solve this problem by two methods.</p><p><strong>Method 1:</strong></p><ul><li>Use binary search to find the row no.</li><li>Use binary search to find the number in that row.</li></ul><p><strong>Method 2:</strong></p><ul><li>Take the matrix as an array, and then do the binary search<br><strong>key point is</strong> how to translate the index to row and col no.<br><code>nums[index] = nums[index / col][index % col];</code></li></ul><p><strong>Code: Method 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> </span><br><span class="line">        || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// do binary search once</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> number = matrix[mid / col][mid % col];</span><br><span class="line">        <span class="keyword">if</span> (number == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code: Method 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> </span><br><span class="line">        || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. find in which row the target may exist, use start as the row index</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = row - <span class="number">1</span>, rowIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &gt; target)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == row - <span class="number">1</span> || matrix[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">                start = mid; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now the start represents that row index</span></span><br><span class="line">    <span class="comment">// then use binary searth to find the element</span></span><br><span class="line">    <span class="keyword">return</span> helper(matrix[start], <span class="number">0</span>, col - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-74-search-a-2d-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-74-search-a-2d-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 74 - Search a 2D Matrix&lt;/h1&gt;
&lt;p&gt;Write an efficient algorithm that searches for a value in an &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted from left to right.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find First and Last Position of Element in Sorted Array</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ34/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ34/</id>
    <published>2019-04-12T21:26:54.000Z</published>
    <updated>2019-04-12T21:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-34-find-first-and-last-position-of-element-in-sorted-array"><a class="markdownIt-Anchor" href="#leetcode-q-34-find-first-and-last-position-of-element-in-sorted-array"></a> LeetCode Q 34 - Find First and Last Position of Element in Sorted Array</h1><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.</p><p>If the target is not found in the array, return [-1, -1].</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>First we use binary search to find the target number, if it exists then we want to find the first and last index.<br>When finding these two indexes, we should also use binary search. Or our algorithm has a potential to become linear search when the data is like [1,1,1,1,1,1,1,2,3], then the time complexity would become <strong>O(n)</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">eturn <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line"><span class="keyword">int</span> index = bs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.fill(res, index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find the left boundary</span></span><br><span class="line">left = index;</span><br><span class="line"><span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">left = bs(nums, <span class="number">0</span>, left - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the right boundary</span></span><br><span class="line">right = index;</span><br><span class="line"><span class="keyword">while</span> (right &lt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">right = bs(nums, right + <span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> res[<span class="number">1</span>] = right;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-34-find-first-and-last-position-of-element-in-sorted-array&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-34-find-first-and-last-position-of-element-in-sorted-array&quot;&gt;&lt;/a&gt; LeetCode Q 34 - Find First and Last Position of Element in Sorted Array&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;
&lt;p&gt;Your algorithm’s runtime complexity must be in the order of &lt;strong&gt;O(log n)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Search Insert Position</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ35/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ35/</id>
    <published>2019-04-12T21:20:36.000Z</published>
    <updated>2019-04-12T21:25:56.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-35-search-insert-position"><a class="markdownIt-Anchor" href="#leetcode-q-35-search-insert-position"></a> LeetCode Q 35 - Search Insert Position</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || target &lt;= nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-35-search-insert-position&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-35-search-insert-position&quot;&gt;&lt;/a&gt; LeetCode Q 35 - Search Insert Position&lt;/h1&gt;
&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Largest Divisible Subset</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ368/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ368/</id>
    <published>2019-04-12T21:05:20.000Z</published>
    <updated>2019-04-12T21:20:20.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-368-largest-divisible-subset"><a class="markdownIt-Anchor" href="#leetcode-q-368-largest-divisible-subset"></a> LeetCode Q 368 - Largest Divisible Subset</h1><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: <code>Si % Sj = 0 or Sj % Si = 0</code></p><p>If there are multiple solutions, return any subset is fine.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We can solve this problem following these four steps:</p><ol><li>Sort</li><li>Find the length of longest subset</li><li>Record the largest element of it.</li><li>Do a loop from the largest element to nums[0], add every element belongs to the longest subset.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">// 1. sort</span></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Find the length of longest subset</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// records the number of each subset contains i</span></span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line"><span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Record the largest element of it.</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt;= dp[maxIndex])</span><br><span class="line">maxIndex = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset. -- easily making mistake at this step</span></span><br><span class="line"><span class="keyword">int</span> temp = nums[maxIndex];</span><br><span class="line"><span class="keyword">int</span> val = dp[maxIndex];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (val == dp[i] &amp;&amp; temp % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(nums[i]);</span><br><span class="line">temp = nums[i];</span><br><span class="line">val--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-368-largest-divisible-subset&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-368-largest-divisible-subset&quot;&gt;&lt;/a&gt; LeetCode Q 368 - Largest Divisible Subset&lt;/h1&gt;
&lt;p&gt;Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: &lt;code&gt;Si % Sj = 0 or Sj % Si = 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If there are multiple solutions, return any subset is fine.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Median of Two Sorted Arrays</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ4/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ4/</id>
    <published>2019-04-12T20:48:12.000Z</published>
    <updated>2019-04-12T21:04:41.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-4-median-of-two-sorted-arrays"><a class="markdownIt-Anchor" href="#leetcode-q-4-median-of-two-sorted-arrays"></a> LeetCode Q 4 - Median of Two Sorted Arrays</h1><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>.</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>This solution is following the idea in Tushar’s Youtube video. This video provides a quite clear and comprehensive description of the solution.<br>You can find this video <a href="https://www.youtube.com/watch?v=LPFhl65R7ww" target="_blank" rel="noopener">here</a>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums1.length &gt; nums2.length) <span class="keyword">return</span> findMedianSortedArrays(nums1, nums2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = num1.length, len2 = num2.length;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = len1;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> partitionX = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> partitionY = (len1 + len2 + <span class="number">1</span>) / <span class="number">2</span> - partitionX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftX = partitionX == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[partitionX - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> leftY = partitionY == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[partitionY - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rightX = partitionX == len1 ? Integer.MAX_VALUE : nums1[partitionX];</span><br><span class="line"><span class="keyword">int</span> rightY = partitionY == len2 ? Integer.MAX_VALUE : nums2[partitionY];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftX &lt;= rightY &amp;&amp; leftY &lt;= rightX) &#123;</span><br><span class="line"><span class="keyword">if</span> ((len1 + len2) % <span class="number">2</span> = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> Math.max(leftX, leftY);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> (Math.max(leftX, leftY) + Math.min(rightX, rightY)) / <span class="number">2.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftX &gt; rightY) &#123;</span><br><span class="line">right = partitionX - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = partitionX + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-4-median-of-two-sorted-arrays&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-4-median-of-two-sorted-arrays&quot;&gt;&lt;/a&gt; LeetCode Q 4 - Median of Two Sorted Arrays&lt;/h1&gt;
&lt;p&gt;There are two sorted arrays &lt;strong&gt;nums1&lt;/strong&gt; and &lt;strong&gt;nums2&lt;/strong&gt; of size m and n respectively.&lt;/p&gt;
&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be &lt;strong&gt;O(log (m+n))&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You may assume &lt;strong&gt;nums1&lt;/strong&gt; and &lt;strong&gt;nums2&lt;/strong&gt; cannot be both empty.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find Minimum in Rotated Sorted Array II</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ154/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ154/</id>
    <published>2019-04-12T17:56:16.000Z</published>
    <updated>2019-04-12T18:10:39.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-154-find-minimum-in-rotated-sorted-array-ii"><a class="markdownIt-Anchor" href="#leetcode-q-154-find-minimum-in-rotated-sorted-array-ii"></a> LeetCode Q 154 - Find Minimum in Rotated Sorted Array II</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).<br>Find the minimum element. The array may contain <strong>duplicates</strong>.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Similar to Q81, in the worst case, the time complexity becomes O(n).<br>So, we don’t need to use binary search.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; min) min = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code: Use fake binary sesarch</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[nums.length - <span class="number">1</span>]) right--;</span><br><span class="line"><span class="comment">//When num[mid] == num[hi], we couldn't sure the position of minimum in mid's left or right, </span></span><br><span class="line"><span class="comment">//so just let upper bound reduce one.</span></span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-154-find-minimum-in-rotated-sorted-array-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-154-find-minimum-in-rotated-sorted-array-ii&quot;&gt;&lt;/a&gt; LeetCode Q 154 - Find Minimum in Rotated Sorted Array II&lt;/h1&gt;
&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;
(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).&lt;br&gt;
Find the minimum element. The array may contain &lt;strong&gt;duplicates&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
</feed>
