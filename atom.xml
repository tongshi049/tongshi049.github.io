<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-28T21:32:26.256Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Permutations II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQQ47/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQQ47/</id>
    <published>2019-04-28T21:28:10.000Z</published>
    <updated>2019-04-28T21:32:26.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-47-permutations-ii"><a class="markdownIt-Anchor" href="#leetcode-q-47-permutations-ii"></a> LeetCode Q 47 - Permutations II</h1><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p>Example:<br><code>Input: [1,1,2]</code><br>Output:<br>[<br>[1,1,2],<br>[1,2,1],<br>[2,1,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Tips:</strong></p><ul><li>Use an extra boolean array <code>boolean[] used</code> to indicate whether the value is added to list.</li><li>Sort the array <code>int[] nums</code> to make sure we can skip the same value.</li><li><strong>When a number has the same value with its previous, we can use this number only if his previous is used.</strong></li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] = nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">visited[i] = <span class="keyword">true</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp, visited);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">visited[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-47-permutations-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-47-permutations-ii&quot;&gt;&lt;/a&gt; LeetCode Q 47 - Permutations II&lt;/h1&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,1,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,1,2],&lt;br&gt;
[1,2,1],&lt;br&gt;
[2,1,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Permutations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ46/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ46/</id>
    <published>2019-04-28T21:25:40.000Z</published>
    <updated>2019-04-28T21:27:47.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-46-permutations"><a class="markdownIt-Anchor" href="#leetcode-q-46-permutations"></a> LeetCode Q 46 - Permutations</h1><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p>Example:<br><code>Input: [1,2,3]</code><br>Output:<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(nums[i])) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-46-permutations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-46-permutations&quot;&gt;&lt;/a&gt; LeetCode Q 46 - Permutations&lt;/h1&gt;
&lt;p&gt;Given a collection of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3,2],&lt;br&gt;
[2,1,3],&lt;br&gt;
[2,3,1],&lt;br&gt;
[3,1,2],&lt;br&gt;
[3,2,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Subsets II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ90/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ90/</id>
    <published>2019-04-28T21:22:53.000Z</published>
    <updated>2019-04-28T21:25:00.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets-ii"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets-ii"></a> LeetCode Q 78 - Subsets II</h1><p>Given a collection of integers that might contain duplicates, <em><strong>nums</strong></em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: [1,2,2]</code><br>Output:<br>[<br>[2],<br>[1],<br>[1,2,2],<br>[2,2],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != pos &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets-ii&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets II&lt;/h1&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, &lt;em&gt;&lt;strong&gt;nums&lt;/strong&gt;&lt;/em&gt;, return all possible subsets (the power set).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2],&lt;br&gt;
[1],&lt;br&gt;
[1,2,2],&lt;br&gt;
[2,2],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ78/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ78/</id>
    <published>2019-04-28T21:21:07.000Z</published>
    <updated>2019-04-28T21:22:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets"></a> LeetCode Q 78 - Subsets</h1><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: nums = [1,2,3]</code><br>Output:<br>[<br>[3],<br>[1],<br>[2],<br>[1,2,3],<br>[1,3],<br>[2,3],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets&lt;/h1&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: nums = [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[3],&lt;br&gt;
[1],&lt;br&gt;
[2],&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum III</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ216/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ216/</id>
    <published>2019-04-28T21:17:33.000Z</published>
    <updated>2019-04-28T21:20:41.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-216-combination-sum-iii"><a class="markdownIt-Anchor" href="#leetcode-q-216-combination-sum-iii"></a> LeetCode Q 216 - Combination Sum III</h1><p>Find all possible combinations of <em><strong>k</strong></em> numbers that add up to a number <em><strong>n</strong></em>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: k = 3, n = 7 ; Output: [[1,2,4]]</code><br>Example 2:<br><code>Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(k, target, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k || target &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, target - i, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-216-combination-sum-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-216-combination-sum-iii&quot;&gt;&lt;/a&gt; LeetCode Q 216 - Combination Sum III&lt;/h1&gt;
&lt;p&gt;Find all possible combinations of &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; numbers that add up to a number &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 7 ; Output: [[1,2,4]]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ77/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ77/</id>
    <published>2019-04-28T21:13:16.000Z</published>
    <updated>2019-04-28T21:19:38.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-77-combinations"><a class="markdownIt-Anchor" href="#leetcode-q-77-combinations"></a> LeetCode Q 77 - Combinations</h1><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><code>Input: n = 4, k = 2</code><br>Output:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || k.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() &gt; k) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, k, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-77-combinations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-77-combinations&quot;&gt;&lt;/a&gt; LeetCode Q 77 - Combinations&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: n = 4, k = 2&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2,4],&lt;br&gt;
[3,4],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[1,3],&lt;br&gt;
[1,4],&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ40/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ40/</id>
    <published>2019-04-28T21:09:18.000Z</published>
    <updated>2019-04-28T21:14:42.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum-ii"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum-ii"></a> LeetCode Q 39 - Combination Sum II</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>Each number in candidates may <strong>only be used once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [10,1,2,7,6,1,5], target = 8,</code><br>A solution set is:<br>[<br>[1, 7],<br>[1, 2, 5],<br>[2, 6],<br>[1, 1, 6]<br>]<br>Example 2:<br><code>Input: candidates = [2,5,2,1,2], target = 5,</code><br>A solution set is:<br>[<br>[1,2,2],<br>[5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (cand == <span class="keyword">null</span> || cand.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(cand, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; cand.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; cand[i] = cand[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum-ii&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum II&lt;/h1&gt;
&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
Each number in candidates may &lt;strong&gt;only be used once&lt;/strong&gt; in the combination.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [10,1,2,7,6,1,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1, 7],&lt;br&gt;
[1, 2, 5],&lt;br&gt;
[2, 6],&lt;br&gt;
[1, 1, 6]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,5,2,1,2], target = 5,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1,2,2],&lt;br&gt;
[5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ39/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ39/</id>
    <published>2019-04-28T21:05:38.000Z</published>
    <updated>2019-04-28T21:09:00.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum"></a> LeetCode Q 39 - Combination Sum</h1><p>Given a <strong>set</strong> of candidate numbers (candidates) <strong>(without duplicates)</strong> and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The <strong>same</strong> repeated number may be chosen from candidates unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [2,3,6,7], target = 7,</code><br>A solution set is:<br>[<br>[7],<br>[2,2,3]<br>]<br>Example 2:<br><code>Input: candidates = [2,3,5], target = 8,</code><br>A solution set is:<br>[<br>[2,2,2,2],<br>[2,3,3],<br>[3,5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (can == <span class="keyword">null</span> || can.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(can, target, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> currSum, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currSum == target) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; can.length; i++) &#123;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum&lt;/h1&gt;
&lt;p&gt;Given a &lt;strong&gt;set&lt;/strong&gt; of candidate numbers (candidates) &lt;strong&gt;(without duplicates)&lt;/strong&gt; and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
The &lt;strong&gt;same&lt;/strong&gt; repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,6,7], target = 7,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[7],&lt;br&gt;
[2,2,3]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[2,2,2,2],&lt;br&gt;
[2,3,3],&lt;br&gt;
[3,5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Letter Combinations of a Phone Number</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ17/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ17/</id>
    <published>2019-04-28T21:01:18.000Z</published>
    <updated>2019-04-28T21:08:14.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-17-letter-combinations-of-a-phone-number"><a class="markdownIt-Anchor" href="#leetcode-q-17-letter-combinations-of-a-phone-number"></a> LeetCode Q 17 - Letter Combinations of a Phone Number</h1><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>Example:<br><code>Input: &quot;23&quot; ;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></p><p><strong>Note:</strong> Although the above answer is in lexicographical order, your answer could be in any order you want.</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] KEYS = &#123; <span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(digits, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// corner cases</span></span><br><span class="line"><span class="keyword">if</span> (pos == digits.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String letters = KEYS[digits.charAt(pos) - <span class="string">'0'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> letter: letters.toCharArray())</span><br><span class="line">backtrack(digits, pos + <span class="number">1</span>, curr + letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;/a&gt; LeetCode Q 17 - Letter Combinations of a Phone Number&lt;/h1&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;23&amp;quot; ;Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Split Array into Fibonacci Sequence</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ842/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ842/</id>
    <published>2019-04-28T17:21:58.000Z</published>
    <updated>2019-04-28T21:04:38.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-842-split-array-into-fibonacci-sequence"><a class="markdownIt-Anchor" href="#leetcode-q-842-split-array-into-fibonacci-sequence"></a> LeetCode Q 842 - Split Array into Fibonacci Sequence</h1><p>Given a string <code>S</code> of digits, such as <code>S = &quot;123456579&quot;</code>, we can split it into a <em>Fibonacci-like</em> sequence <code>[123, 456, 579]</code>.<br>Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:</p><ul><li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>, (that is, each integer fits a 32-bit signed integer type);</li><li><code>F.length &gt;= 3</code>;</li><li>and <code>F[i] + F[i+1] = F[i+2]</code> for all <code>0 &lt;= i &lt; F.length - 2</code>.<br>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</li></ul><p>Return any Fibonacci-like sequence split from S, or return <code>[]</code> if it cannot be done.</p><p>Example 1:<br><code>Input: &quot;123456579&quot; ; Output: [123,456,579]</code><br>Example 2:<br><code>Input: &quot;11235813&quot; ; Output: [1,1,2,3,5,8,13]</code><br>Example 3:<br><code>Input: &quot;112358130&quot; ; Output: []</code><br>Explanation: The task is impossible.<br>Example 4:<br><code>Input: &quot;0123&quot; ; Output: []</code><br>Explanation: Leading zeroes are not allowed, so “01”, “2”, “3” is not valid.<br>Example 5:<br><code>Input: &quot;1101111&quot; ; Output: [110, 1, 111]</code><br>Explanation: The output [11, 0, 11, 11] would also be accepted.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= S.length &lt;= 200</li><li>S contains only digits.</li></ul><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p>The <strong>key</strong> is <strong>handling corner cases</strong>:</p><ul><li>Remove elements with leading zero</li><li>The element in the sequence should be at most Integer.MAX_VALUE</li><li>The sequence should has at least 3 elements</li><li>If current number is larger than the sum of previous two elements, stop backtracking</li><li>If we find a valid sequence, stop backtracking</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">backtrack(S, res, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(String s, List&lt;Integer&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == s.length() &amp;&amp; res.size() &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="comment">// a number with leading 0s but not '0' is invalid</span></span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; s.charAt(index) == <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = Long.parseLong(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = res.size();</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">2</span> &amp;&amp; num &gt; res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">2</span> || num == res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>)) &#123;</span><br><span class="line">    res.add((<span class="keyword">int</span>)num);</span><br><span class="line">    <span class="comment">// If we find a valid sequence, stop backtracking</span></span><br><span class="line">    <span class="keyword">if</span> (backtrack(s, res, i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-842-split-array-into-fibonacci-sequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-842-split-array-into-fibonacci-sequence&quot;&gt;&lt;/a&gt; LeetCode Q 842 - Split Array into Fibonacci Sequence&lt;/h1&gt;
&lt;p&gt;Given a string &lt;code&gt;S&lt;/code&gt; of digits, such as &lt;code&gt;S = &amp;quot;123456579&amp;quot;&lt;/code&gt;, we can split it into a &lt;em&gt;Fibonacci-like&lt;/em&gt; sequence &lt;code&gt;[123, 456, 579]&lt;/code&gt;.&lt;br&gt;
Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1&lt;/code&gt;, (that is, each integer fits a 32-bit signed integer type);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F.length &amp;gt;= 3&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;F[i] + F[i+1] = F[i+2]&lt;/code&gt; for all &lt;code&gt;0 &amp;lt;= i &amp;lt; F.length - 2&lt;/code&gt;.&lt;br&gt;
Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return any Fibonacci-like sequence split from S, or return &lt;code&gt;[]&lt;/code&gt; if it cannot be done.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;123456579&amp;quot; ; Output: [123,456,579]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;11235813&amp;quot; ; Output: [1,1,2,3,5,8,13]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;112358130&amp;quot; ; Output: []&lt;/code&gt;&lt;br&gt;
Explanation: The task is impossible.&lt;br&gt;
Example 4:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;0123&amp;quot; ; Output: []&lt;/code&gt;&lt;br&gt;
Explanation: Leading zeroes are not allowed, so “01”, “2”, “3” is not valid.&lt;br&gt;
Example 5:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;1101111&amp;quot; ; Output: [110, 1, 111]&lt;/code&gt;&lt;br&gt;
Explanation: The output [11, 0, 11, 11] would also be accepted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= S.length &amp;lt;= 200&lt;/li&gt;
&lt;li&gt;S contains only digits.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
  </entry>
  
  <entry>
    <title>Expression Add Operators</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ282/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ282/</id>
    <published>2019-04-28T16:58:59.000Z</published>
    <updated>2019-04-28T21:02:16.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-282-expression-add-operators"><a class="markdownIt-Anchor" href="#leetcode-q-282-expression-add-operators"></a> LeetCode Q 282 - Expression Add Operators</h1><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.</p><p>Example 1:<br><code>Input: num = &quot;123&quot;, target = 6 ; Output: [&quot;1+2+3&quot;, &quot;1*2*3&quot;]</code><br>Example 2:<br><code>Input: num = &quot;232&quot;, target = 8 ; Output: [&quot;2*3+2&quot;, &quot;2+3*2&quot;]</code><br>Example 3:<br><code>Input: num = &quot;105&quot;, target = 5 ; Output: [&quot;1*0+5&quot;,&quot;10-5&quot;]</code><br>Example 4:<br><code>Input: num = &quot;00&quot;, target = 0 ; Output: [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]</code><br>Example 5:<br><code>Input: num = &quot;3456237490&quot;, target = 9191 ; Output: []</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><ol><li><strong>Corner Cases:</strong></li></ol><ul><li>if current position is 0, we can only use it as a single digit number, should be 0</li><li>if it is not a single digit number with leading 0, it should be considered as an invalid number</li></ul><ol start="2"><li><strong>How to do multiplication?</strong><br>we should subtract previous number, and then add current multiplication result to the subtraction result</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">dfs(num, target, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String num, <span class="keyword">int</span> target, String exp, <span class="keyword">int</span> index, <span class="keyword">long</span> prev, <span class="keyword">long</span> calVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == num.length() &amp;&amp; calVal == target) &#123;</span><br><span class="line">res.add(exp); <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; num.charAt(index) == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> num = Long.parseLong(s.substring(index, i));</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">dfs(num, target, exp + num, i, num, num);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfs(num, target, exp + <span class="string">"+"</span> + num, i, num, calVal + num);</span><br><span class="line">dfs(num, target, exp + <span class="string">"-"</span> + num, i, -num, calVal - num);</span><br><span class="line">dfs(num, target, exp + <span class="string">"*"</span> + num, i, prev * num, calVal - prev + prev * num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-282-expression-add-operators&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-282-expression-add-operators&quot;&gt;&lt;/a&gt; LeetCode Q 282 - Expression Add Operators&lt;/h1&gt;
&lt;p&gt;Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;123&amp;quot;, target = 6 ; Output: [&amp;quot;1+2+3&amp;quot;, &amp;quot;1*2*3&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;232&amp;quot;, target = 8 ; Output: [&amp;quot;2*3+2&amp;quot;, &amp;quot;2+3*2&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;105&amp;quot;, target = 5 ; Output: [&amp;quot;1*0+5&amp;quot;,&amp;quot;10-5&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 4:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;00&amp;quot;, target = 0 ; Output: [&amp;quot;0+0&amp;quot;, &amp;quot;0-0&amp;quot;, &amp;quot;0*0&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 5:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;3456237490&amp;quot;, target = 9191 ; Output: []&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
  </entry>
  
  <entry>
    <title>Different Ways to Add Parentheses</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ241/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ241/</id>
    <published>2019-04-28T16:48:52.000Z</published>
    <updated>2019-04-28T21:02:06.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-241-different-ways-to-add-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-241-different-ways-to-add-parentheses"></a> LeetCode Q 241 - Different Ways to Add Parentheses</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p><p>Example 1:<br><code>Input: &quot;2-1-1&quot; ; Output: [0, 2]</code><br>Explanation:<br><code>((2-1)-1) = 0 , (2-(1-1)) = 2</code></p><p>Example 2:<br><code>Input: &quot;2*3-4*5&quot; ; Output: [-34, -14, -10, -10, 10]</code><br>Explanation:<br><code>(2*(3-(4*5))) = -34 , ((2*3)-(4*5)) = -14 , ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 , (((2*3)-4)*5) = 10</code></p><a id="more"></a><h2 id="solution-divide-and-conquer"><a class="markdownIt-Anchor" href="#solution-divide-and-conquer"></a> Solution : Divide and Conquer</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (input.charAt(i) == <span class="string">'+'</span> || input.charAt(i) == <span class="string">'-'</span> || input.charAt(i) == <span class="string">'*'</span>) &#123;</span><br><span class="line">List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num1: left) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num2: right) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) res.add(num1 + num2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) res.add(num1 - num2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) res.add(num1 * num2); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.size() == <span class="number">0</span>) </span><br><span class="line">res.add(Integer.parseInt(input));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-241-different-ways-to-add-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-241-different-ways-to-add-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 241 - Different Ways to Add Parentheses&lt;/h1&gt;
&lt;p&gt;Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;2-1-1&amp;quot; ; Output: [0, 2]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;((2-1)-1) = 0 , (2-(1-1)) = 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;2*3-4*5&amp;quot; ; Output: [-34, -14, -10, -10, 10]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;(2*(3-(4*5))) = -34 , ((2*3)-(4*5)) = -14 , ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 , (((2*3)-4)*5) = 10&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Partitioning</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ131/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ131/</id>
    <published>2019-04-28T16:36:58.000Z</published>
    <updated>2019-04-28T16:51:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-131-palindrome-partitioning"><a class="markdownIt-Anchor" href="#leetcode-q-131-palindrome-partitioning"></a> LeetCode Q 131 - Palindrome Partitioning</h1><p>Given a string s, partition s such that every substring of the partition is a palindrome.<br>Return all possible palindrome partitioning of s.</p><p>Example:<br><code>Input: &quot;aab&quot; Output: [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(s, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, List&lt;String&gt; temp, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPalindromic(s, index, i)) &#123;</span><br><span class="line">temp.add(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">backtrack(s, temp, i + <span class="number">1</span>);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span> <span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">left++; right--;</span><br><span class="line">&#125;</span><br><span class="line">retur <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-131-palindrome-partitioning&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-131-palindrome-partitioning&quot;&gt;&lt;/a&gt; LeetCode Q 131 - Palindrome Partitioning&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;br&gt;
Return all possible palindrome partitioning of s.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Restore IP Addresses</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ93/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ93/</id>
    <published>2019-04-28T16:18:59.000Z</published>
    <updated>2019-04-28T16:36:39.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-93-restore-ip-addresses"><a class="markdownIt-Anchor" href="#leetcode-q-93-restore-ip-addresses"></a> LeetCode Q 93 - Restore IP Addresses</h1><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p><p>Example:<br><code>Input: &quot;25525511135&quot; ; Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p>The key point is how to identify a valid IP address.</p><ul><li>Strings whose length greater than 3 or equals to 0 is not valid;</li><li>If the string’s length is longer than 1 and the first letter is ‘0’ then it’s invalid;</li><li>String whose integer representation greater than 255 is invalid.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(s, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(String s, <span class="keyword">int</span> index, <span class="keyword">int</span> segments, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == s.length() &amp;&amp; segments == <span class="number">4</span>) &#123;</span><br><span class="line">res.add(curr.substring(<span class="number">1</span>)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == s.length() || segments == <span class="number">4</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span> &amp;&amp; index + i &lt;= s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> num = Integer.parseInt(index, index + i);</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span> || num &gt; <span class="number">255</span> || (num &gt; <span class="number">10</span> &amp;&amp; s.charAt(index) == <span class="string">'0'</span>)) <span class="keyword">continue</span>;</span><br><span class="line">backtrack(s, index + i, segments + <span class="number">1</span>, curr + <span class="string">'.'</span> + s.substring(index, index + i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-93-restore-ip-addresses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-93-restore-ip-addresses&quot;&gt;&lt;/a&gt; LeetCode Q 93 - Restore IP Addresses&lt;/h1&gt;
&lt;p&gt;Given a string containing only digits, restore it by returning all possible valid IP address combinations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;25525511135&amp;quot; ; Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
  </entry>
  
  <entry>
    <title>Permutation in String</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ567/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ567/</id>
    <published>2019-04-26T22:32:32.000Z</published>
    <updated>2019-04-26T22:41:20.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-567-permutation-in-string"><a class="markdownIt-Anchor" href="#leetcode-q-567-permutation-in-string"></a> LeetCode Q 567 - Permutation in String</h1><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><p>Example 1:<br><code>Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; ; Output: True</code><br>Explanation: s2 contains one permutation of s1 (“ba”).<br>Example 2:<br><code>Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; ; Output: False</code></p><p><strong>Note:</strong></p><ul><li>The input strings only contain lower case letters.</li><li>The length of both given strings is in range [1, 10,000].</li></ul><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><ol><li>Swap String <em><strong>s1</strong></em>, count the times each char appears.</li><li>Get the first <em><strong>s1.length()</strong></em> char of String <em><strong>s2</strong></em>, to check if the times of each char in <em><strong>s2</strong></em> mataches that in <em><strong>s1</strong></em>.<ul><li>If it matches, we return <strong>true</strong>.</li><li>If not, we apply <strong>slinding window</strong> algorithm to keep checking, increasing the last char and decreasing the first char.</li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.length() &gt; s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">count[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (allZeros(count)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">count[s2.charAt(i - s1.length()) - <span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">if</span> (allZeros(count)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allZeros</span><span class="params">(<span class="keyword">int</span>[] count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c: count)</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-567-permutation-in-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-567-permutation-in-string&quot;&gt;&lt;/a&gt; LeetCode Q 567 - Permutation in String&lt;/h1&gt;
&lt;p&gt;Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; ; Output: True&lt;/code&gt;&lt;br&gt;
Explanation: s2 contains one permutation of s1 (“ba”).&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input:s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; ; Output: False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input strings only contain lower case letters.&lt;/li&gt;
&lt;li&gt;The length of both given strings is in range [1, 10,000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Max Consecutive Ones III</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ1004/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ1004/</id>
    <published>2019-04-26T22:27:54.000Z</published>
    <updated>2019-04-26T22:33:32.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1004-max-consecutive-ones-iii"><a class="markdownIt-Anchor" href="#leetcode-q-1004-max-consecutive-ones-iii"></a> LeetCode Q 1004 - Max Consecutive Ones III</h1><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.</p><p>Example 1:<br><code>Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 ; Output: 6</code><br>Explanation: [1,1,1,0,0,1,1,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.<br>Example 2:<br><code>Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 ; Output: 10</code><br>Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>0 &lt;= K &lt;= A.length</li><li>A[i] is 0 or 1</li></ul><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><p>This problem is similar to <a href="/2019/04/26/leetcodeQ424/" title="Longest Repeating Character Replacement">Longest Repeating Character Replacement</a>.</p><p>Without constraints, maximum consecutive Ones length is<br><code>length of array</code><br>With constraints, then it becomes<br><code>length of array - number of 1s in the array &lt;= k</code></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A.length &lt;= K) <span class="keyword">return</span> A.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, maxCount = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (end &lt; A.length) &#123;</span><br><span class="line">count[A[end]]++;</span><br><span class="line"><span class="keyword">while</span> (end - start + <span class="number">1</span> - count[<span class="number">1</span>] &gt; K) &#123;</span><br><span class="line">count[A[start++]]--;</span><br><span class="line">&#125;</span><br><span class="line">maxCount = Math.max(maxCount, end - start + <span class="number">1</span>);</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1004-max-consecutive-ones-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1004-max-consecutive-ones-iii&quot;&gt;&lt;/a&gt; LeetCode Q 1004 - Max Consecutive Ones III&lt;/h1&gt;
&lt;p&gt;Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: [1,1,1,0,0,1,1,1,1,1,1]&lt;br&gt;
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 ; Output: 10&lt;/code&gt;&lt;br&gt;
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]&lt;br&gt;
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= K &amp;lt;= A.length&lt;/li&gt;
&lt;li&gt;A[i] is 0 or 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Repeating Character Replacement</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ424/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ424/</id>
    <published>2019-04-26T22:20:24.000Z</published>
    <updated>2019-04-26T22:29:55.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-424-longest-repeating-character-replacement"><a class="markdownIt-Anchor" href="#leetcode-q-424-longest-repeating-character-replacement"></a> LeetCode Q 424 - Longest Repeating Character Replacement</h1><p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p><p><strong>Note:</strong> Both the string’s length and k will not exceed 104.</p><p>Example 1:<br><code>Input: s = &quot;ABAB&quot;, k = 2 ; Output: 4</code><br>Explanation: Replace the two 'A’s with two 'B’s or vice versa.<br>Example 2:<br><code>Input: s = &quot;AABABBA&quot;, k = 1 ; Output: 4</code><br>Explanation: Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”. The substring “BBBB” has the longest repeating letters, which is 4.</p><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><p>The problem says that we can make at most k changes to the string (any character can be replaced with any other character).</p><ol><li><p>First, let’s say there were no constraints like the k. Given a string convert it to a string with all same characters with minimal changes. The <strong>answer</strong> to this is<br><code>length of the entire string - number of times of the maximum occurring character in the string</code>.</p></li><li><p>Given this, we can apply the at most k changes constraint and maintain a sliding window such that<br><code>length of substring - number of times of the maximum occurring character in the substring) &lt;= k</code></p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, maxCount = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">count[s.charAt(end) - <span class="string">'A'</span>]++;</span><br><span class="line">maxCount = Math.max(maxCount, count[s.charAt(end) - <span class="string">'A'</span>]);</span><br><span class="line"><span class="keyword">while</span> (end - start + <span class="number">1</span> - maxCount &gt; k) &#123;</span><br><span class="line">count[s.charAt(start++) - <span class="string">'A'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="comment">// update maxCount</span></span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; maxCount) maxCount = count[i];</span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-424-longest-repeating-character-replacement&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-424-longest-repeating-character-replacement&quot;&gt;&lt;/a&gt; LeetCode Q 424 - Longest Repeating Character Replacement&lt;/h1&gt;
&lt;p&gt;Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Both the string’s length and k will not exceed 104.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;ABAB&amp;quot;, k = 2 ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Replace the two &#39;A’s with two &#39;B’s or vice versa.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;AABABBA&amp;quot;, k = 1 ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”. The substring “BBBB” has the longest repeating letters, which is 4.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Partition to K Equal Sum Subsets</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ698/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ698/</id>
    <published>2019-04-26T22:11:37.000Z</published>
    <updated>2019-04-26T22:18:36.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-698-partition-to-k-equal-sum-subsets"><a class="markdownIt-Anchor" href="#leetcode-q-698-partition-to-k-equal-sum-subsets"></a> LeetCode Q 698 - Partition to K Equal Sum Subsets</h1><p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:<br><code>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 ; Output: True</code><br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= k &lt;= len(nums) &lt;= 16.</li><li>0 &lt; nums[i] &lt; 10000.</li></ul><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.length &lt; k || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">sum /= k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> backtrack(nums, k, sum, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> currSum, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boundary cases</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currSum == targetSum) </span><br><span class="line"><span class="keyword">return</span> backtrack(nums, k - <span class="number">1</span>, targetSum, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; targetSum)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep recursion:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">visited[i] = <span class="keyword">true</span>; <span class="comment">//choose</span></span><br><span class="line"><span class="keyword">if</span> (dfs(nums, k, targetSum, currSum + nums[i], i + <span class="number">1</span>, visited))   <span class="comment">// explore</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[i] = <span class="keyword">false</span>; <span class="comment">// unchoose</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-698-partition-to-k-equal-sum-subsets&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-698-partition-to-k-equal-sum-subsets&quot;&gt;&lt;/a&gt; LeetCode Q 698 - Partition to K Equal Sum Subsets&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 ; Output: True&lt;/code&gt;&lt;br&gt;
Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= k &amp;lt;= len(nums) &amp;lt;= 16.&lt;/li&gt;
&lt;li&gt;0 &amp;lt; nums[i] &amp;lt; 10000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Longest Turbulent Subarray</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ978/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ978/</id>
    <published>2019-04-26T22:00:24.000Z</published>
    <updated>2019-04-26T22:11:12.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-978-longest-turbulent-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-978-longest-turbulent-subarray"></a> LeetCode Q 978 - Longest Turbulent Subarray</h1><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p><ul><li>For <code>i &lt;= k &lt; j, A[k] &gt; A[k+1]</code> when k is odd, and <code>A[k] &lt; A[k+1]</code> when k is even;</li><li>OR, for <code>i &lt;= k &lt; j, A[k] &gt; A[k+1]</code> when k is even, and <code>A[k] &lt; A[k+1]</code> when k is odd.<br>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.<br>Return the length of a maximum size turbulent subarray of A.</li></ul><p>Example 1:<br><code>Input: [9,4,2,10,7,8,8,1,9] ; Output: 5</code><br>Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])<br>Example 2:<br><code>Input: [4,8,12,16] ; Output: 2</code><br>Example 3:<br><code>Input: [100] ; Output: 1</code></p><p><strong>Note:</strong></p><ul><li><code>1 &lt;= A.length &lt;= 40000</code></li><li><code>0 &lt;= A[i] &lt;= 10^9</code></li></ul><p>Similar Question: <a href="/2019/04/24/leetcodeQ376/" title="Wiggle Subsequence">Wiggle Subsequence</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h2 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h2><ol><li><p><strong>States</strong><br><code>up[i]</code>: the maximum length until <em><strong>i</strong></em> if <em><strong>ith</strong></em> number is in peak.<br><code>down[i]</code>: the maximum length until <em><strong>i</strong></em> if <em><strong>ith</strong></em> number is in valley.</p></li><li><p><strong>State Transfer Function:</strong></p><ul><li><code>if (A[i] &gt; A[i - 1])</code> then <code>up[i] = down[i] + 1; down[i] = 1</code></li><li><code>if (A[i] &lt; A[i - 1])</code> then <code>dwon[i] = up[i] + 1; up[i] = 1</code></li><li><code>if (A[i] == A[i - 1])</code> then <code>up[i] = down[i] = 1</code></li></ul></li><li><p><strong>Optimization:</strong> Since the <em><strong>ith</strong></em> state only depends on the <em><strong>(i-1)th</strong></em> state, therefore we can just use two variables <em><strong>up</strong></em> and <em><strong>down</strong></em>.</p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">up = down + <span class="number">1</span>;</span><br><span class="line">down = <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, up);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>])&#123;</span><br><span class="line">down = up + <span class="number">1</span>;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, down);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">up = down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-sliding-window-todo"><a class="markdownIt-Anchor" href="#solution-2-sliding-window-todo"></a> Solution 2: Sliding Window (TODO)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-978-longest-turbulent-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-978-longest-turbulent-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 978 - Longest Turbulent Subarray&lt;/h1&gt;
&lt;p&gt;A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1]&lt;/code&gt; when k is odd, and &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt; when k is even;&lt;/li&gt;
&lt;li&gt;OR, for &lt;code&gt;i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1]&lt;/code&gt; when k is even, and &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt; when k is odd.&lt;br&gt;
That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.&lt;br&gt;
Return the length of a maximum size turbulent subarray of A.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [9,4,2,10,7,8,8,1,9] ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: (A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; A[5])&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [4,8,12,16] ; Output: 2&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [100] ; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= A.length &amp;lt;= 40000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= A[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/24/leetcodeQ376/&quot; title=&quot;Wiggle Subsequence&quot;&gt;Wiggle Subsequence&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Increasing Path in a Matrix</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ329/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ329/</id>
    <published>2019-04-26T21:43:58.000Z</published>
    <updated>2019-04-26T22:19:47.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-329-longest-increasing-path-in-a-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-329-longest-increasing-path-in-a-matrix"></a> LeetCode Q 329 - Longest Increasing Path in a Matrix</h1><p>Given an integer matrix, find the length of the longest increasing path.<br>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><p>Example 1:<br><code>Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4</code><br>Explanation: The longest increasing path is [1, 2, 6, 9].<br>Example 2:<br><code>Input: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4</code><br>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p><strong>DFS + Memorization</strong><br><code>memo[i][j]</code>: the maximum length of increasing numbers until point [i][j]</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">booelan visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"><span class="keyword">int</span>[] directions = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">res = Math.max(res, dfs(matrix, i, j, memo, visited))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] memo, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[] dirictions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[row][col]) <span class="keyword">return</span> memo[row][col];</span><br><span class="line"><span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">nx = row + directions[i];</span><br><span class="line">ny = col + directions[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &gt; matrix[x][y])</span><br><span class="line">res = Math.max(res, <span class="number">1</span> + dfs(matrix, nx, ny, memo, visited, directions));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">memo[x][y] = res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-329-longest-increasing-path-in-a-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-329-longest-increasing-path-in-a-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 329 - Longest Increasing Path in a Matrix&lt;/h1&gt;
&lt;p&gt;Given an integer matrix, find the length of the longest increasing path.&lt;br&gt;
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest increasing path is [1, 2, 6, 9].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Memorization" scheme="http://yoursite.com/tags/Memorization/"/>
    
  </entry>
  
</feed>
