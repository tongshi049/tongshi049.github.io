<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-23T00:14:59.521Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Edit Distance</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ72/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ72/</id>
    <published>2019-04-23T00:10:51.000Z</published>
    <updated>2019-04-23T00:14:59.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-72-edit-distance"><a class="markdownIt-Anchor" href="#leetcode-q-72-edit-distance"></a> LeetCode Q 72 - Edit Distance</h1><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.<br>You have the following 3 operations permitted on a word:</p><ol><li>Insert a character</li><li>Delete a character</li><li>Replace a character<br>Example 1:<br><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; ; Output: 3</code><br>Explanation:<br><code>horse -&gt; rorse (replace 'h' with 'r') rorse -&gt; rose (remove 'r') rose -&gt; ros (remove 'e')</code><br>Example 2:<br><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot; ; Output: 5</code><br>Explanation:<br><code>intention -&gt; inention (remove 't') inention -&gt; enention (replace 'i' with 'e') enention -&gt; exention (replace 'n' with 'x') exention -&gt; exection (replace 'n' with 'c') exection -&gt; execution (insert 'u')</code></li></ol><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p>dp[i][j]: the distance between ith char in word1 and jth char in word2</p><ul><li>if (word1.charAt(i) == word1.charAt(j)) dp[i][j] = dp[i - 1][j - 1];</li><li>else we can get to j from i though<ul><li>replace a char, dp[i][j] = dp[i - 1][j - 1]</li><li>delete a char, dp[i][j] = dp[i][j - 1];</li><li>insert a char, dp[i][j] = dp[i - 1][j];</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word1.length() == <span class="number">0</span>) <span class="keyword">return</span> word2.length(); <span class="comment">// insert</span></span><br><span class="line"><span class="keyword">if</span> (word2.length() == <span class="number">0</span>) <span class="keyword">return</span> word1.length(); <span class="comment">// delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = word1.length(), len2 = word2.length();</span><br><span class="line"><span class="comment">// dp[i][j]: the distance between ith char in word1 and jth char in word2</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// word1 is ""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++) </span><br><span class="line">dp[<span class="number">0</span>][i] = i; </span><br><span class="line"><span class="comment">// word2 is ""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-72-edit-distance&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-72-edit-distance&quot;&gt;&lt;/a&gt; LeetCode Q 72 - Edit Distance&lt;/h1&gt;
&lt;p&gt;Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.&lt;br&gt;
You have the following 3 operations permitted on a word:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Insert a character&lt;/li&gt;
&lt;li&gt;Delete a character&lt;/li&gt;
&lt;li&gt;Replace a character&lt;br&gt;
Example 1:&lt;br&gt;
&lt;code&gt;Input: word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot; ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;horse -&amp;gt; rorse (replace &#39;h&#39; with &#39;r&#39;) rorse -&amp;gt; rose (remove &#39;r&#39;) rose -&amp;gt; ros (remove &#39;e&#39;)&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot; ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;intention -&amp;gt; inention (remove &#39;t&#39;) inention -&amp;gt; enention (replace &#39;i&#39; with &#39;e&#39;) enention -&amp;gt; exention (replace &#39;n&#39; with &#39;x&#39;) exention -&amp;gt; exection (replace &#39;n&#39; with &#39;c&#39;) exection -&amp;gt; execution (insert &#39;u&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Climbing Stairs</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ70/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ70/</id>
    <published>2019-04-23T00:08:37.000Z</published>
    <updated>2019-04-23T00:12:28.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-70-climbing-stairs"><a class="markdownIt-Anchor" href="#leetcode-q-70-climbing-stairs"></a> LeetCode Q 70 - Climbing Stairs</h1><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><p>Example 1:<br><code>Input: 2 ; Output: 2</code><br>Explanation: There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps<br>Example 2:<br><code>Input: 3 ; Output: 3</code><br>Explanation: There are three ways to climb to the top.</li><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-70-climbing-stairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-70-climbing-stairs&quot;&gt;&lt;/a&gt; LeetCode Q 70 - Climbing Stairs&lt;/h1&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
&lt;p&gt;Note: Given n will be a positive integer.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: 2 ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: There are two ways to climb to the top.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1 step + 1 step&lt;/li&gt;
&lt;li&gt;2 steps&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: 3 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: There are three ways to climb to the top.&lt;/li&gt;
&lt;li&gt;1 step + 1 step + 1 step&lt;/li&gt;
&lt;li&gt;1 step + 2 steps&lt;/li&gt;
&lt;li&gt;2 steps + 1 step&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Path Sum</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ64/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ64/</id>
    <published>2019-04-23T00:02:22.000Z</published>
    <updated>2019-04-23T00:12:36.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-64-minimum-path-sum"><a class="markdownIt-Anchor" href="#leetcode-q-64-minimum-path-sum"></a> LeetCode Q 64 - Minimum Path Sum</h1><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.<br>Note: You can only move either down or right at any point in time.</p><p>Example:<br><code>Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7</code><br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp-using-an-additional-array"><a class="markdownIt-Anchor" href="#solution-1-dp-using-an-additional-array"></a> Solution 1: DP using an additional array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col]; dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-in-place"><a class="markdownIt-Anchor" href="#solution-2-dp-in-place"></a> Solution 2: DP in place</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) </span><br><span class="line">grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-64-minimum-path-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-64-minimum-path-sum&quot;&gt;&lt;/a&gt; LeetCode Q 64 - Minimum Path Sum&lt;/h1&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.&lt;br&gt;
Note: You can only move either down or right at any point in time.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: Because the path 1→3→1→1→1 minimizes the sum.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Paths II</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ63/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ63/</id>
    <published>2019-04-22T23:50:34.000Z</published>
    <updated>2019-04-23T00:12:42.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-63-unique-paths-ii"><a class="markdownIt-Anchor" href="#leetcode-q-63-unique-paths-ii"></a> LeetCode Q 63 - Unique Paths II</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p><p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p><p>Comparing with <a href="/2019/04/22/leetcodeQ62/" title="Unique Path">Unique Path</a>, now we have <strong>obstable</strong>!</p><p>Note: m and n will be at most 100.<br>Example 1:<br><code>Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2</code><br>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:</p><ol><li>Right -&gt; Right -&gt; Down -&gt; Down</li><li>Down -&gt; Down -&gt; Right -&gt; Right</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp-using-an-additional-array"><a class="markdownIt-Anchor" href="#solution-1-dp-using-an-additional-array"></a> Solution 1: DP using an additional array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = obstacleGrid.length, col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-in-place"><a class="markdownIt-Anchor" href="#solution-2-dp-in-place"></a> Solution 2: DP in place</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line"><span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line"><span class="comment">// no paths to the destination.</span></span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filling the values for the first column</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filling the values for the first row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line"><span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line"><span class="comment">// i.e. From above and left.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line"><span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-63-unique-paths-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-63-unique-paths-ii&quot;&gt;&lt;/a&gt; LeetCode Q 63 - Unique Paths II&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;br&gt;
Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;/p&gt;
&lt;p&gt;An obstacle and empty space is marked as 1 and 0 respectively in the grid.&lt;/p&gt;
&lt;p&gt;Comparing with &lt;a href=&quot;/2019/04/22/leetcodeQ62/&quot; title=&quot;Unique Path&quot;&gt;Unique Path&lt;/a&gt;, now we have &lt;strong&gt;obstable&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Note: m and n will be at most 100.&lt;br&gt;
Example 1:&lt;br&gt;
&lt;code&gt;Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
There is one obstacle in the middle of the 3x3 grid above.&lt;br&gt;
There are two ways to reach the bottom-right corner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Right -&amp;gt; Right -&amp;gt; Down -&amp;gt; Down&lt;/li&gt;
&lt;li&gt;Down -&amp;gt; Down -&amp;gt; Right -&amp;gt; Right&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Paths</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ62/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ62/</id>
    <published>2019-04-22T23:47:30.000Z</published>
    <updated>2019-04-23T00:12:46.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-62-unique-paths"><a class="markdownIt-Anchor" href="#leetcode-q-62-unique-paths"></a> LeetCode Q 62 - Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>How many possible unique paths are there?</p><p>Note: m and n will be at most 100.</p><p>Example 1:<br><code>Input: m = 3, n = 2 ; Output: 3</code><br>Explanation:<br>From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p><ol><li>Right -&gt; Right -&gt; Down</li><li>Right -&gt; Down -&gt; Right</li><li>Down -&gt; Right -&gt; Right<br>Example 2:<br><code>Input: m = 7, n = 3 ; Output: 28</code></li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-62-unique-paths&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-62-unique-paths&quot;&gt;&lt;/a&gt; LeetCode Q 62 - Unique Paths&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;br&gt;
How many possible unique paths are there?&lt;/p&gt;
&lt;p&gt;Note: m and n will be at most 100.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: m = 3, n = 2 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Right -&amp;gt; Right -&amp;gt; Down&lt;/li&gt;
&lt;li&gt;Right -&amp;gt; Down -&amp;gt; Right&lt;/li&gt;
&lt;li&gt;Down -&amp;gt; Right -&amp;gt; Right&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: m = 7, n = 3 ; Output: 28&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Subarray</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ53/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ53/</id>
    <published>2019-04-22T23:24:57.000Z</published>
    <updated>2019-04-22T23:43:52.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-53-maximum-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-53-maximum-subarray"></a> LeetCode Q 53 - Maximum Subarray</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:<br><code>Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6</code><br>Explanation: [4,-1,2,1] has the largest sum = 6.<br><strong>Follow up:</strong> If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>] &lt;= <span class="number">0</span>) dp[i] = nums[i];</span><br><span class="line"><span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">maxSum = Math.max(maxSum, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-divide-and-conquer"><a class="markdownIt-Anchor" href="#solution-2-divide-and-conquer"></a> Solution 2: Divide and Conquer</h3><p>A quite clean but detailed explanation can be found <a href="https://leetcode.com/problems/maximum-subarray/discuss/232505/java-solution-divide-and-conquer-way-dynamic-programming-way" target="_blank" rel="noopener">here</a>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> leftSum = sum(nums, left, mid);</span><br><span class="line"><span class="keyword">int</span> rightSum = sum(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">int</span> crossSum = crossSum(nums, left, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(leftSum, Math.max(rightSum, crossSum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftSum = Integer.MIN_VALUE, rightSum = Integer.MIN_VALUE, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (leftSum &lt; sum) leftSum = sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (rightSum &lt; sum) rightSum = sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-53-maximum-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-53-maximum-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 53 - Maximum Subarray&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: [4,-1,2,1] has the largest sum = 6.&lt;br&gt;
&lt;strong&gt;Follow up:&lt;/strong&gt; If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Longest Valid Parentheses</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ32/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ32/</id>
    <published>2019-04-22T23:04:52.000Z</published>
    <updated>2019-04-22T23:24:22.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-32-longest-valid-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-32-longest-valid-parentheses"></a> LeetCode Q 32 - Longest Valid Parentheses</h1><p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><p>Example 1:<br><code>Input: &quot;(()&quot; ; Output: 2</code><br>Explanation: The longest valid parentheses substring is “()”<br>Example 2:<br><code>Input: &quot;)()())&quot; ; Output: 4</code><br>Explanation: The longest valid parentheses substring is “()()”</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-stack"><a class="markdownIt-Anchor" href="#solution-1-stack"></a> Solution 1: Stack</h3><p>The integer stored the index of invalid ‘)’ and last ‘(’</p><ul><li>whenver we encount a ‘(’, we also push its index;</li><li>whenever we encounter a ‘)’, we first <strong>pop</strong> the 1st element from stack, there are <strong>two</strong> cases:<ul><li>the 1st element is the index of ‘(’, in which case the stack must not be <strong>empty</strong>, since we always store the last index of invalid ‘)’ in the stack, then update the <strong>maxLen</strong>;</li><li>the 1st element is the index of ‘)’, in which case the stack should be <strong>empty</strong>, since we only store the last index of invalid ‘)’ in the stack, then update the index of ‘)’ stored in the stack.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">stack.push(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">stack.push(i);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">maxLen = Math.max(maxLen, i - stack.peek());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-todo"><a class="markdownIt-Anchor" href="#solution-2-dp-todo"></a> Solution 2: DP (TODO)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-32-longest-valid-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-32-longest-valid-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 32 - Longest Valid Parentheses&lt;/h1&gt;
&lt;p&gt;Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;(()&amp;quot; ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: The longest valid parentheses substring is “()”&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;)()())&amp;quot; ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest valid parentheses substring is “()()”&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Regular Expression Matching</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ10/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ10/</id>
    <published>2019-04-22T19:28:46.000Z</published>
    <updated>2019-04-22T23:05:17.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-10-regular-expression-matching"><a class="markdownIt-Anchor" href="#leetcode-q-10-regular-expression-matching"></a> LeetCode Q 10 - Regular Expression Matching</h1><p>Given an input string (s) and a pattern §, implement regular expression matching with support for ‘.’ and ‘*’.<br><strong>’.’</strong> Matches any single character.<br><strong>’*’</strong> Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p><p><strong>Note:</strong><br><strong>s</strong> could be <strong>empty</strong> and contains only lowercase letters a-z.<br><strong>p</strong> could be <strong>empty</strong> and contains only lowercase letters a-z, and characters like <strong>.</strong> or <strong>*</strong>.<br>Example 1:<br><code>Input: s = &quot;aa&quot; p = &quot;a&quot; ; Output: false</code><br>Explanation: “a” does not match the entire string “aa”.<br>Example 2:<br><code>Input: s = &quot;aa&quot; p = &quot;a*&quot; ; Output: true</code><br>Explanation: ‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.<br>Example 3:<br><code>Input: s = &quot;ab&quot; p = &quot;.*&quot; ; Output: true</code><br>Explanation: “.*” means “zero or more (*) of any character (.)”.<br>Example 4:<br><code>Input: s = &quot;aab&quot; p = &quot;c*a*b&quot; ; Output: true</code><br>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.<br>Example 5:<br><code>Input: s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot; ; Output: false</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-recursion"><a class="markdownIt-Anchor" href="#solution-1-recursion"></a> Solution 1: Recursion</h3><p><strong>Some tips:</strong></p><ol><li><code>if (p.length() == 0) return s.length == 0</code>;</li><li><code>s.length()</code> is also allowed to be <strong>0</strong>;</li><li>Line 6: <code>if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '\*')</code>, we can return</li></ol><ul><li><code>isMatch(s, p.substring(2))</code>; we ignore the 1st char of <strong>p</strong>, and also the 2nd char of <strong>p</strong> (i.e. ‘*’) ;</li><li>or <code>firstMatch &amp;&amp; isMatch(s.substring(1), p)</code>; when the 1st char in <strong>s</strong> and <strong>p</strong> are matched, whether the 1st char in <strong>p</strong> is the same as that in **s **or the 1st char in <strong>p</strong> is ‘.’, since the 2nd char in <strong>p</strong> is ‘*’, we can still use then <strong>entire p</strong> to match <strong>s</strong> from the 2nd char (i.e. <code>s.substring(1)</code>).</li></ul><ol start="4"><li>Line 8: <code>else</code>, we can return</li></ol><ul><li><code>firstMatch &amp;&amp; isMatch(s.substring(1), p.substring(1))</code>, in this case, the 1st char in <strong>s</strong> and <strong>p</strong> must be matched, and we compare their substrings (i.e. <code>s.substring(1)</code> and <code>s.substring(1)</code>).</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span> || p.length() == <span class="number">0</span>) <span class="keyword">return</span> s.length == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s could be empty</span></span><br><span class="line"><span class="keyword">boolean</span> firstMatch = (s.length() &gt; <span class="number">0</span> &amp;&amp; (s.charAt(<span class="number">0</span>) == p.charAt(<span class="number">0</span>) || p.charAt(<span class="number">0</span>) == <span class="string">'.'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p.length() &gt;= <span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>) == <span class="string">'*'</span>) </span><br><span class="line"><span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>)) || firstMatch &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> firstMatch &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp"><a class="markdownIt-Anchor" href="#solution-2-dp"></a> Solution 2: DP</h3><ol><li><code>If p.charAt(j) == s.charAt(i)</code> :  <code>dp[i][j] = dp[i-1][j-1]</code>;</li><li><code>If p.charAt(j) == '.'</code> : <code>dp[i][j] = dp[i-1][j-1]</code>;</li><li><code>If p.charAt(j) == '\*'</code>: here are two sub conditions:</li></ol><ul><li><code>if p.charAt(j-1) != s.charAt(i)</code> 1st char in <strong>s</strong> and <strong>p</strong> is matched<ul><li><code>dp[i][j] = dp[i][j-2]</code> in this case, a* only counts as empty</li></ul></li><li><code>if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'</code><ul><li><code>dp[i][j] = dp[i-1][j]</code> in this case, a* counts as multiple a</li><li><code>dp[i][j] = dp[i][j-1]</code> in this case, a* counts as single a **</li><li><code>dp[i][j] = dp[i][j-2]</code> in this case, a* counts as empty</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p.length() == <span class="number">0</span>) <span class="keyword">return</span> s.length() == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.charAt(i) == <span class="string">'\*'</span> &amp;&amp; dp[<span class="number">0</span>][i-<span class="number">1</span>]) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p.length(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>) </span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line"><span class="keyword">if</span> (p.charAt(j) == <span class="string">'\*'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.charAt(j-<span class="number">1</span>) != s.charAt(i) &amp;&amp; p.charAt(j-<span class="number">1</span>) != <span class="string">'.'</span>) </span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = (dp[i+<span class="number">1</span>][j] || dp[i][j+<span class="number">1</span>] || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length()][p.length()];   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-10-regular-expression-matching&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-10-regular-expression-matching&quot;&gt;&lt;/a&gt; LeetCode Q 10 - Regular Expression Matching&lt;/h1&gt;
&lt;p&gt;Given an input string (s) and a pattern §, implement regular expression matching with support for ‘.’ and ‘*’.&lt;br&gt;
&lt;strong&gt;’.’&lt;/strong&gt; Matches any single character.&lt;br&gt;
&lt;strong&gt;’*’&lt;/strong&gt; Matches zero or more of the preceding element.&lt;br&gt;
The matching should cover the entire input string (not partial).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;s&lt;/strong&gt; could be &lt;strong&gt;empty&lt;/strong&gt; and contains only lowercase letters a-z.&lt;br&gt;
&lt;strong&gt;p&lt;/strong&gt; could be &lt;strong&gt;empty&lt;/strong&gt; and contains only lowercase letters a-z, and characters like &lt;strong&gt;.&lt;/strong&gt; or &lt;strong&gt;*&lt;/strong&gt;.&lt;br&gt;
Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;aa&amp;quot; p = &amp;quot;a&amp;quot; ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: “a” does not match the entire string “aa”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;aa&amp;quot; p = &amp;quot;a*&amp;quot; ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: ‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;ab&amp;quot; p = &amp;quot;.*&amp;quot; ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: “.*” means “zero or more (*) of any character (.)”.&lt;br&gt;
Example 4:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;aab&amp;quot; p = &amp;quot;c*a*b&amp;quot; ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.&lt;br&gt;
Example 5:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;mississippi&amp;quot; p = &amp;quot;mis*is*p*.&amp;quot; ; Output: false&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>Longest Palindromic Substring</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ5/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ5/</id>
    <published>2019-04-22T18:56:43.000Z</published>
    <updated>2019-04-22T19:27:33.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-5-longest-palindromic-substring"><a class="markdownIt-Anchor" href="#leetcode-q-5-longest-palindromic-substring"></a> LeetCode Q 5 - Longest Palindromic Substring</h1><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p><p>Example 1:<br><code>Input: &quot;babad&quot; ; Output: &quot;bab&quot;</code><br>Note: “aba” is also a valid answer.<br>Example 2:<br><code>Input: &quot;cbbd&quot; ; Output: &quot;bb&quot;</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-center-expanding"><a class="markdownIt-Anchor" href="#solution-1-center-expanding"></a> Solution 1: Center Expanding</h3><p><strong>Time Complexity: O(n^2)</strong><br><strong>Space Complexity: O(1)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxLen;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pos;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">centerExpanding(s, i, i);</span><br><span class="line">centerExpanding(s, i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s.substring(pos, pos + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">centerExpanding</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">left--; right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxLen &lt; right - left - <span class="number">1</span>) &#123;</span><br><span class="line">pos = left + <span class="number">1</span>;</span><br><span class="line">maxLen = right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp"><a class="markdownIt-Anchor" href="#solution-2-dp"></a> Solution 2: DP</h3><p><strong>Time Complexity: O(n^2)</strong><br><strong>Space Complexity: O(n^2)</strong></p><ol><li>Base Case:<br><code>dp[i][i] = T ; dp[i][i + 1] = s.charAt(i) == s.charAt(i + 1)</code></li><li>State Transfer Function:<br><code>dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s.charAt(i) == s.charAt(j)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; ((i - j) &lt;= <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>])) &#123;</span><br><span class="line">dp[j][i] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[j][i] &amp;&amp; maxLen &lt; i - j + <span class="number">1</span>) &#123;</span><br><span class="line">maxLen = i - j + <span class="number">1</span>;</span><br><span class="line">pos = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-5-longest-palindromic-substring&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-5-longest-palindromic-substring&quot;&gt;&lt;/a&gt; LeetCode Q 5 - Longest Palindromic Substring&lt;/h1&gt;
&lt;p&gt;Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;babad&amp;quot; ; Output: &amp;quot;bab&amp;quot;&lt;/code&gt;&lt;br&gt;
Note: “aba” is also a valid answer.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;cbbd&amp;quot; ; Output: &amp;quot;bb&amp;quot;&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Sort Characters By Frequency</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ451/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ451/</id>
    <published>2019-04-21T22:04:39.000Z</published>
    <updated>2019-04-21T22:34:38.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-451-sort-characters-by-frequency"><a class="markdownIt-Anchor" href="#leetcode-q-451-sort-characters-by-frequency"></a> LeetCode Q 451 - Sort Characters By Frequency</h1><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong><br><code>Input: &quot;tree&quot; ; Output: &quot;eert&quot;</code><br>Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.<br><strong>Example 2:</strong><br><code>Input: &quot;cccaaa&quot; ; Output: &quot;cccaaa&quot;</code><br>Explanation: Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer. Note that “cacaca” is incorrect, as the same characters must be together.<br><strong>Example 3:</strong><br><code>Input: &quot;Aabb&quot; ; Output: &quot;bbAa&quot;</code><br>Explanation: “bbaA” is also a valid answer, but “Aabb” is incorrect. Note that ‘A’ and ‘a’ are treated as two different characters.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) </span><br><span class="line">map.put(ch, map.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt;[] buckets = <span class="keyword">new</span> List[s.length() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(ch);</span><br><span class="line"><span class="keyword">if</span> (buckets[freq] == <span class="keyword">null</span>) buckets[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">buckets[freq].add(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (buckets[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: buckets[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; i; num++)</span><br><span class="line">res.append(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-451-sort-characters-by-frequency&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-451-sort-characters-by-frequency&quot;&gt;&lt;/a&gt; LeetCode Q 451 - Sort Characters By Frequency&lt;/h1&gt;
&lt;p&gt;Given a string, sort it in decreasing order based on the frequency of characters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;tree&amp;quot; ; Output: &amp;quot;eert&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;cccaaa&amp;quot; ; Output: &amp;quot;cccaaa&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer. Note that “cacaca” is incorrect, as the same characters must be together.&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;Aabb&amp;quot; ; Output: &amp;quot;bbAa&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: “bbaA” is also a valid answer, but “Aabb” is incorrect. Note that ‘A’ and ‘a’ are treated as two different characters.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Longest Palindrome</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ409/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ409/</id>
    <published>2019-04-21T22:01:23.000Z</published>
    <updated>2019-04-21T22:16:38.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-409-longest-palindrome"><a class="markdownIt-Anchor" href="#leetcode-q-409-longest-palindrome"></a> LeetCode Q 409 - Longest Palindrome</h1><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br>This is case sensitive, for example “Aa” is not considered a palindrome here.<br>Note:Assume the length of given string will not exceed 1,010.</p><p><strong>Example:</strong><br><code>Input: &quot;abccccdd&quot; ; Output: 7</code><br>Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray())</span><br><span class="line">count[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>, hasOdd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: count) &#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) maxLen += num;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">hasOdd = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> maxLen += (num - <span class="number">1</span>); <span class="comment">// "ccc" --&gt; 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasOdd == <span class="number">0</span> ? maxLen : maxLen + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-409-longest-palindrome&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-409-longest-palindrome&quot;&gt;&lt;/a&gt; LeetCode Q 409 - Longest Palindrome&lt;/h1&gt;
&lt;p&gt;Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.&lt;br&gt;
This is case sensitive, for example “Aa” is not considered a palindrome here.&lt;br&gt;
Note:Assume the length of given string will not exceed 1,010.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;abccccdd&amp;quot; ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Find the Difference</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ389/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ389/</id>
    <published>2019-04-21T21:54:34.000Z</published>
    <updated>2019-04-21T22:16:54.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-389-find-the-difference"><a class="markdownIt-Anchor" href="#leetcode-q-389-find-the-difference"></a> LeetCode Q 389 - Find the Difference</h1><p>Given two strings s and t which consist of only lowercase letters.<br>String t is generated by random shuffling string s and then add one more letter at a random position.<br>Find the letter that was added in t.</p><p><strong>Example:</strong><br><code>Input: s = &quot;abcd&quot; t = &quot;abcde&quot; ; Output: e</code><br>Explanation: ‘e’ is the letter that was added.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray()) sum += (<span class="keyword">int</span>)ch;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray()) sum -= (<span class="keyword">int</span>)ch;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-389-find-the-difference&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-389-find-the-difference&quot;&gt;&lt;/a&gt; LeetCode Q 389 - Find the Difference&lt;/h1&gt;
&lt;p&gt;Given two strings s and t which consist of only lowercase letters.&lt;br&gt;
String t is generated by random shuffling string s and then add one more letter at a random position.&lt;br&gt;
Find the letter that was added in t.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; ; Output: e&lt;/code&gt;&lt;br&gt;
Explanation: ‘e’ is the letter that was added.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>First Unique Character in a String</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ387/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ387/</id>
    <published>2019-04-21T21:51:57.000Z</published>
    <updated>2019-04-21T21:53:55.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-387-first-unique-character-in-a-string"><a class="markdownIt-Anchor" href="#leetcode-q-387-first-unique-character-in-a-string"></a> LeetCode Q 387 - First Unique Character in a String</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p>Examples:<br><code>s = &quot;leetcode&quot; return 0. s = &quot;loveleetcode&quot;, return 2.</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray())</span><br><span class="line">count[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(i)] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-387-first-unique-character-in-a-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-387-first-unique-character-in-a-string&quot;&gt;&lt;/a&gt; LeetCode Q 387 - First Unique Character in a String&lt;/h1&gt;
&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;
&lt;code&gt;s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2.&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Design Twitter</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ355/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ355/</id>
    <published>2019-04-21T17:11:41.000Z</published>
    <updated>2019-04-21T22:19:56.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-355-design-twitter"><a class="markdownIt-Anchor" href="#leetcode-q-355-design-twitter"></a> LeetCode Q 355 - Design Twitter</h1><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p><ol><li><strong>postTweet(userId, tweetId)</strong>: Compose a new tweet.</li><li><strong>getNewsFeed(userId)</strong>: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li><li><strong>follow(followerId, followeeId)</strong>: Follower follows a followee.</li><li><strong>unfollow(followerId, followeeId)</strong>: Follower unfollows a followee.<br>Example:<br><code>Twitter twitter = new Twitter();</code><br>// User 1 posts a new tweet (id = 5).<br><code>twitter.postTweet(1, 5);</code><br>// User 1’s news feed should return a list with 1 tweet id -&gt; [5].<br><code>twitter.getNewsFeed(1);</code><br>// User 1 follows user 2.<br><code>twitter.follow(1, 2);</code><br>// User 2 posts a new tweet (id = 6).<br><code>twitter.postTweet(2, 6);</code><br>// User 1’s news feed should return a list with 2 tweet ids -&gt; [6, 5].<br>// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.<br><code>twitter.getNewsFeed(1);</code><br>// User 1 unfollows user 2.<br><code>twitter.unfollow(1, 2);</code><br>// User 1’s news feed should return a list with 1 tweet id -&gt; [5],<br>// since user 1 is no longer following user 2.<br><code>twitter.getNewsFeed(1);</code></li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-hashtable"><a class="markdownIt-Anchor" href="#method-1-hashtable"></a> Method 1: HashTable</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Tweet&gt; tweetMap;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; userMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;   <span class="comment">// increase an time field to the Tweet class</span></span><br><span class="line"><span class="keyword">int</span> tweetId; <span class="comment">// enable the sorting by time function</span></span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line">Tweet next;  <span class="comment">// in the tweetMap, we only store the most recent tweet and use next attribute to find its next recent tweet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetId = id; <span class="keyword">this</span>.time = time; <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize your data structure here.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">this</span>.userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose a new tweet. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> twitId)</span> </span>&#123;</span><br><span class="line">Tweet curr = <span class="keyword">new</span> Tweet(twitId, ++timeStamp);</span><br><span class="line">curr.next = tweetMap.getOrDefault(userId, <span class="keyword">null</span>);</span><br><span class="line">tweetMap.put(userId, curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(userId); <span class="comment">// add the user itself</span></span><br><span class="line"><span class="keyword">if</span> (userMap.containsKey(userId)) set.addAll(userMap.get(userId));</span><br><span class="line"></span><br><span class="line">Queue&lt;Tweet&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (b.time - a.time));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: set) &#123;</span><br><span class="line"><span class="keyword">if</span> (tweetMap.get(num) != <span class="keyword">null</span>) pq.offer(tweetMap.get(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">Tweet t = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (t.next != <span class="keyword">null</span>) pq.offer(t.next);</span><br><span class="line">count++;</span><br><span class="line">res.add(t.tweetId);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">userMap.putIfAbsent(followerId, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">userMap.get(followerId).add(followeeId);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower unfollows a followee. If the operation is invalid, it should be a no-op. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (userMap.get(followerId) == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">userMap.get(followerId).remove(followeeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-ood-todo"><a class="markdownIt-Anchor" href="#method-2-ood-todo"></a> Method 2: OOD (TODO)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-355-design-twitter&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-355-design-twitter&quot;&gt;&lt;/a&gt; LeetCode Q 355 - Design Twitter&lt;/h1&gt;
&lt;p&gt;Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;postTweet(userId, tweetId)&lt;/strong&gt;: Compose a new tweet.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getNewsFeed(userId)&lt;/strong&gt;: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;follow(followerId, followeeId)&lt;/strong&gt;: Follower follows a followee.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unfollow(followerId, followeeId)&lt;/strong&gt;: Follower unfollows a followee.&lt;br&gt;
Example:&lt;br&gt;
&lt;code&gt;Twitter twitter = new Twitter();&lt;/code&gt;&lt;br&gt;
// User 1 posts a new tweet (id = 5).&lt;br&gt;
&lt;code&gt;twitter.postTweet(1, 5);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 1 tweet id -&amp;gt; [5].&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;br&gt;
// User 1 follows user 2.&lt;br&gt;
&lt;code&gt;twitter.follow(1, 2);&lt;/code&gt;&lt;br&gt;
// User 2 posts a new tweet (id = 6).&lt;br&gt;
&lt;code&gt;twitter.postTweet(2, 6);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 2 tweet ids -&amp;gt; [6, 5].&lt;br&gt;
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;br&gt;
// User 1 unfollows user 2.&lt;br&gt;
&lt;code&gt;twitter.unfollow(1, 2);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 1 tweet id -&amp;gt; [5],&lt;br&gt;
// since user 1 is no longer following user 2.&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="OOD" scheme="http://yoursite.com/tags/OOD/"/>
    
  </entry>
  
  <entry>
    <title>Find All Anagrams in a String</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ438/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ438/</id>
    <published>2019-04-21T16:51:16.000Z</published>
    <updated>2019-04-21T22:21:06.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-438-find-all-anagrams-in-a-string"><a class="markdownIt-Anchor" href="#leetcode-q-438-find-all-anagrams-in-a-string"></a> LeetCode Q 438 - Find All Anagrams in a String</h1><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.<br>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.<br>The order of output does not matter.</p><p><strong>Example 1:</strong><br><code>Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; ; Output: [0, 6]</code><br>Explanation: The substring with start index = 0 is “cba”, which is an anagram of “abc”. The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br><strong>Example 2:</strong><br><code>Input: s: &quot;abab&quot; p: &quot;ab&quot; ; Output: [0, 1, 2]</code><br>Explanation: The substring with start index = 0 is “ab”, which is an anagram of “ab”. The substring with start index = 1 is “ba”, which is an anagram of “ab”. The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/20/lintcodeQ386/" title="Longest Substring with At Most K Distinct Characters">Longest Substring with At Most K Distinct Characters</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sliding-window"><a class="markdownIt-Anchor" href="#method-1-sliding-window"></a> Method 1: Sliding Window</h3><p><strong>Time Complexity: O(n), n is the length of String s.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r) - <span class="string">'a'</span>] &gt; <span class="number">0</span>) sum++;</span><br><span class="line">count[s.charAt(r++) - <span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">if</span> (sum == p.length()) res.add(l);</span><br><span class="line"><span class="keyword">if</span> (r - l == p.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] &gt;= <span class="number">0</span>) sum--;</span><br><span class="line">count[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-naive-method"><a class="markdownIt-Anchor" href="#method-2-naive-method"></a> Method 2: Naive Method</h3><p><strong>Time Complexity: O(m * n), n is the length of String s, m is the length of String p.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - p.length(); i++) &#123;</span><br><span class="line">String str = s.substring(i, i + p.length());</span><br><span class="line"><span class="keyword">if</span> (isAnagram(str, p)) res.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch-<span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) count[ch-<span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) </span><br><span class="line"><span class="keyword">if</span> (count[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;/a&gt; LeetCode Q 438 - Find All Anagrams in a String&lt;/h1&gt;
&lt;p&gt;Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.&lt;br&gt;
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.&lt;br&gt;
The order of output does not matter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; ; Output: [0, 6]&lt;/code&gt;&lt;br&gt;
Explanation: The substring with start index = 0 is “cba”, which is an anagram of “abc”. The substring with start index = 6 is “bac”, which is an anagram of “abc”.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot; ; Output: [0, 1, 2]&lt;/code&gt;&lt;br&gt;
Explanation: The substring with start index = 0 is “ab”, which is an anagram of “ab”. The substring with start index = 1 is “ba”, which is an anagram of “ab”. The substring with start index = 2 is “ab”, which is an anagram of “ab”.&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/20/lintcodeQ386/&quot; title=&quot;Longest Substring with At Most K Distinct Characters&quot;&gt;Longest Substring with At Most K Distinct Characters&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring with At Most K Distinct Characters</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ386/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ386/</id>
    <published>2019-04-20T23:53:12.000Z</published>
    <updated>2019-04-21T16:58:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"><a class="markdownIt-Anchor" href="#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"></a> LeetCode Q 386 - Longest Substring with At Most K Distinct Characters</h1><p>Given a string S, find the length of the longest substring T that contains at most k distinct characters.</p><p>Example 1:<br><code>Input: S = &quot;eceba&quot; and k = 3 ; Output: 4 ; Explanation: T = &quot;eceb&quot;</code><br>Example 2:<br><code>Input: S = &quot;WORLD&quot; and k = 4 ; Output: 4 ; Explanation: T = &quot;WORL&quot; or &quot;ORLD&quot;</code><br><strong>Challenge</strong> : O(n) time</p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/21/leetcodeQ438/" title="Find All Anagrams in a String">Find All Anagrams in a String</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Sliding Window: Time Complexity: O(n)</strong></p><h3 id="method-1-use-an-array"><a class="markdownIt-Anchor" href="#method-1-use-an-array"></a> Method 1: Use an array</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length() &lt;= k) <span class="keyword">return</span> s.length();</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, maxLen = <span class="number">0</span>;;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">count[s.charAt(r)]++;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r)] == <span class="number">1</span>) sum++;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">count[s.charAt(l)]--;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] == <span class="number">0</span>) sum--;</span><br><span class="line">l++;</span><br><span class="line">&#125; </span><br><span class="line">maxLen = Math.max(maxLen, r - l + <span class="number">1</span>);</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-use-an-hashmap"><a class="markdownIt-Anchor" href="#method-2-use-an-hashmap"></a> Method 2: Use an hashmap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store char and number of occurance. </span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class="line"><span class="keyword">char</span> curr = s.charAt(end);</span><br><span class="line"><span class="keyword">if</span> (map.get(curr) == <span class="keyword">null</span>) map.put(curr, <span class="number">0</span>);</span><br><span class="line">map.put(curr, map.get(curr) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(curr)==<span class="number">1</span>) counter++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check size of k in current window</span></span><br><span class="line"><span class="keyword">while</span>(counter &gt; k) &#123;</span><br><span class="line"><span class="keyword">char</span> first = s.charAt(start);</span><br><span class="line">map.put(first, map.get(first)-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(first) == <span class="number">0</span>) counter--;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">len = Math.max(len, end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;/a&gt; LeetCode Q 386 - Longest Substring with At Most K Distinct Characters&lt;/h1&gt;
&lt;p&gt;Given a string S, find the length of the longest substring T that contains at most k distinct characters.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;eceba&amp;quot; and k = 3 ; Output: 4 ; Explanation: T = &amp;quot;eceb&amp;quot;&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;WORLD&amp;quot; and k = 4 ; Output: 4 ; Explanation: T = &amp;quot;WORL&amp;quot; or &amp;quot;ORLD&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Challenge&lt;/strong&gt; : O(n) time&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/21/leetcodeQ438/&quot; title=&quot;Find All Anagrams in a String&quot;&gt;Find All Anagrams in a String&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ347/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ347/</id>
    <published>2019-04-20T16:41:21.000Z</published>
    <updated>2019-04-20T17:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-347-top-k-frequent-elements"><a class="markdownIt-Anchor" href="#leetcode-q-347-top-k-frequent-elements"></a> LeetCode Q 347 - Top K Frequent Elements</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>Example 1:<br><code>Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]</code><br>Example 2:<br><code>Input: nums = [1], k = 1 ; Output: [1]</code><br><strong>Note</strong>: You may assume k is always valid, <strong>1 ≤ k ≤ number of unique elements</strong>. Your algorithm’s time complexity must be better than <strong>O(n log n)</strong>, where n is the array’s size.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Heap Sort: time O(NlogN)</strong><br><strong>Bucket Sort: tiem O(N)</strong></p><h3 id="solution-1-heap-sort"><a class="markdownIt-Anchor" href="#solution-1-heap-sort"></a> Solution 1: Heap Sort</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (map.get(a) - map.get(b)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line">pq.offer(num);</span><br><span class="line"><span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: pq)</span><br><span class="line">res.add(<span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bucket-sort-counting-sort"><a class="markdownIt-Anchor" href="#solution-2-bucket-sort-counting-sort"></a> Solution 2: Bucket Sort (Counting sort)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// first traverse: calculate frequencies, recode in the map</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// build buckets</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(num);</span><br><span class="line"><span class="keyword">if</span> (lists[freq] == <span class="keyword">null</span>) lists[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists[freq].add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse each bucket </span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lists.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; k != <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">res.addAll(lists[i]);</span><br><span class="line">k -= lists[i].size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;/a&gt; LeetCode Q 347 - Top K Frequent Elements&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [1], k = 1 ; Output: [1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt;: You may assume k is always valid, &lt;strong&gt;1 ≤ k ≤ number of unique elements&lt;/strong&gt;. Your algorithm’s time complexity must be better than &lt;strong&gt;O(n log n)&lt;/strong&gt;, where n is the array’s size.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Pairs</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ336/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ336/</id>
    <published>2019-04-20T16:23:37.000Z</published>
    <updated>2019-04-21T22:22:25.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-336-palindrome-pairs"><a class="markdownIt-Anchor" href="#leetcode-q-336-palindrome-pairs"></a> LeetCode Q 336 - Palindrome Pairs</h1><p>Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.</p><p><strong>Example 1:</strong><br><code>Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;] ; Output: [[0,1],[1,0],[3,2],[2,4]]</code><br>Explanation: The palindromes are [“dcbaabcd”,“abcddcba”,“slls”,“llssssll”]<br><strong>Example 2:</strong><br><code>Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;] ; Output: [[0,1],[1,0]]</code><br>Explanation: The palindromes are [“battab”,“tabbat”]</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is we first store each string and its index in the map.<br>Then, for each string, we divide it into two substrings(<strong>str1 and str2</strong>), and check all the substring pairs.</p><ol><li>if <code>str1</code> is Palindrome, then we reverse <code>str2</code>, and check if the map containsKey <code>reversedStr2</code>. If it contains, then we can concate String <code>reversedStr2</code> and <code>str1</code> to get the palindrome string. <strong>Note:</strong> the <code>reversedStr2</code> should be on the left and <code>str1</code> on the right.</li><li>if <code>str2</code> is Palindrome, then we reverse <code>str1</code>, and check if the map containsKey <code>reversedStr1</code>. If it contains, then we can concate String <code>str2</code> and <code>reversedStr1</code> to get the palindrome string. <strong>Note:</strong> the <code>str2</code> should be on the left and <code>reversedStr1</code> on the right.</li></ol><p><strong>Caution</strong>: MUST CHECK whether str.length() is equal to 0 in either if statement, because we need to make sure we do not add duplicate pairs (if str1.length() == 0, both of str1 and str2 will from input array).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)</span><br><span class="line">map.put(words[i], i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">String word = words[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word.length(); j++) &#123;</span><br><span class="line">String str1 = word.substring(<span class="number">0</span>, j);</span><br><span class="line">String str2 = word.substring(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str1)) &#123;</span><br><span class="line">String reversedStr2 = <span class="keyword">new</span> StringBuilder(str2).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr2) &amp;&amp; map.get(reversedStr2) != i &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">res.add(Arrays.asList(map.get(reversedStr2), str1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str2)) &#123;</span><br><span class="line">String reversedStr1 = <span class="keyword">new</span> StringBuilder(str1).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr1) &amp;&amp; map.get(reversedStr1) != i)</span><br><span class="line">res.add(Arrays.asList(i,map.get(reversedStr1)));   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i++) != str.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-336-palindrome-pairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-336-palindrome-pairs&quot;&gt;&lt;/a&gt; LeetCode Q 336 - Palindrome Pairs&lt;/h1&gt;
&lt;p&gt;Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;] ; Output: [[0,1],[1,0],[3,2],[2,4]]&lt;/code&gt;&lt;br&gt;
Explanation: The palindromes are [“dcbaabcd”,“abcddcba”,“slls”,“llssssll”]&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;] ; Output: [[0,1],[1,0]]&lt;/code&gt;&lt;br&gt;
Explanation: The palindromes are [“battab”,“tabbat”]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>H-Index</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ274-1/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ274-1/</id>
    <published>2019-04-20T16:19:42.000Z</published>
    <updated>2019-04-20T16:25:17.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-274-h-index"><a class="markdownIt-Anchor" href="#leetcode-q-274-h-index"></a> LeetCode Q 274 - H-Index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><p>Similar question: <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Comparing with <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a>, the given citations is unsorted. We can still use <strong>binary search</strong> to solve this question as we did in leetcodeQ275. Then the <strong>time complexity</strong> is <strong>O(NlogN)</strong>. But we can optimize the solution using <strong>bucket sort (counting sort)</strong>. The <strong>time complexity</strong> becomes <strong>O(N)</strong>.</p><p>Assume n is the total number of papers, if we have n+1 buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket. The only exception is that for any paper with larger number of reference than n, we put in the n-th bucket.</p><p>Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result.</p><p>Some tricky cases: [5,5] -&gt; 2 [0,0] -&gt; 0</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = citations.length;</span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> citation: citations) &#123;</span><br><span class="line"><span class="keyword">if</span> (citation &gt;= len) buckets[len]++;</span><br><span class="line"><span class="keyword">else</span> buckets[citation]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">count += buckets[i];</span><br><span class="line"><span class="keyword">if</span> (count &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-274-h-index&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-274-h-index&quot;&gt;&lt;/a&gt; LeetCode Q 274 - H-Index&lt;/h1&gt;
&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
&lt;p&gt;Similar question: &lt;a href=&quot;/2019/04/15/leetcodeQ275/&quot; title=&quot;H-Index II&quot;&gt;H-Index II&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number II</title>
    <link href="http://yoursite.com/2019/04/20/lintcodtQ776/"/>
    <id>http://yoursite.com/2019/04/20/lintcodtQ776/</id>
    <published>2019-04-20T15:24:13.000Z</published>
    <updated>2019-04-20T15:30:14.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-ii"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-ii"></a> LintCode Q 644 - Strobogrammatic Number II</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Find all strobogrammatic numbers that are of length = n.</p><a href="/2019/04/20/lintcodeQ644/" title="Strobogrammatic Number (Mirror Number)">Strobogrammatic Number (Mirror Number)</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We expanded the target String <strong>from center to two sides</strong> by recursively calling the helper method.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strs = helper(n - <span class="number">2</span>, target);</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line"><span class="keyword">if</span> (n != target) res.add(<span class="string">'0'</span> + str + <span class="string">'0'</span>);</span><br><span class="line">res.add(<span class="string">'1'</span> + str + <span class="string">'1'</span>);</span><br><span class="line">res.add(<span class="string">'6'</span> + str + <span class="string">'9'</span>);</span><br><span class="line">res.add(<span class="string">'8'</span> + str + <span class="string">'8'</span>);</span><br><span class="line">res.add(<span class="string">'9'</span> + str + <span class="string">'6'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number II&lt;/h1&gt;
&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;br&gt;
Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodeQ644/&quot; title=&quot;Strobogrammatic Number (Mirror Number)&quot;&gt;Strobogrammatic Number (Mirror Number)&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
</feed>
