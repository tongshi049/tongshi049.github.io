<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TongTong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-07T17:54:08.267Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cheapest Flights Within K Stops</title>
    <link href="http://yoursite.com/2019/05/07/leetcodeQ787/"/>
    <id>http://yoursite.com/2019/05/07/leetcodeQ787/</id>
    <published>2019-05-07T17:02:52.000Z</published>
    <updated>2019-05-07T17:54:08.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-787-cheapest-flights-within-k-stops"><a class="markdownIt-Anchor" href="#leetcode-q-787-cheapest-flights-within-k-stops"></a> LeetCode Q 787 - Cheapest Flights Within K Stops</h1><p>There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.<br>Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.</p><p>Example 1:<br>Input:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 1<br>Output: 200</p><p>Example 2:<br>Input:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 0<br>Output: 500</p><p><strong>Note:</strong></p><ul><li>The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.</li><li>The size of flights will be in range [0, n * (n - 1) / 2].</li><li>The format of each flight will be (src, dst, price).</li><li>The price of each flight will be in the range [1, 10000].</li><li>k is in the range of [0, n - 1].</li><li>There will not be any duplicated flights or self cycles.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dijkstras-algorithm"><a class="markdownIt-Anchor" href="#solution-1-dijkstras-algorithm"></a> Solution 1: Dijkstra’s algorithm</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> to, <span class="keyword">int</span> weight;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Edge</span> <span class="params">(<span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.to = to; <span class="keyword">this</span>.weigth = weight;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stop</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> id, count, price;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Stop</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> count, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id; <span class="keyword">this</span>.count = count; <span class="keyword">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">Map&lt;Integer, List&lt;Edge&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] f: flights) &#123;</span><br><span class="line">graph.putIfAbsent(f[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">graph.get(f[<span class="number">0</span>]).add(<span class="keyword">new</span> Edge (f[<span class="number">1</span>], f[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Stop&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a.price - b.price));</span><br><span class="line">pq.offer(<span class="keyword">new</span> Stop (src, K + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">Stop stop = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (stop.id == dst) <span class="keyword">return</span> stop.price;</span><br><span class="line"><span class="keyword">if</span> (stop.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">List&lt;Edge&gt; list = graph.getOrDefault(curr.id, <span class="keyword">new</span> ArrayList());</span><br><span class="line"><span class="keyword">for</span> (Edge e: edges)</span><br><span class="line">pq.offer(<span class="keyword">new</span> Stop(e.to, stop.count - <span class="number">1</span>, stop.price + e.weight));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp"><a class="markdownIt-Anchor" href="#solution-2-dp"></a> Solution 2: DP</h3><ol><li><p><strong>States:</strong> <code>long[k][i] dp</code> represents the minimum price that flight <strong>from src to i within k - 1 steps</strong>.</p></li><li><p><strong>State Transfer Function:</strong><br><code>dp[i][flight[1]] = Math.min(dp[i][flight[1]], dp[i - 1][flight[0]] + flight[2]);</code></p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[K + <span class="number">2</span>][n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span>[] arr: dp)</span><br><span class="line">Arrays.fill(arr, Integer.MAX_VALUE);</span><br><span class="line">dp[<span class="number">0</span>][src] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; K + <span class="number">2</span>; i++) &#123;</span><br><span class="line">dp[i][src] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] flight: flights) &#123;</span><br><span class="line">dp[i][flight[<span class="number">1</span>]] = Math.min(dp[i][flight[<span class="number">1</span>]], dp[i - <span class="number">1</span>][flight[<span class="number">0</span>]] + flight[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[K + <span class="number">1</span>][dst] == Integer.MAX_VALUE ? -<span class="number">1</span> : (<span class="keyword">int</span>)dp[K + <span class="number">1</span>][dst];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-787-cheapest-flights-within-k-stops&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-787-cheapest-flights-within-k-stops&quot;&gt;&lt;/a&gt; LeetCode Q 787 - Cheapest Flights Within K Stops&lt;/h1&gt;
&lt;p&gt;There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.&lt;br&gt;
Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]&lt;br&gt;
src = 0, dst = 2, k = 1&lt;br&gt;
Output: 200&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]&lt;br&gt;
src = 0, dst = 2, k = 0&lt;br&gt;
Output: 500&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.&lt;/li&gt;
&lt;li&gt;The size of flights will be in range [0, n * (n - 1) / 2].&lt;/li&gt;
&lt;li&gt;The format of each flight will be (src, dst, price).&lt;/li&gt;
&lt;li&gt;The price of each flight will be in the range [1, 10000].&lt;/li&gt;
&lt;li&gt;k is in the range of [0, n - 1].&lt;/li&gt;
&lt;li&gt;There will not be any duplicated flights or self cycles.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Redundant Connection II</title>
    <link href="http://yoursite.com/2019/05/07/leetcodeQ685/"/>
    <id>http://yoursite.com/2019/05/07/leetcodeQ685/</id>
    <published>2019-05-07T16:49:09.000Z</published>
    <updated>2019-05-07T17:34:32.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-685-redundant-connection-ii"><a class="markdownIt-Anchor" href="#leetcode-q-685-redundant-connection-ii"></a> LeetCode Q 685 - Redundant Connection II</h1><p>In this problem, a rooted tree is a <strong>directed</strong> graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.</p><p>The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p><p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a <strong>directed</strong> edge connecting nodes u and v, where u is a parent of child v.</p><p>Return an edge that can be removed so that the resulting graph is a <strong>rooted tree</strong> of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.</p><p>Example 1:<br>Input: [[1,2], [1,3], [2,3]]<br>Output: [2,3]</p><p>Example 2:<br>Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>Output: [4,1]</p><p><strong>Note:</strong></p><ul><li>The size of the input 2D-array will be between 3 and 1000.</li><li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-disjoint-set-union-find"></a> Solution  : Disjoint Set / Union Find</h3><ol><li><p><strong>what is a rooted tree?</strong><br>In a rooted tree, the parent of a vertex is the vertex connected to it on the path to the root; <strong>every vertex except the root has a unique parent</strong>. A child of a vertex v is a vertex of which v is the parent. A descendant of any vertex v is any vertex which is either the child of v or is (recursively) the descendant of any of the children of v. A sibling to a vertex v is any other vertex on the tree which has the same parent as v. The root is an external vertex if it has precisely one child. A leaf is different from the root.</p></li><li><p>There are <strong>3</strong> cases, where the cycle has redundante edges.</p><ul><li>There is a cycle.</li><li>A node has two parents.</li><li>A node has two parents and one edge of this node introduces a cycle.<br>These cases are shown as follows.<br><img src="leetcodeQ685.png" width="50%" height="50%"><br>We can eliminate reduanduncy like this.</li></ul></li></ol><ul><li>For case 1, we just remove the last edge introducing a cycle.</li><li>For case 2, we delete one edge of that node. That edge is the last one causing multiple parents issue.</li><li>For case 3, we delete one edge of that node. That edge is the first one causing multiple parents issue.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = x;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p]) </span><br><span class="line">p = parent[p];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) parent[px] = py;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantDirectedConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(edges.length + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span>[] cand1 = <span class="keyword">null</span>, cand2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line"><span class="keyword">int</span> p1 = ufs.find(edge[<span class="number">0</span>]), p2 = ufs.find(edge[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;</span><br><span class="line"><span class="keyword">if</span> (p2 != edge[<span class="number">1</span>]) <span class="comment">//record the last edge which results in "multiple parents" issue</span></span><br><span class="line">cand1 = edge;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ufs.union(edge[<span class="number">1</span>], edge[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// current edge causes a cycle</span></span><br><span class="line">cand2 = edge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cand1 == <span class="keyword">null</span>) <span class="keyword">return</span> cand2;</span><br><span class="line"><span class="keyword">if</span> (cand2 == <span class="keyword">null</span>) <span class="keyword">return</span> cand1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If both issues present, then the answer should be the first edge which results in "multiple parents" issue</span></span><br><span class="line"><span class="comment">// Could use map to skip this pass, but will use more memory.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line"><span class="keyword">if</span> (edge[<span class="number">1</span>] == cand1[<span class="number">1</span>])</span><br><span class="line">retur edge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-685-redundant-connection-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-685-redundant-connection-ii&quot;&gt;&lt;/a&gt; LeetCode Q 685 - Redundant Connection II&lt;/h1&gt;
&lt;p&gt;In this problem, a rooted tree is a &lt;strong&gt;directed&lt;/strong&gt; graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.&lt;/p&gt;
&lt;p&gt;The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, …, N), with one additional directed edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.&lt;/p&gt;
&lt;p&gt;The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] that represents a &lt;strong&gt;directed&lt;/strong&gt; edge connecting nodes u and v, where u is a parent of child v.&lt;/p&gt;
&lt;p&gt;Return an edge that can be removed so that the resulting graph is a &lt;strong&gt;rooted tree&lt;/strong&gt; of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input: [[1,2], [1,3], [2,3]]&lt;br&gt;
Output: [2,3]&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input: [[1,2], [2,3], [3,4], [4,1], [1,5]]&lt;br&gt;
Output: [4,1]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The size of the input 2D-array will be between 3 and 1000.&lt;/li&gt;
&lt;li&gt;Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Redundant Connection</title>
    <link href="http://yoursite.com/2019/05/07/leetcodeQ684/"/>
    <id>http://yoursite.com/2019/05/07/leetcodeQ684/</id>
    <published>2019-05-07T16:26:44.000Z</published>
    <updated>2019-05-07T16:52:11.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-684-redundant-connection"><a class="markdownIt-Anchor" href="#leetcode-q-684-redundant-connection"></a> LeetCode Q 684 - Redundant Connection</h1><p>In this problem, a tree is an <strong>undirected</strong> graph that is connected and has no cycles.<br>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.<br>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an <strong>undirected</strong> edge connecting nodes u and v.</p><p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p><p>Example 1:<br>Input: [[1,2], [1,3], [2,3]]<br>Output: [2,3]<br>Explanation: The given undirected graph will be like this:<br>  1<br> / \<br>2 - 3<br>Example 2:<br>Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]<br>Output: [1,4]<br>Explanation: The given undirected graph will be like this:<br>5 - 1 - 2<br> | |<br> 4 - 3</p><p><strong>Note:</strong></p><ul><li>The size of the input 2D-array will be between 3 and 1000.</li><li>Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Time Complexity: O(n^2)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line">seen.clear();</span><br><span class="line"><span class="keyword">if</span> (!graph.containsKey(edge[<span class="number">0</span>]) &amp;&amp; !graph.containsKey(edge[<span class="number">1</span>]) </span><br><span class="line">&amp;&amp; hasCycle(graph, edge[<span class="number">0</span>], edge[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">return</span> edge;</span><br><span class="line">graph.putIfAbsent(edge[<span class="number">0</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">graph.putIfAbsent(edge[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span> <span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (seen.contains(start)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == end) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!graph.containsKey(start)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">seen.add(start);</span><br><span class="line">List&lt;Integer&gt; nexts = graph.get(start);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: nexts) &#123;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, next, end))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-2-disjoint-set-union-find"></a> Solution 2 : Disjoint Set / Union Find</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = x;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p]) </span><br><span class="line">p = parent[p];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) parent[px] = py;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(edges.length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(edge[<span class="number">0</span>]) == ufs.find(edge[<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">return</span> edge;</span><br><span class="line">ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-684-redundant-connection&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-684-redundant-connection&quot;&gt;&lt;/a&gt; LeetCode Q 684 - Redundant Connection&lt;/h1&gt;
&lt;p&gt;In this problem, a tree is an &lt;strong&gt;undirected&lt;/strong&gt; graph that is connected and has no cycles.&lt;br&gt;
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, …, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.&lt;br&gt;
The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &amp;lt; v, that represents an &lt;strong&gt;undirected&lt;/strong&gt; edge connecting nodes u and v.&lt;/p&gt;
&lt;p&gt;Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &amp;lt; v.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input: [[1,2], [1,3], [2,3]]&lt;br&gt;
Output: [2,3]&lt;br&gt;
Explanation: The given undirected graph will be like this:&lt;br&gt;
  1&lt;br&gt;
 / \&lt;br&gt;
2 - 3&lt;br&gt;
Example 2:&lt;br&gt;
Input: [[1,2], [2,3], [3,4], [1,4], [1,5]]&lt;br&gt;
Output: [1,4]&lt;br&gt;
Explanation: The given undirected graph will be like this:&lt;br&gt;
5 - 1 - 2&lt;br&gt;
 | |&lt;br&gt;
 4 - 3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The size of the input 2D-array will be between 3 and 1000.&lt;/li&gt;
&lt;li&gt;Every integer represented in the 2D-array will be between 1 and N, where N is the size of the input array.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Surrounded Regions</title>
    <link href="http://yoursite.com/2019/05/07/leetcodeQ130/"/>
    <id>http://yoursite.com/2019/05/07/leetcodeQ130/</id>
    <published>2019-05-07T16:03:44.000Z</published>
    <updated>2019-05-07T16:52:10.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-130-surrounded-regions"><a class="markdownIt-Anchor" href="#leetcode-q-130-surrounded-regions"></a> LeetCode Q 130 - Surrounded Regions</h1><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p><p>A region is captured by flipping all 'O’s into 'X’s in that surrounded region.</p><p>Example:<br>X  X  X  X<br>X  O  O  X<br>X  X  O  X<br>X  O  X  X</p><p>After running your function, the board should be:<br>X  X  X  X<br>X  X  X  X<br>X  X  X  X<br>X  O  X  X</p><p>Explanation:<br>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = board.length, C = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r][<span class="number">0</span>] == <span class="string">'O'</span>) dfs(board, r, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (board[r][C - <span class="number">1</span>] == <span class="string">'O'</span>) dfs(board, r, C - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[<span class="number">0</span>][c] == <span class="string">'O'</span>) dfs(board, <span class="number">0</span>, c);</span><br><span class="line"><span class="keyword">if</span> (board[R - <span class="number">1</span>][c] == <span class="string">'O'</span>) dfs(board, R - <span class="number">1</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r][c] == <span class="string">'U'</span>) board[r][c] = <span class="string">'O'</span>;</span><br><span class="line"><span class="keyword">if</span> (board[r][c] == <span class="string">'O'</span>) board[r][c] = <span class="string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == board.length || c == board[<span class="number">0</span>].length || board[r][c] != <span class="string">'O'</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">board[r][c] = <span class="string">'U'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line">dfs(board, nr, nc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-disjoint-set-union-find"></a> Solution : Disjoint Set / Union Find</h3><p><strong>Tips:</strong></p><ol><li>we’d better write the <code>find</code> function in the <code>UnionFindSet</code> iteratively to avoid <strong>Stack Overflow</strong>.</li><li>when making the <code>union</code>, let the one with bigger index be the root, making sure the <code>Os</code> on the borders has root <code>R * C</code>.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = x;</span><br><span class="line"><span class="keyword">while</span> (p != parent[p]) </span><br><span class="line">p = parent[p];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) parent[Math.min(px, py)] = Math.max(px, py);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = board.length, C = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r][c] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span> || r == R - <span class="number">1</span> || c == <span class="number">0</span> || c == C - <span class="number">1</span>) &#123;</span><br><span class="line">ufs.union(r * C + c, R * C);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (board[nr][nc] == <span class="string">'O'</span>)</span><br><span class="line">ufs.union(r * C + c, nr * C + nc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; R - <span class="number">1</span>; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; C - <span class="number">1</span>; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r][c] == <span class="string">'O'</span> &amp;&amp; ufs.find(r * C + c) != R * C) </span><br><span class="line">board[r][c] == <span class="string">'X'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-130-surrounded-regions&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-130-surrounded-regions&quot;&gt;&lt;/a&gt; LeetCode Q 130 - Surrounded Regions&lt;/h1&gt;
&lt;p&gt;Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.&lt;/p&gt;
&lt;p&gt;A region is captured by flipping all &#39;O’s into &#39;X’s in that surrounded region.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
X  X  X  X&lt;br&gt;
X  O  O  X&lt;br&gt;
X  X  O  X&lt;br&gt;
X  O  X  X&lt;/p&gt;
&lt;p&gt;After running your function, the board should be:&lt;br&gt;
X  X  X  X&lt;br&gt;
X  X  X  X&lt;br&gt;
X  X  X  X&lt;br&gt;
X  O  X  X&lt;/p&gt;
&lt;p&gt;Explanation:&lt;br&gt;
Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Similar String Groups</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ839/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ839/</id>
    <published>2019-05-06T20:29:11.000Z</published>
    <updated>2019-05-06T20:34:27.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-839-similar-string-groups"><a class="markdownIt-Anchor" href="#leetcode-q-839-similar-string-groups"></a> LeetCode Q 839 - Similar String Groups</h1><p>Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.</p><p>For example, “tars” and “rats” are similar (swapping at positions 0 and 2), and “rats” and “arts” are similar, but “star” is not similar to “tars”, “rats”, or “arts”.</p><p>Together, these form two connected groups by similarity: {“tars”, “rats”, “arts”} and {“star”}.  Notice that “tars” and “arts” are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.</p><p>We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there?</p><p>Example 1:<br><code>Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;] ; Output: 2</code></p><p><strong>Note:</strong></p><ul><li>A.length &lt;= 2000</li><li>A[i].length &lt;= 1000</li><li>A.length * A[i].length &lt;= 20000</li><li>All words in A consist of lowercase letters only.</li><li>All words in A have the same length and are anagrams of each other.</li><li>The judging time limit has been increased for this question.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-1-disjoint-set-union-find"></a> Solution 1: Disjoint Set / Union Find</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123; parent[px] = py; count--; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> A.length;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(A.length);</span><br><span class="line">ufs.count = A.length;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; strToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">String word = A[i];</span><br><span class="line">strToId.putIfAbsent(word, i);</span><br><span class="line"><span class="keyword">for</span> (String str: strToId.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (canGroup(str, word)) </span><br><span class="line">ufs.union(strToId.get(str), i); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canGroup</span> <span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, len = a.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line"><span class="keyword">if</span> (a.charAt(i) != b.charAt(i) &amp;&amp; ++res &gt; <span class="number">2</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code: More concise code</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSimilarGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> A.length;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(A.length);</span><br><span class="line">ufs.count = A.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (canGroup(A[i], A[j]))</span><br><span class="line">ufs.union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-839-similar-string-groups&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-839-similar-string-groups&quot;&gt;&lt;/a&gt; LeetCode Q 839 - Similar String Groups&lt;/h1&gt;
&lt;p&gt;Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.&lt;/p&gt;
&lt;p&gt;For example, “tars” and “rats” are similar (swapping at positions 0 and 2), and “rats” and “arts” are similar, but “star” is not similar to “tars”, “rats”, or “arts”.&lt;/p&gt;
&lt;p&gt;Together, these form two connected groups by similarity: {“tars”, “rats”, “arts”} and {“star”}.  Notice that “tars” and “arts” are in the same group even though they are not similar.  Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.&lt;/p&gt;
&lt;p&gt;We are given a list A of strings.  Every string in A is an anagram of every other string in A.  How many groups are there?&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;tars&amp;quot;,&amp;quot;rats&amp;quot;,&amp;quot;arts&amp;quot;,&amp;quot;star&amp;quot;] ; Output: 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.length &amp;lt;= 2000&lt;/li&gt;
&lt;li&gt;A[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;A.length * A[i].length &amp;lt;= 20000&lt;/li&gt;
&lt;li&gt;All words in A consist of lowercase letters only.&lt;/li&gt;
&lt;li&gt;All words in A have the same length and are anagrams of each other.&lt;/li&gt;
&lt;li&gt;The judging time limit has been increased for this question.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Satisfiability of Equality Equations</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ990/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ990/</id>
    <published>2019-05-06T20:25:28.000Z</published>
    <updated>2019-05-06T20:28:57.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-990-satisfiability-of-equality-equations"><a class="markdownIt-Anchor" href="#leetcode-q-990-satisfiability-of-equality-equations"></a> LeetCode Q 990 - Satisfiability of Equality Equations</h1><p>Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: “a==b” or “a!=b”.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.</p><p>Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p><p>Example 1:<br><code>Input: [&quot;a==b&quot;,&quot;b!=a&quot;] ; Output: false</code><br>Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</p><p>Example 2:<br><code>Input: [&quot;b==a&quot;,&quot;a==b&quot;] ; Output: true</code><br>Explanation: We could assign a = 1 and b = 1 to satisfy both equations.</p><p>Example 3:<br><code>Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;] ; Output: true</code></p><p>Example 4:<br><code>Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;] ; Output: false</code></p><p>Example 5:<br><code>Input: [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;] ; Output: true</code></p><p><strong>Note:</strong></p><ul><li>1 &lt;= equations.length &lt;= 500</li><li>equations[i].length == 4</li><li>equations[i][0] and equations[i][3] are lowercase letters</li><li>equations[i][1] is either ‘=’ or ‘!’</li><li>equations[i][2] is ‘=’</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-1-disjoint-set-union-find"></a> Solution 1: Disjoint Set / Union Find</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) parent[px] = py;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equationsPossible</span><span class="params">(String[] equations)</span> </span>&#123;</span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(<span class="number">26</span>);</span><br><span class="line"><span class="keyword">for</span> (String equ: equations) &#123;</span><br><span class="line"><span class="keyword">if</span> (equ.charAt(<span class="number">1</span>) == <span class="string">'='</span>) </span><br><span class="line">ufs.union(equ.charAt(<span class="number">0</span>) - <span class="string">'a'</span>, equ.charAt(<span class="number">3</span>) - <span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String equ: equations) &#123;</span><br><span class="line"><span class="keyword">if</span> (equ.charAt(<span class="number">1</span>) == <span class="string">'!'</span>) </span><br><span class="line"><span class="keyword">if</span> (ufs.find(equ.charAt(<span class="number">0</span>) - <span class="string">'a'</span>) == ufs.find(equ.charAt(<span class="number">3</span>) - <span class="string">'a'</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-990-satisfiability-of-equality-equations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-990-satisfiability-of-equality-equations&quot;&gt;&lt;/a&gt; LeetCode Q 990 - Satisfiability of Equality Equations&lt;/h1&gt;
&lt;p&gt;Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: “a==b” or “a!=b”.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.&lt;/p&gt;
&lt;p&gt;Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;a==b&amp;quot;,&amp;quot;b!=a&amp;quot;] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;b==a&amp;quot;,&amp;quot;a==b&amp;quot;] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: We could assign a = 1 and b = 1 to satisfy both equations.&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;a==b&amp;quot;,&amp;quot;b==c&amp;quot;,&amp;quot;a==c&amp;quot;] ; Output: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 4:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;a==b&amp;quot;,&amp;quot;b!=c&amp;quot;,&amp;quot;c==a&amp;quot;] ; Output: false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 5:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;c==c&amp;quot;,&amp;quot;b==d&amp;quot;,&amp;quot;x!=z&amp;quot;] ; Output: true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= equations.length &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;equations[i].length == 4&lt;/li&gt;
&lt;li&gt;equations[i][0] and equations[i][3] are lowercase letters&lt;/li&gt;
&lt;li&gt;equations[i][1] is either ‘=’ or ‘!’&lt;/li&gt;
&lt;li&gt;equations[i][2] is ‘=’&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Accounts Merge</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ721/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ721/</id>
    <published>2019-05-06T19:42:39.000Z</published>
    <updated>2019-05-06T20:24:32.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-721-accounts-merge"><a class="markdownIt-Anchor" href="#leetcode-q-721-accounts-merge"></a> LeetCode Q 721 - Accounts Merge</h1><p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in <strong>sorted order</strong>. The accounts themselves can be returned in any order.</p><p>Example 1:<br><code>Input: accounts = [ [ &quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]] Output: [ [ &quot;John&quot;, 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</code><br>Explanation:</p><ul><li>The first and third John’s are the same person as they have the common email <code>&quot;johnsmith@mail.com&quot;</code>.</li><li>The second John and Mary are different people as none of their email addresses are used by other accounts.</li><li>We could return these lists in any order, for example the answer <code>[ [ 'Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']]</code> would still be accepted.</li></ul><p><strong>Note:</strong></p><ul><li>The length of accounts will be in the range [1, 1000].</li><li>The length of accounts[i] will be in the range [1, 10].</li><li>The length of accounts[i][j] will be in the range [1, 30].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-1-disjoint-set-union-find"></a> Solution 1: Disjoint Set / Union Find</h3><ol><li>build the <code>emailToId</code> map, where <code>key: email, value: the root index</code></li><li>find each email’s father email and name, then group them up</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) parent[px] = py;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; accounts) &#123;</span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (accounts == <span class="keyword">null</span> || accounts.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(accounts.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the emailToId map</span></span><br><span class="line">Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accounts.size(); i++) &#123;</span><br><span class="line">List&lt;String&gt; emails = accounts.get(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; emails.size(); i++) &#123; <span class="comment">// skip name, iterate emails</span></span><br><span class="line">String email = emails.get(j); <span class="comment">// get email</span></span><br><span class="line">emailToId.putIfAbsent(email, i);</span><br><span class="line">ufs.union(emailToId.get(email), i); <span class="comment">// union the emails having the same name or in the same list. And set index i as its parent</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String email: emailToId.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> idx = emailToId.get(email); <span class="comment">// get index</span></span><br><span class="line"><span class="keyword">int</span> p = ufs.find(idx); <span class="comment">// get parent</span></span><br><span class="line">idToEmails.putIfAbsent(p, <span class="keyword">new</span> ArrayList&lt;&gt;(); </span><br><span class="line">idToEmails.get(p).add(email); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> idx: IdToEmails.keySet()) &#123;</span><br><span class="line">List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// create account</span></span><br><span class="line">temp.add(accounts.get(idx).get(<span class="number">0</span>)); <span class="comment">// add name;</span></span><br><span class="line">List&lt;String&gt; emails = IdToEmails.get(idx); <span class="comment">// get emails</span></span><br><span class="line">Collections.sort(emails); <span class="comment">// sort emails</span></span><br><span class="line">temp.addAll(emails); <span class="comment">// add emails</span></span><br><span class="line">res.add(temp); <span class="comment">// add account</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-721-accounts-merge&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-721-accounts-merge&quot;&gt;&lt;/a&gt; LeetCode Q 721 - Accounts Merge&lt;/h1&gt;
&lt;p&gt;Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.&lt;/p&gt;
&lt;p&gt;Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.&lt;/p&gt;
&lt;p&gt;After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in &lt;strong&gt;sorted order&lt;/strong&gt;. The accounts themselves can be returned in any order.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: accounts = [ [ &amp;quot;John&amp;quot;, &amp;quot;johnsmith@mail.com&amp;quot;, &amp;quot;john00@mail.com&amp;quot;], [&amp;quot;John&amp;quot;, &amp;quot;johnnybravo@mail.com&amp;quot;], [&amp;quot;John&amp;quot;, &amp;quot;johnsmith@mail.com&amp;quot;, &amp;quot;john_newyork@mail.com&amp;quot;], [&amp;quot;Mary&amp;quot;, &amp;quot;mary@mail.com&amp;quot;]] Output: [ [ &amp;quot;John&amp;quot;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;], [&amp;quot;John&amp;quot;, &amp;quot;johnnybravo@mail.com&amp;quot;], [&amp;quot;Mary&amp;quot;, &amp;quot;mary@mail.com&amp;quot;]]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first and third John’s are the same person as they have the common email &lt;code&gt;&amp;quot;johnsmith@mail.com&amp;quot;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second John and Mary are different people as none of their email addresses are used by other accounts.&lt;/li&gt;
&lt;li&gt;We could return these lists in any order, for example the answer &lt;code&gt;[ [ &#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], [&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]]&lt;/code&gt; would still be accepted.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of accounts will be in the range [1, 1000].&lt;/li&gt;
&lt;li&gt;The length of accounts[i] will be in the range [1, 10].&lt;/li&gt;
&lt;li&gt;The length of accounts[i][j] will be in the range [1, 30].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Evaluate Division</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ399/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ399/</id>
    <published>2019-05-06T18:29:14.000Z</published>
    <updated>2019-05-06T20:09:12.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-399-evaluate-division"><a class="markdownIt-Anchor" href="#leetcode-q-399-evaluate-division"></a> LeetCode Q 399 - Evaluate Division</h1><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p><p>Example:<br><code>Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ].</code></p><p>According to the example above:<br><code>equations = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ], values = [2.0, 3.0], queries = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</code></p><p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-disjoint-set-union-find"><a class="markdownIt-Anchor" href="#solution-1-disjoint-set-union-find"></a> Solution 1: Disjoint Set / Union Find</h3><ol><li><p>We use two maps, <code>Map&lt;String, String&gt; root</code> and <code>Map&lt;String, Double&gt; dist</code>.</p><ul><li><code>root</code> is used to store the divisors. For example, given <code>a / b</code>, in the <code>root</code>, we add two key value pairs, one is <code>{a: b}</code> and another is <code>{b: b}</code>.</li><li><code>dist</code> is used to store the values. For example, given <code>a / b = 2.0</code>, in the <code>root</code>, we add two key value pairs, one is <code>{a: 2.0}</code> and another is <code>{b: 1.0}</code>.</li></ul></li><li><p>In our algorithm, we implicitly utilzie <strong>Union Find</strong> data structure, doing <code>ufs.union</code> and <code>ufs.find</code> operations.</p></li><li><p>why <code>dist.put(p1, values[i] * dist.get(e.get(1)) / dist.get(e.get(0)));</code><br><code>dist</code> is a map that stores the “distance” (or factor) from current node to its root. Since we have <code>e[i][0] = dist.get(e[i][0]) * r1</code> and <code>e[i][1] = dist.get(e[i][1]) * r2</code>, <code>e[i][0] = e[i][1] * values[i]</code> can be rewritten in <code>dist.get(e[i][0]) * r1 = dist.get(e[i][1]) * r2 * values[i]</code>. Then, we can get <code>r1 = dist.get(e[i][1]) * r2 * values[i] / dist.get(e[i][0])</code>. Since <code>r2 = 1</code>, <code>r1 = dist.get(e[i][1]) * values[i] / dist.get(e[i][0])</code>.</p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; root = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, Double&gt; dist = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">List&lt;String&gt; equ = equations.get(i);</span><br><span class="line">String p1 = find(root, dist, equ.get(<span class="number">0</span>));</span><br><span class="line">String p2 = find(root, dist, equ.get(<span class="number">1</span>));</span><br><span class="line">root.put(p1, p2);</span><br><span class="line">dist.put(p1, values[i] * dist.get(equ.get(<span class="number">1</span>)) / dist.get(equ.get(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>(queries.size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size()) &#123;</span><br><span class="line">List&lt;String&gt; que = queries.get(i);</span><br><span class="line"><span class="keyword">if</span> (!root.containsKey(que(<span class="number">0</span>)) || !root.containsKey(que(<span class="number">1</span>))) &#123;</span><br><span class="line">res[i] = -<span class="number">1.0</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line">String p1 = find(root, dist, que.get(<span class="number">0</span>));</span><br><span class="line">String p2 = find(root, dist, que.get(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (!p1.equals(p2)) &#123;</span><br><span class="line">res[i] = -<span class="number">1.0</span>; <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">res[i] = (<span class="keyword">double</span>) dist.get(que.get(<span class="number">0</span>)) / dist.get(que.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">find</span> <span class="params">(Map&lt;String, String&gt; root, Map&lt;String, Double&gt; dist, String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!root.containsKey(s)) &#123;</span><br><span class="line">root.put(s, s); dist.put(s, <span class="number">1.0</span>); <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root.get(s).equals(s)) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> lastParent = root.get(s);</span><br><span class="line"><span class="keyword">int</span> parent = find(root, dist, lastParent);</span><br><span class="line"></span><br><span class="line">root.put(s, parent);</span><br><span class="line">dist.put(s, dist.get(s) * dist.get(lastParent));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2: DFS</h3><p>The DFS method is more straightforward.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, List&lt;Double&gt;&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">buildGraph(map1, map2, equations, values);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">res[i] = dfs(map1, map2, queries.get(i).get(<span class="number">0</span>), </span><br><span class="line">queries.get(i).get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span> <span class="params">(Map&lt;String, List&lt;String&gt;&gt; map1, Map&lt;String, List&lt;Double&gt;&gt; map2, String start, String end, Set&lt;String&gt; visited, <span class="keyword">double</span> res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!map1.containsKey(start) || visited.contains(start)) </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">visited.add(start);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nexts = map1.get(start);</span><br><span class="line">List&lt;Double&gt; values = map2.get(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp = -<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nexts.size(); i++) &#123;</span><br><span class="line">String next = nexts.get(i);</span><br><span class="line">Double val = values.get(i);</span><br><span class="line">temp = dfs(map1, map2, next, end, viisted, res * values.get(i));</span><br><span class="line"><span class="keyword">if</span> (temp != -<span class="number">1.0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited.remove(visited.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; map1, Map&lt;String, List&lt;Double&gt;&gt; map2, List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">List&lt;String&gt; equ = equations.get(i);</span><br><span class="line"><span class="keyword">if</span> (!map1.containsKey(equ.get(<span class="number">0</span>))) &#123;</span><br><span class="line">map1.put(equ.get(<span class="number">0</span>), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">map2.put(equ.get(<span class="number">0</span>), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!map1.containsKey(equ.get(<span class="number">1</span>))) &#123;</span><br><span class="line">map1.put(equ.get(<span class="number">1</span>), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">map2.put(equ.get(<span class="number">1</span>), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map1.get(equ.get(<span class="number">0</span>)).add(equ.get(<span class="number">1</span>));</span><br><span class="line">map1.get(equ.get(<span class="number">1</span>)).add(equ.get(<span class="number">0</span>));</span><br><span class="line">map2.get(equ.get(<span class="number">0</span>)).add(values[i]);</span><br><span class="line">map2.get(equ.get(<span class="number">1</span>)).add(<span class="number">1</span> / values[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-399-evaluate-division&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-399-evaluate-division&quot;&gt;&lt;/a&gt; LeetCode Q 399 - Evaluate Division&lt;/h1&gt;
&lt;p&gt;Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Given a / b = 2.0, b / c = 3.0. queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? . return [6.0, 0.5, -1.0, 1.0, -1.0 ].&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;According to the example above:&lt;br&gt;
&lt;code&gt;equations = [ [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;] ], values = [2.0, 3.0], queries = [ [&amp;quot;a&amp;quot;, &amp;quot;c&amp;quot;], [&amp;quot;b&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;], [&amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;], [&amp;quot;x&amp;quot;, &amp;quot;x&amp;quot;] ].&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Swap</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ670/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ670/</id>
    <published>2019-05-06T18:00:34.000Z</published>
    <updated>2019-05-06T20:01:57.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-670-maximum-swap"><a class="markdownIt-Anchor" href="#leetcode-q-670-maximum-swap"></a> LeetCode Q 670 - Maximum Swap</h1><p>Given a non-negative integer, you could swap two digits <strong>at most</strong> once to get the maximum valued number. Return the maximum valued number you could get.</p><p>Example 1:<br><code>Input: 2736 ; Output: 7236</code><br>Explanation: Swap the number 2 and the number 7.</p><p>Example 2:<br><code>Input: 9973 ; Output: 9973</code><br>Explanation: No swap.</p><p><strong>Note:</strong> The given number is in the range <code>[0, 108]</code>.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-greedy"><a class="markdownIt-Anchor" href="#solution-1-greedy"></a> Solution 1: Greedy</h3><p>The <strong>left</strong> and <strong>right</strong> digits we swap should satisfy the following property, if we want to get the maximum num after the exchange.</p><ol><li>the index of <strong>left</strong> digit should be as small as possible.</li><li>the index of <strong>right</strong> digit should be as large as possible. And the <strong>right</strong> digit should be larger than the <strong>left digit</strong>.</li></ol><p>In the following code, we use an array, i.e. <code>int[] last</code> to records the largest index of <code>0, 1, 2, .., 9</code> of the given <code>num</code>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = (num + <span class="string">""</span>).toCharArray();</span><br><span class="line"><span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">last[chs[i] - <span class="string">'0'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">9</span>; j &gt; chs[i] - <span class="string">'0'</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (last[j] &gt; i) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = chs[i];</span><br><span class="line">chs[i] = chs[last[j]];</span><br><span class="line">chs[last[j]] = temp;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-stack"><a class="markdownIt-Anchor" href="#solution-2-stack"></a> Solution 2: Stack</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = (num + <span class="string">""</span>).toCharArray();</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(chs[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> left = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; chs[i] &gt; chs[stack.peek()]) &#123;</span><br><span class="line">left = stack.pop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">stack.push(i);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = Math.max(res, swapAndTransform(num, i, left));</span><br><span class="line">stack.push(left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swapAndTransform</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> i, <span class="keyword">int</span> j )</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = (num+<span class="string">""</span>).toCharArray();</span><br><span class="line"><span class="keyword">char</span> temp = chs[i];</span><br><span class="line">chs[i] = chs[j];</span><br><span class="line">chs[j] =temp;</span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(<span class="keyword">new</span> String(chs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-670-maximum-swap&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-670-maximum-swap&quot;&gt;&lt;/a&gt; LeetCode Q 670 - Maximum Swap&lt;/h1&gt;
&lt;p&gt;Given a non-negative integer, you could swap two digits &lt;strong&gt;at most&lt;/strong&gt; once to get the maximum valued number. Return the maximum valued number you could get.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: 2736 ; Output: 7236&lt;/code&gt;&lt;br&gt;
Explanation: Swap the number 2 and the number 7.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: 9973 ; Output: 9973&lt;/code&gt;&lt;br&gt;
Explanation: No swap.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The given number is in the range &lt;code&gt;[0, 108]&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Keys and Rooms</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ841/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ841/</id>
    <published>2019-05-06T17:41:37.000Z</published>
    <updated>2019-05-06T20:02:35.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-841-keys-and-rooms"><a class="markdownIt-Anchor" href="#leetcode-q-841-keys-and-rooms"></a> LeetCode Q 841 - Keys and Rooms</h1><p>There are <code>N</code> rooms and you start in room 0.  Each room has a distinct number in <code>0, 1, 2, ..., N-1</code>, and each room may have some keys to access the next room.<br>Formally, each room i has a list of keys <code>rooms[i]</code>, and each key <code>rooms[i][j]</code> is an integer in <code>[0, 1, ..., N-1]</code> where <code>N = rooms.length</code>.  A key <code>rooms[i][j] = v</code> opens the room with number <code>v</code>.<br>Initially, all the rooms start locked (except for room <code>0</code>).<br>You can <strong>walk back and forth</strong> between rooms freely.<br>Return true if and only if you can enter every room.</p><p>Example 1:<br><code>Input: [[1],[2],[3],[]] ; Output: true</code><br>Explanation:<br>We start in room 0, and pick up key 1.<br>We then go to room 1, and pick up key 2.<br>We then go to room 2, and pick up key 3.<br>We then go to room 3.  Since we were able to go to every room, we return true.</p><p>Example 2:<br><code>Input: [[1,3],[3,0,1],[2],[0]] ; Output: false</code><br>Explanation: We can’t enter the room with number 2.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= rooms.length &lt;= 1000</li><li>0 &lt;= rooms[i].length &lt;= 1000</li><li>The number of keys in all rooms combined is at most 3000.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs-dfs"><a class="markdownIt-Anchor" href="#solution-bfs-dfs"></a> Solution : BFS / DFS</h3><p>The codes of the solution when adopting the BFS and DFS are almost same, excepte for that,</p><ul><li>when using BFS, a <code>stack</code> is employed;</li><li>when using DFS, a <code>queue</code> is employed.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canVisitAllRooms</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; rooms)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = rooms.size();</span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line">Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123; <span class="comment">// while (!stack.isEmpty())</span></span><br><span class="line"><span class="keyword">int</span> curr = que.poll(); <span class="comment">// int curr = stack.pop();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: rooms.get(curr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited.add(next)) &#123;</span><br><span class="line">que.offer(next); <span class="comment">// stack.push(next);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (visited.size() == N) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> visited.size() == N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-841-keys-and-rooms&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-841-keys-and-rooms&quot;&gt;&lt;/a&gt; LeetCode Q 841 - Keys and Rooms&lt;/h1&gt;
&lt;p&gt;There are &lt;code&gt;N&lt;/code&gt; rooms and you start in room 0.  Each room has a distinct number in &lt;code&gt;0, 1, 2, ..., N-1&lt;/code&gt;, and each room may have some keys to access the next room.&lt;br&gt;
Formally, each room i has a list of keys &lt;code&gt;rooms[i]&lt;/code&gt;, and each key &lt;code&gt;rooms[i][j]&lt;/code&gt; is an integer in &lt;code&gt;[0, 1, ..., N-1]&lt;/code&gt; where &lt;code&gt;N = rooms.length&lt;/code&gt;.  A key &lt;code&gt;rooms[i][j] = v&lt;/code&gt; opens the room with number &lt;code&gt;v&lt;/code&gt;.&lt;br&gt;
Initially, all the rooms start locked (except for room &lt;code&gt;0&lt;/code&gt;).&lt;br&gt;
You can &lt;strong&gt;walk back and forth&lt;/strong&gt; between rooms freely.&lt;br&gt;
Return true if and only if you can enter every room.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[1],[2],[3],[]] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
We start in room 0, and pick up key 1.&lt;br&gt;
We then go to room 1, and pick up key 2.&lt;br&gt;
We then go to room 2, and pick up key 3.&lt;br&gt;
We then go to room 3.  Since we were able to go to every room, we return true.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[1,3],[3,0,1],[2],[0]] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: We can’t enter the room with number 2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= rooms.length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= rooms[i].length &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;The number of keys in all rooms combined is at most 3000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Making A Large Island</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ827/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ827/</id>
    <published>2019-05-06T16:59:55.000Z</published>
    <updated>2019-05-06T20:01:22.446Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-827-making-a-large-island"><a class="markdownIt-Anchor" href="#leetcode-q-827-making-a-large-island"></a> LeetCode Q 827 - Making A Large Island</h1><p>In a 2D grid of 0s and 1s, we change at most one 0 to a 1.<br>After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).</p><p>Example 1:<br><code>Input: [[1, 0], [0, 1]] ; Output: 3</code><br>Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</p><p>Example 2:<br><code>Input: [[1, 1], [1, 0]] ; Output: 4</code><br>Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.</p><p>Example 3:<br><code>Input: [[1, 1], [1, 1]] ; Output: 4</code><br>Explanation: Can’t change any 0 to 1, only one island with area = 4.</p><p><strong>Notes:</strong></p><ul><li>1 &lt;= grid.length = grid[0].length &lt;= 50.</li><li>0 &lt;= grid[i][j] &lt;= 1.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-union-find-disjoint-set"><a class="markdownIt-Anchor" href="#solution-1-union-find-disjoint-set"></a> Solution 1 : Union Find / Disjoint Set</h3><p>We add one field to the <code>UnionFindSet</code>.<br>That is <code>int[] area</code>, which used to track the size of each component after the <code>union</code> operation.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] area;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size]; <span class="keyword">this</span>.area = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">parent[py] = px;</span><br><span class="line">area[px] += area[py];</span><br><span class="line">maxArea = Math.max(maxArea, area[px]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxArea = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; -<span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, -<span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// union node and its top and left nodes</span></span><br><span class="line"><span class="comment">// the other two girds' area are all 0, cuz we haven't visited them.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> nc = r + DIRS[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &lt; C </span><br><span class="line">&amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">ufs.union(r * C + c, nr * C + nc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> curr = i * C + j;</span><br><span class="line">ufs.area[curr] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// Use set to record neighbors' father to avoid adding area repeatedly</span></span><br><span class="line">Set&lt;Integer&gt; neighs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> nc = r + DIRS[i][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C </span><br><span class="line">|| grid[nr][nc] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> np = ufs.find(nr * C + nc);</span><br><span class="line"><span class="keyword">if</span> (neighs.add(np)) </span><br><span class="line">ufs.area[curr] += ufs.area[np];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">maxArea = Math.max(maxArea, ufs.area[curr]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p>Whe <strong>mark island</strong>.</p><ul><li>Give each island different name and calculate the area of each island.</li><li>Try each point grid[i][j] == 0 to see which island this point connects to.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> m = grid.length, index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][m];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">1</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">dfs(grid,visited,i,j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : set) map.put(s,res + <span class="string">"+"</span> + index);</span><br><span class="line"></span><br><span class="line">res = <span class="number">0</span>; set.clear(); index++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[][] neibor = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; -<span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, -<span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tempvalue = <span class="number">1</span>;</span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> row = i + neibor[k][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> col = j + neibor[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &gt;=<span class="number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; m </span><br><span class="line">&amp;&amp; grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">String value = map.get(row + <span class="string">"+"</span> + col);</span><br><span class="line"></span><br><span class="line">String[] strs = value.split(<span class="string">"\\+"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (set.add(strs[<span class="number">1</span>])) </span><br><span class="line">tempvalue += Integer.parseInt(strs[<span class="number">0</span>]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">max = Math.max(max,tempvalue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max == <span class="number">0</span> ? m * m : max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">int</span> m = grid.length;</span><br><span class="line"></span><br><span class="line">set.add(r + <span class="string">"+"</span> + c);</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] neibor = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123; -<span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, -<span class="number">1</span> &#125;, &#123; <span class="number">1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + neibor[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> nc = c + neibor[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &gt;=<span class="number">0</span> &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; m </span><br><span class="line">&amp;&amp; grid[nr][nc] == <span class="number">1</span> &amp;&amp; !visited[nr][nc]) </span><br><span class="line">dfs(grid, visited, nr, nc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-827-making-a-large-island&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-827-making-a-large-island&quot;&gt;&lt;/a&gt; LeetCode Q 827 - Making A Large Island&lt;/h1&gt;
&lt;p&gt;In a 2D grid of 0s and 1s, we change at most one 0 to a 1.&lt;br&gt;
After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[1, 0], [0, 1]] ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[1, 1], [1, 0]] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: [[1, 1], [1, 1]] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Can’t change any 0 to 1, only one island with area = 4.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= grid.length = grid[0].length &amp;lt;= 50.&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 1.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Max Area of Island</title>
    <link href="http://yoursite.com/2019/05/06/leetcodeQ695/"/>
    <id>http://yoursite.com/2019/05/06/leetcodeQ695/</id>
    <published>2019-05-06T16:46:02.000Z</published>
    <updated>2019-05-06T16:59:31.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-695-max-area-of-island"><a class="markdownIt-Anchor" href="#leetcode-q-695-max-area-of-island"></a> LeetCode Q 695 - Max Area of Island</h1><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.<br>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p><p>Example 1:<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p><p>Example 2:<br>[[0,0,0,0,0,0,0,0]]<br>Given the above grid, return 0.<br>Note: The length of each dimension in the given grid does not exceed 50.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">max = Math.max(max, dfs(grid, r, c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">grid[r][c] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nr &lt; grid.length &amp;&amp; nc &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[nr][nc] == <span class="number">1</span>) </span><br><span class="line">res += dfs(grid, nr, nc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">max = Math.max(max, bfs(grid, r, c));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span> <span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;); </span><br><span class="line">grid[r][c] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">res++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DISR[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &lt; C </span><br><span class="line">&amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">grid[nr][nc] = <span class="number">0</span>; <span class="comment">// set node to be 0 as soon as we offer it into the queue.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-695-max-area-of-island&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-695-max-area-of-island&quot;&gt;&lt;/a&gt; LeetCode Q 695 - Max Area of Island&lt;/h1&gt;
&lt;p&gt;Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.&lt;br&gt;
Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
[[0,0,1,0,0,0,0,1,0,0,0,0,0],&lt;br&gt;
[0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;br&gt;
[0,1,1,0,1,0,0,0,0,0,0,0,0],&lt;br&gt;
[0,1,0,0,1,1,0,0,1,0,1,0,0],&lt;br&gt;
[0,1,0,0,1,1,0,0,1,1,1,0,0],&lt;br&gt;
[0,0,0,0,0,0,0,0,0,0,1,0,0],&lt;br&gt;
[0,0,0,0,0,0,0,1,1,1,0,0,0],&lt;br&gt;
[0,0,0,0,0,0,0,1,1,0,0,0,0]]&lt;br&gt;
Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
[[0,0,0,0,0,0,0,0]]&lt;br&gt;
Given the above grid, return 0.&lt;br&gt;
Note: The length of each dimension in the given grid does not exceed 50.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Walls and Gates</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ663/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ663/</id>
    <published>2019-05-04T23:21:52.000Z</published>
    <updated>2019-05-04T23:29:56.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-663-walls-and-gates"><a class="markdownIt-Anchor" href="#lintcode-q-663-walls-and-gates"></a> LintCode Q 663 - Walls and Gates</h1><p>You are given a m x n 2D grid initialized with these three possible values.</p><ul><li>-1 - A wall or an obstacle.</li><li>0 - A gate.</li><li>INF - Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.<br>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a ROOM, that room should remain filled with INF</li></ul><p>Example1<br><code>Input: [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] ; Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]</code></p><p>Explanation:<br>the 2D grid is:<br>INF    -1     0    INF<br>INF    INF    INF    -1<br>INF    -1    INF    -1<br>0     -1    INF    INF<br>the answer is:<br>3    -1    0    1<br>2    2    1    -1<br>1    -1    2    -1<br>0    -1    3    4</p><p>Example2<br><code>Input: [[0,-1],[2147483647,2147483647]] ; Output: [[0,-1],[1,2]]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="comment">// find a gate</span></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != INF) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">grid[nr][nc] = grid[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-663-walls-and-gates&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-663-walls-and-gates&quot;&gt;&lt;/a&gt; LintCode Q 663 - Walls and Gates&lt;/h1&gt;
&lt;p&gt;You are given a m x n 2D grid initialized with these three possible values.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-1 - A wall or an obstacle.&lt;/li&gt;
&lt;li&gt;0 - A gate.&lt;/li&gt;
&lt;li&gt;INF - Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.&lt;br&gt;
Fill each empty room with the distance to its nearest gate. If it is impossible to reach a ROOM, that room should remain filled with INF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example1&lt;br&gt;
&lt;code&gt;Input: [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] ; Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Explanation:&lt;br&gt;
the 2D grid is:&lt;br&gt;
INF    -1     0    INF&lt;br&gt;
INF    INF    INF    -1&lt;br&gt;
INF    -1    INF    -1&lt;br&gt;
0     -1    INF    INF&lt;br&gt;
the answer is:&lt;br&gt;
3    -1    0    1&lt;br&gt;
2    2    1    -1&lt;br&gt;
1    -1    2    -1&lt;br&gt;
0    -1    3    4&lt;/p&gt;
&lt;p&gt;Example2&lt;br&gt;
&lt;code&gt;Input: [[0,-1],[2147483647,2147483647]] ; Output: [[0,-1],[1,2]]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Build Post Office II</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ573/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ573/</id>
    <published>2019-05-04T23:16:19.000Z</published>
    <updated>2019-05-04T23:21:05.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-573-build-post-office-ii"><a class="markdownIt-Anchor" href="#lintcode-q-573-build-post-office-ii"></a> LintCode Q 573 - Build Post Office II</h1><p>Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the sum of the distance from the post office to all the houses is smallest.<br>Return the smallest sum of distance. Return -1 if it is not possible.</p><p>Example 1:<br><code>Input：[[0,1,0,0,0],[1,0,0,2,1],[0,1,0,0,0]] ; Output：8</code><br>Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.</p><p>Example 2:<br><code>Input：[[0,1,0],[1,0,1],[0,1,0]] ; Output：4</code><br>Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.</p><p><strong>Challenge:</strong> Solve this problem within O(n^3) time.</p><p><strong>Notice:</strong></p><ul><li>You cannot pass through wall and house, but can pass through empty.</li><li>You only build post office on an empty.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><ul><li>Use BFS to calculte the distance from house to every empty land in the graph.</li><li>Add distances of all houses to every empty land together.</li><li>Choose the smallest distance</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">int</span> house = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">house++;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">dist[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] += level;</span><br><span class="line">reach[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || visited[nr][nc] || grid[nr][nc] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span> &amp;&amp; reach[r][c] == house &amp;&amp; dist[r][c] &lt; res)</span><br><span class="line">res = dist[r][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-573-build-post-office-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-573-build-post-office-ii&quot;&gt;&lt;/a&gt; LintCode Q 573 - Build Post Office II&lt;/h1&gt;
&lt;p&gt;Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the sum of the distance from the post office to all the houses is smallest.&lt;br&gt;
Return the smallest sum of distance. Return -1 if it is not possible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[[0,1,0,0,0],[1,0,0,2,1],[0,1,0,0,0]] ; Output：8&lt;/code&gt;&lt;br&gt;
Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[[0,1,0],[1,0,1],[0,1,0]] ; Output：4&lt;/code&gt;&lt;br&gt;
Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Challenge:&lt;/strong&gt; Solve this problem within O(n^3) time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You cannot pass through wall and house, but can pass through empty.&lt;/li&gt;
&lt;li&gt;You only build post office on an empty.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Rectangle Enclosing Black Pixels</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ803/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ803/</id>
    <published>2019-05-04T23:08:55.000Z</published>
    <updated>2019-05-04T23:17:30.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-803-smallest-rectangle-enclosing-black-pixels"><a class="markdownIt-Anchor" href="#lintcode-q-803-smallest-rectangle-enclosing-black-pixels"></a> LintCode Q 803 - Smallest Rectangle Enclosing Black Pixels</h1><p>You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:</p><ul><li>Each 0 marks an empty land which you can pass by freely.</li><li>Each 1 marks a building which you cannot pass through.</li><li>Each 2 marks an obstacle which you cannot pass through.</li></ul><p>Example 1<br><code>Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]] ; Output: 7</code><br>Explanation:<br>In this example, there are three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).<br>1 - 0 - 2 - 0 - 1<br>|   |   |   |   |<br>0 - 0 - 0 - 0 - 0<br>|   |   |   |   |<br>0 - 0 - 1 - 0 - 0<br>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p><p>Example 2<br><code>Input: [[1,0],[0,0]] ; Output: 1</code><br>In this example, there is one buildings at (0,0).<br>1 - 0<br>|   |<br>0 - 0<br>The point (1,0) or (0,1) is an ideal empty land to build a house, as the total travel distance of 1 is minimal. So return 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><ul><li>Use BFS to calculte the distance from house to every empty land in the graph.</li><li>Add distances of all houses to every empty land together.</li><li>Choose the smallest distance</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length;</span><br><span class="line"><span class="keyword">int</span> C = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[R][C]; <span class="comment">// record how many houses have reached this land;</span></span><br><span class="line"><span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[R][C]; <span class="comment">// recode the total ditance from an empty land to all houses</span></span><br><span class="line"><span class="keyword">int</span> building = <span class="number">0</span>; <span class="comment">// number of houses</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="comment">// find a house</span></span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">building++; <span class="comment">// increase number of house</span></span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">// dist from curr house to land</span></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size(); <span class="comment">// BFS layer by layer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">distance[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] += level;</span><br><span class="line">reach[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != <span class="number">0</span> || visited[nr][nc]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">level++; <span class="comment">// update dist layer by layer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span> &amp;&amp; reach[r][c] == building &amp;&amp; distance[r][c] &lt; res)</span><br><span class="line">res = distance[r][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == Integer.MAX_VALUE)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-803-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-803-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;/a&gt; LintCode Q 803 - Smallest Rectangle Enclosing Black Pixels&lt;/h1&gt;
&lt;p&gt;You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each 0 marks an empty land which you can pass by freely.&lt;/li&gt;
&lt;li&gt;Each 1 marks a building which you cannot pass through.&lt;/li&gt;
&lt;li&gt;Each 2 marks an obstacle which you cannot pass through.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1&lt;br&gt;
&lt;code&gt;Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
In this example, there are three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).&lt;br&gt;
1 - 0 - 2 - 0 - 1&lt;br&gt;
|   |   |   |   |&lt;br&gt;
0 - 0 - 0 - 0 - 0&lt;br&gt;
|   |   |   |   |&lt;br&gt;
0 - 0 - 1 - 0 - 0&lt;br&gt;
The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.&lt;/p&gt;
&lt;p&gt;Example 2&lt;br&gt;
&lt;code&gt;Input: [[1,0],[0,0]] ; Output: 1&lt;/code&gt;&lt;br&gt;
In this example, there is one buildings at (0,0).&lt;br&gt;
1 - 0&lt;br&gt;
|   |&lt;br&gt;
0 - 0&lt;br&gt;
The point (1,0) or (0,1) is an ideal empty land to build a house, as the total travel distance of 1 is minimal. So return 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Rectangle Enclosing Black Pixels</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ600/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ600/</id>
    <published>2019-05-04T23:01:34.000Z</published>
    <updated>2019-05-04T23:16:35.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-600-smallest-rectangle-enclosing-black-pixels"><a class="markdownIt-Anchor" href="#lintcode-q-600-smallest-rectangle-enclosing-black-pixels"></a> LintCode Q 600 - Smallest Rectangle Enclosing Black Pixels</h1><p>An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p><p>Example 1:<br><code>Input：[&quot;0010&quot;,&quot;0110&quot;,&quot;0100&quot;]，x=0，y=2 ; Output：6</code><br>Explanation：<br>The upper left coordinate of the matrix is (0,1), and the lower right coordinate is (2,2).</p><p>Example 2:<br><code>Input：[&quot;0000&quot;,&quot;0101&quot;,&quot;0000&quot;]，x=1，y=1 ; Output：3</code><br>Explanation：<br>The upper left coordinate of the matrix is (1,1), and the lower right coordinate is (1,3).</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = image.length, C = image[<span class="number">0</span>].length;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;); image[x][y] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> l = x, r = x, t = y, b = y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || image[nr][nc] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">image[nr][nc] = <span class="string">'0'</span>;</span><br><span class="line">l = Math.min(l, nr); r = Math.max(r, nr);</span><br><span class="line">t = Math.min(t, nc); b = Math.max(b, nc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (r - l + <span class="number">1</span>) * (b - t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-600-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-600-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;/a&gt; LintCode Q 600 - Smallest Rectangle Enclosing Black Pixels&lt;/h1&gt;
&lt;p&gt;An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;0010&amp;quot;,&amp;quot;0110&amp;quot;,&amp;quot;0100&amp;quot;]，x=0，y=2 ; Output：6&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
The upper left coordinate of the matrix is (0,1), and the lower right coordinate is (2,2).&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;0000&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0000&amp;quot;]，x=1，y=1 ; Output：3&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
The upper left coordinate of the matrix is (1,1), and the lower right coordinate is (1,3).&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Number of Islands II</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ434/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ434/</id>
    <published>2019-05-04T22:49:46.000Z</published>
    <updated>2019-05-04T23:16:44.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-434-number-of-islands-ii"><a class="markdownIt-Anchor" href="#lintcode-q-434-number-of-islands-ii"></a> LintCode Q 434 - Number of Islands II</h1><p>Given a n,m which means the row and column of the 2D matrix and an array of pair A( size k). Originally, the 2D matrix is all 0 which means there is only sea in the matrix. The list pair has k operator and each operator has two integer A[i].x, A[i].y means that you can change the grid matrix[A[i].x][A[i].y] from sea to island. Return how many island are there in the matrix after each operator.</p><p>Example 1:<br><code>Input: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]] ; Output: [1,1,2,2]</code><br>Explanation:</p><ol><li>00000<br>00000<br>00000<br>00000</li><li>00000<br>01000<br>00000<br>00000</li><li>01000<br>01000<br>00000<br>00000</li><li>01000<br>01000<br>00000<br>00010</li><li>01000<br>01000<br>00000<br>00011</li></ol><p>Example 2:<br><code>Input: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]; Output: [1,1,2,2]</code></p><p><strong>Notice:</strong> 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-union-find"><a class="markdownIt-Anchor" href="#solution-1-union-find"></a> Solution 1 : Union Find</h3><p>We don’t need an addition array to record if we have visited a node, we can set <code>M[i][i] = 2</code> to indiate that.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != parent[x]) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123; parent[py] = px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, Point[] operators)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (R == <span class="number">0</span> || C == <span class="number">0</span> || operators == <span class="keyword">null</span> || operators.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Point operator: operators) &#123;</span><br><span class="line"><span class="keyword">int</span> r = operator.x, c = operator.y;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">grid[r][c] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C </span><br><span class="line">|| grid[nr][nc] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> pa = ufs.find(r * C + c);</span><br><span class="line"><span class="keyword">int</span> npa = ufs.find(nr * C + nc);</span><br><span class="line"><span class="keyword">if</span> (pa != npa) &#123;</span><br><span class="line">count--;</span><br><span class="line">ufs.union(pa, npa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.add(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-434-number-of-islands-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-434-number-of-islands-ii&quot;&gt;&lt;/a&gt; LintCode Q 434 - Number of Islands II&lt;/h1&gt;
&lt;p&gt;Given a n,m which means the row and column of the 2D matrix and an array of pair A( size k). Originally, the 2D matrix is all 0 which means there is only sea in the matrix. The list pair has k operator and each operator has two integer A[i].x, A[i].y means that you can change the grid matrix[A[i].x][A[i].y] from sea to island. Return how many island are there in the matrix after each operator.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]] ; Output: [1,1,2,2]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;00000&lt;br&gt;
00000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;00000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00010&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00011&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]; Output: [1,1,2,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="LinttCode" scheme="http://yoursite.com/tags/LinttCode/"/>
    
  </entry>
  
  <entry>
    <title>Friend Circle</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ547/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ547/</id>
    <published>2019-05-04T22:26:18.000Z</published>
    <updated>2019-05-04T22:42:14.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-547-friend-circle"><a class="markdownIt-Anchor" href="#leetcode-q-547-friend-circle"></a> LeetCode Q 547 - Friend Circle</h1><p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a N * N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p>Example 1:<br>Input:<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>Output: 2<br>Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.<br>The 2nd student himself is in a friend circle. So return 2.</p><p>Example 2:<br>Input:<br>[[1,1,0],<br>[1,1,1],<br>[0,1,1]]<br>Output: 1<br>Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,<br>so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</p><p><strong>Note:</strong><br>N is in range [1,200].<br>M[i][i] = 1 for all students.<br>If M[i][j] = 1, then M[j][i] = 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>We don’t need an addition array to record if we have visited a node, we can set <code>M[i][i] = 2</code> to indiate that.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">dfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> curr)</span> </span>&#123;</span><br><span class="line">M[curr][curr] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][curr] == <span class="number">1</span> &amp;&amp; M[i][i] == <span class="number">1</span>)</span><br><span class="line">dfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">bfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> student)</span> </span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(student);</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line">M[curr][curr] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span> &amp;&amp; M[i][curr] == <span class="number">1</span>)</span><br><span class="line">que.offer(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-3-disjoint-set"><a class="markdownIt-Anchor" href="#solution-3-disjoint-set"></a> Solution 3 : Disjoint Set</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) </span><br><span class="line">parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">parent[px] = py;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = M.length;</span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(N);</span><br><span class="line">ufs.count = N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(i) != ufs.find(j))</span><br><span class="line">ufs.union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-547-friend-circle&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-547-friend-circle&quot;&gt;&lt;/a&gt; LeetCode Q 547 - Friend Circle&lt;/h1&gt;
&lt;p&gt;There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.&lt;/p&gt;
&lt;p&gt;Given a N * N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,0],&lt;br&gt;
[0,0,1]]&lt;br&gt;
Output: 2&lt;br&gt;
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.&lt;br&gt;
The 2nd student himself is in a friend circle. So return 2.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,1],&lt;br&gt;
[0,1,1]]&lt;br&gt;
Output: 1&lt;br&gt;
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,&lt;br&gt;
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;
N is in range [1,200].&lt;br&gt;
M[i][i] = 1 for all students.&lt;br&gt;
If M[i][j] = 1, then M[j][i] = 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Flood Fill</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ733/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ733/</id>
    <published>2019-05-04T22:17:06.000Z</published>
    <updated>2019-05-04T22:23:56.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-733-flood-fill"><a class="markdownIt-Anchor" href="#leetcode-q-733-flood-fill"></a> LeetCode Q 733 - Flood Fill</h1><p>An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).<br>Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.<br>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.<br>At the end, return the modified image.</p><p>Example 1:<br><code>Input: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 ; Output: [[2,2,2],[2,2,0],[2,0,1]]</code><br>Explanation:<br>From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.</p><p><strong>Note:</strong></p><ul><li>The length of image and image[0] will be in the range [1, 50].</li><li>The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length.</li><li>The value of each color in image[i][j] and newColor will be an integer in [0, 65535].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line"><span class="keyword">if</span> (newColor != image[sr][sc])</span><br><span class="line">dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oriColor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sc &lt; <span class="number">0</span> || sr == image.length || sc == image[<span class="number">0</span>].length || image[sr][sc] != oriColor) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">image[sr][sc] = newColor;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = sr + DIRS[i], nc = sc + DIRS[i + <span class="number">1</span>];</span><br><span class="line">dfs(image, nr, nc, newColor, oriColor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">image[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] = newColor;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> ny = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= image.length || ny &gt;= image[<span class="number">0</span>].length || image[nx][ny] != oldColor) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-733-flood-fill&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-733-flood-fill&quot;&gt;&lt;/a&gt; LeetCode Q 733 - Flood Fill&lt;/h1&gt;
&lt;p&gt;An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).&lt;br&gt;
Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.&lt;br&gt;
To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.&lt;br&gt;
At the end, return the modified image.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 ; Output: [[2,2,2],[2,2,0],[2,0,1]]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of image and image[0] will be in the range [1, 50].&lt;/li&gt;
&lt;li&gt;The given starting pixel will satisfy 0 &amp;lt;= sr &amp;lt; image.length and 0 &amp;lt;= sc &amp;lt; image[0].length.&lt;/li&gt;
&lt;li&gt;The value of each color in image[i][j] and newColor will be an integer in [0, 65535].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Number of Islands</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ200/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ200/</id>
    <published>2019-05-04T15:32:36.000Z</published>
    <updated>2019-05-05T15:45:35.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-200-number-of-islands"><a class="markdownIt-Anchor" href="#leetcode-q-200-number-of-islands"></a> LeetCode Q 200 - Number of Islands</h1><p>Given a 2d grid map of '1’s (land) and '0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:<br>Input:<br>11110<br>11010<br>11000<br>00000<br>Output: 1</p><p>Example 2:<br>Input:<br>11000<br>11000<br>00100<br>00011<br>Output: 3</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>We don’t need another boolean[][] visited, since we can set the visited element <code>grid[r][c] = '0'</code> to <strong>avoid re-visit</strong>.<br>Time complexity : R * C nodes,  O(R * C)</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">dfs(grid, i, j);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.length || c == grid[<span class="number">0</span>].length || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">dfs(grid, r + DIRS[i], c + DIRS[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">grid[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="string">'1'</span>) </span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-3-disjoint-set"><a class="markdownIt-Anchor" href="#solution-3-disjoint-set"></a> Solution 3 : Disjoint Set</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) </span><br><span class="line">parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">parent[px] = py;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;   </span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) total++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ufs.count = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">ufs.union(r * C + c, nr * C + nc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-200-number-of-islands&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-200-number-of-islands&quot;&gt;&lt;/a&gt; LeetCode Q 200 - Number of Islands&lt;/h1&gt;
&lt;p&gt;Given a 2d grid map of &#39;1’s (land) and &#39;0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
11110&lt;br&gt;
11010&lt;br&gt;
11000&lt;br&gt;
00000&lt;br&gt;
Output: 1&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
11000&lt;br&gt;
11000&lt;br&gt;
00100&lt;br&gt;
00011&lt;br&gt;
Output: 3&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
</feed>
