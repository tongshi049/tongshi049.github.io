<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T22:34:38.424Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sort Characters By Frequency</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ451/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ451/</id>
    <published>2019-04-21T22:04:39.000Z</published>
    <updated>2019-04-21T22:34:38.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-451-sort-characters-by-frequency"><a class="markdownIt-Anchor" href="#leetcode-q-451-sort-characters-by-frequency"></a> LeetCode Q 451 - Sort Characters By Frequency</h1><p>Given a string, sort it in decreasing order based on the frequency of characters.</p><p><strong>Example 1:</strong><br><code>Input: &quot;tree&quot; ; Output: &quot;eert&quot;</code><br>Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.<br><strong>Example 2:</strong><br><code>Input: &quot;cccaaa&quot; ; Output: &quot;cccaaa&quot;</code><br>Explanation: Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer. Note that “cacaca” is incorrect, as the same characters must be together.<br><strong>Example 3:</strong><br><code>Input: &quot;Aabb&quot; ; Output: &quot;bbAa&quot;</code><br>Explanation: “bbaA” is also a valid answer, but “Aabb” is incorrect. Note that ‘A’ and ‘a’ are treated as two different characters.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s == <span class="string">""</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) </span><br><span class="line">map.put(ch, map.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Character&gt;[] buckets = <span class="keyword">new</span> List[s.length() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(ch);</span><br><span class="line"><span class="keyword">if</span> (buckets[freq] == <span class="keyword">null</span>) buckets[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">buckets[freq].add(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (buckets[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: buckets[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; i; num++)</span><br><span class="line">res.append(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-451-sort-characters-by-frequency&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-451-sort-characters-by-frequency&quot;&gt;&lt;/a&gt; LeetCode Q 451 - Sort Characters By Frequency&lt;/h1&gt;
&lt;p&gt;Given a string, sort it in decreasing order based on the frequency of characters.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;tree&amp;quot; ; Output: &amp;quot;eert&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: ‘e’ appears twice while ‘r’ and ‘t’ both appear once. So ‘e’ must appear before both ‘r’ and ‘t’. Therefore “eetr” is also a valid answer.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;cccaaa&amp;quot; ; Output: &amp;quot;cccaaa&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: Both ‘c’ and ‘a’ appear three times, so “aaaccc” is also a valid answer. Note that “cacaca” is incorrect, as the same characters must be together.&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;Aabb&amp;quot; ; Output: &amp;quot;bbAa&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation: “bbaA” is also a valid answer, but “Aabb” is incorrect. Note that ‘A’ and ‘a’ are treated as two different characters.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Longest Palindrome</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ409/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ409/</id>
    <published>2019-04-21T22:01:23.000Z</published>
    <updated>2019-04-21T22:16:38.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-409-longest-palindrome"><a class="markdownIt-Anchor" href="#leetcode-q-409-longest-palindrome"></a> LeetCode Q 409 - Longest Palindrome</h1><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br>This is case sensitive, for example “Aa” is not considered a palindrome here.<br>Note:Assume the length of given string will not exceed 1,010.</p><p><strong>Example:</strong><br><code>Input: &quot;abccccdd&quot; ; Output: 7</code><br>Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray())</span><br><span class="line">count[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>, hasOdd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: count) &#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) maxLen += num;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">hasOdd = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> maxLen += (num - <span class="number">1</span>); <span class="comment">// "ccc" --&gt; 3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> hasOdd == <span class="number">0</span> ? maxLen : maxLen + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-409-longest-palindrome&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-409-longest-palindrome&quot;&gt;&lt;/a&gt; LeetCode Q 409 - Longest Palindrome&lt;/h1&gt;
&lt;p&gt;Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.&lt;br&gt;
This is case sensitive, for example “Aa” is not considered a palindrome here.&lt;br&gt;
Note:Assume the length of given string will not exceed 1,010.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: &amp;quot;abccccdd&amp;quot; ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Find the Difference</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ389/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ389/</id>
    <published>2019-04-21T21:54:34.000Z</published>
    <updated>2019-04-21T22:16:54.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-389-find-the-difference"><a class="markdownIt-Anchor" href="#leetcode-q-389-find-the-difference"></a> LeetCode Q 389 - Find the Difference</h1><p>Given two strings s and t which consist of only lowercase letters.<br>String t is generated by random shuffling string s and then add one more letter at a random position.<br>Find the letter that was added in t.</p><p><strong>Example:</strong><br><code>Input: s = &quot;abcd&quot; t = &quot;abcde&quot; ; Output: e</code><br>Explanation: ‘e’ is the letter that was added.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:t.toCharArray()) sum += (<span class="keyword">int</span>)ch;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> ch:s.toCharArray()) sum -= (<span class="keyword">int</span>)ch;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">char</span>)sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-389-find-the-difference&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-389-find-the-difference&quot;&gt;&lt;/a&gt; LeetCode Q 389 - Find the Difference&lt;/h1&gt;
&lt;p&gt;Given two strings s and t which consist of only lowercase letters.&lt;br&gt;
String t is generated by random shuffling string s and then add one more letter at a random position.&lt;br&gt;
Find the letter that was added in t.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; ; Output: e&lt;/code&gt;&lt;br&gt;
Explanation: ‘e’ is the letter that was added.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>First Unique Character in a String</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ387/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ387/</id>
    <published>2019-04-21T21:51:57.000Z</published>
    <updated>2019-04-21T21:53:55.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-387-first-unique-character-in-a-string"><a class="markdownIt-Anchor" href="#leetcode-q-387-first-unique-character-in-a-string"></a> LeetCode Q 387 - First Unique Character in a String</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p><p>Examples:<br><code>s = &quot;leetcode&quot; return 0. s = &quot;loveleetcode&quot;, return 2.</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray())</span><br><span class="line">count[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(i)] == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-387-first-unique-character-in-a-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-387-first-unique-character-in-a-string&quot;&gt;&lt;/a&gt; LeetCode Q 387 - First Unique Character in a String&lt;/h1&gt;
&lt;p&gt;Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;
&lt;code&gt;s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2.&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Design Twitter</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ355/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ355/</id>
    <published>2019-04-21T17:11:41.000Z</published>
    <updated>2019-04-21T22:19:56.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-355-design-twitter"><a class="markdownIt-Anchor" href="#leetcode-q-355-design-twitter"></a> LeetCode Q 355 - Design Twitter</h1><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p><ol><li><strong>postTweet(userId, tweetId)</strong>: Compose a new tweet.</li><li><strong>getNewsFeed(userId)</strong>: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li><li><strong>follow(followerId, followeeId)</strong>: Follower follows a followee.</li><li><strong>unfollow(followerId, followeeId)</strong>: Follower unfollows a followee.<br>Example:<br><code>Twitter twitter = new Twitter();</code><br>// User 1 posts a new tweet (id = 5).<br><code>twitter.postTweet(1, 5);</code><br>// User 1’s news feed should return a list with 1 tweet id -&gt; [5].<br><code>twitter.getNewsFeed(1);</code><br>// User 1 follows user 2.<br><code>twitter.follow(1, 2);</code><br>// User 2 posts a new tweet (id = 6).<br><code>twitter.postTweet(2, 6);</code><br>// User 1’s news feed should return a list with 2 tweet ids -&gt; [6, 5].<br>// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.<br><code>twitter.getNewsFeed(1);</code><br>// User 1 unfollows user 2.<br><code>twitter.unfollow(1, 2);</code><br>// User 1’s news feed should return a list with 1 tweet id -&gt; [5],<br>// since user 1 is no longer following user 2.<br><code>twitter.getNewsFeed(1);</code></li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-hashtable"><a class="markdownIt-Anchor" href="#method-1-hashtable"></a> Method 1: HashTable</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Tweet&gt; tweetMap;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; userMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;   <span class="comment">// increase an time field to the Tweet class</span></span><br><span class="line"><span class="keyword">int</span> tweetId; <span class="comment">// enable the sorting by time function</span></span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line">Tweet next;  <span class="comment">// in the tweetMap, we only store the most recent tweet and use next attribute to find its next recent tweet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetId = id; <span class="keyword">this</span>.time = time; <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize your data structure here.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">this</span>.userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose a new tweet. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> twitId)</span> </span>&#123;</span><br><span class="line">Tweet curr = <span class="keyword">new</span> Tweet(twitId, ++timeStamp);</span><br><span class="line">curr.next = tweetMap.getOrDefault(userId, <span class="keyword">null</span>);</span><br><span class="line">tweetMap.put(userId, curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(userId); <span class="comment">// add the user itself</span></span><br><span class="line"><span class="keyword">if</span> (userMap.containsKey(userId)) set.addAll(userMap.get(userId));</span><br><span class="line"></span><br><span class="line">Queue&lt;Tweet&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (b.time - a.time));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: set) &#123;</span><br><span class="line"><span class="keyword">if</span> (tweetMap.get(num) != <span class="keyword">null</span>) pq.offer(tweetMap.get(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">Tweet t = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (t.next != <span class="keyword">null</span>) pq.offer(t.next);</span><br><span class="line">count++;</span><br><span class="line">res.add(t.tweetId);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">userMap.putIfAbsent(followerId, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">userMap.get(followerId).add(followeeId);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower unfollows a followee. If the operation is invalid, it should be a no-op. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (userMap.get(followerId) == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">userMap.get(followerId).remove(followeeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-ood-todo"><a class="markdownIt-Anchor" href="#method-2-ood-todo"></a> Method 2: OOD (TODO)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-355-design-twitter&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-355-design-twitter&quot;&gt;&lt;/a&gt; LeetCode Q 355 - Design Twitter&lt;/h1&gt;
&lt;p&gt;Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;postTweet(userId, tweetId)&lt;/strong&gt;: Compose a new tweet.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getNewsFeed(userId)&lt;/strong&gt;: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;follow(followerId, followeeId)&lt;/strong&gt;: Follower follows a followee.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unfollow(followerId, followeeId)&lt;/strong&gt;: Follower unfollows a followee.&lt;br&gt;
Example:&lt;br&gt;
&lt;code&gt;Twitter twitter = new Twitter();&lt;/code&gt;&lt;br&gt;
// User 1 posts a new tweet (id = 5).&lt;br&gt;
&lt;code&gt;twitter.postTweet(1, 5);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 1 tweet id -&amp;gt; [5].&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;br&gt;
// User 1 follows user 2.&lt;br&gt;
&lt;code&gt;twitter.follow(1, 2);&lt;/code&gt;&lt;br&gt;
// User 2 posts a new tweet (id = 6).&lt;br&gt;
&lt;code&gt;twitter.postTweet(2, 6);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 2 tweet ids -&amp;gt; [6, 5].&lt;br&gt;
// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;br&gt;
// User 1 unfollows user 2.&lt;br&gt;
&lt;code&gt;twitter.unfollow(1, 2);&lt;/code&gt;&lt;br&gt;
// User 1’s news feed should return a list with 1 tweet id -&amp;gt; [5],&lt;br&gt;
// since user 1 is no longer following user 2.&lt;br&gt;
&lt;code&gt;twitter.getNewsFeed(1);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="OOD" scheme="http://yoursite.com/tags/OOD/"/>
    
  </entry>
  
  <entry>
    <title>Find All Anagrams in a String</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ438/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ438/</id>
    <published>2019-04-21T16:51:16.000Z</published>
    <updated>2019-04-21T22:21:06.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-438-find-all-anagrams-in-a-string"><a class="markdownIt-Anchor" href="#leetcode-q-438-find-all-anagrams-in-a-string"></a> LeetCode Q 438 - Find All Anagrams in a String</h1><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.<br>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.<br>The order of output does not matter.</p><p><strong>Example 1:</strong><br><code>Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; ; Output: [0, 6]</code><br>Explanation: The substring with start index = 0 is “cba”, which is an anagram of “abc”. The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br><strong>Example 2:</strong><br><code>Input: s: &quot;abab&quot; p: &quot;ab&quot; ; Output: [0, 1, 2]</code><br>Explanation: The substring with start index = 0 is “ab”, which is an anagram of “ab”. The substring with start index = 1 is “ba”, which is an anagram of “ab”. The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/20/lintcodeQ386/" title="Longest Substring with At Most K Distinct Characters">Longest Substring with At Most K Distinct Characters</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sliding-window"><a class="markdownIt-Anchor" href="#method-1-sliding-window"></a> Method 1: Sliding Window</h3><p><strong>Time Complexity: O(n), n is the length of String s.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r) - <span class="string">'a'</span>] &gt; <span class="number">0</span>) sum++;</span><br><span class="line">count[s.charAt(r++) - <span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">if</span> (sum == p.length()) res.add(l);</span><br><span class="line"><span class="keyword">if</span> (r - l == p.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] &gt;= <span class="number">0</span>) sum--;</span><br><span class="line">count[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-naive-method"><a class="markdownIt-Anchor" href="#method-2-naive-method"></a> Method 2: Naive Method</h3><p><strong>Time Complexity: O(m * n), n is the length of String s, m is the length of String p.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - p.length(); i++) &#123;</span><br><span class="line">String str = s.substring(i, i + p.length());</span><br><span class="line"><span class="keyword">if</span> (isAnagram(str, p)) res.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch-<span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) count[ch-<span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) </span><br><span class="line"><span class="keyword">if</span> (count[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;/a&gt; LeetCode Q 438 - Find All Anagrams in a String&lt;/h1&gt;
&lt;p&gt;Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.&lt;br&gt;
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.&lt;br&gt;
The order of output does not matter.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; ; Output: [0, 6]&lt;/code&gt;&lt;br&gt;
Explanation: The substring with start index = 0 is “cba”, which is an anagram of “abc”. The substring with start index = 6 is “bac”, which is an anagram of “abc”.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot; ; Output: [0, 1, 2]&lt;/code&gt;&lt;br&gt;
Explanation: The substring with start index = 0 is “ab”, which is an anagram of “ab”. The substring with start index = 1 is “ba”, which is an anagram of “ab”. The substring with start index = 2 is “ab”, which is an anagram of “ab”.&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/20/lintcodeQ386/&quot; title=&quot;Longest Substring with At Most K Distinct Characters&quot;&gt;Longest Substring with At Most K Distinct Characters&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring with At Most K Distinct Characters</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ386/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ386/</id>
    <published>2019-04-20T23:53:12.000Z</published>
    <updated>2019-04-21T16:58:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"><a class="markdownIt-Anchor" href="#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"></a> LeetCode Q 386 - Longest Substring with At Most K Distinct Characters</h1><p>Given a string S, find the length of the longest substring T that contains at most k distinct characters.</p><p>Example 1:<br><code>Input: S = &quot;eceba&quot; and k = 3 ; Output: 4 ; Explanation: T = &quot;eceb&quot;</code><br>Example 2:<br><code>Input: S = &quot;WORLD&quot; and k = 4 ; Output: 4 ; Explanation: T = &quot;WORL&quot; or &quot;ORLD&quot;</code><br><strong>Challenge</strong> : O(n) time</p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/21/leetcodeQ438/" title="Find All Anagrams in a String">Find All Anagrams in a String</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Sliding Window: Time Complexity: O(n)</strong></p><h3 id="method-1-use-an-array"><a class="markdownIt-Anchor" href="#method-1-use-an-array"></a> Method 1: Use an array</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length() &lt;= k) <span class="keyword">return</span> s.length();</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, maxLen = <span class="number">0</span>;;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">count[s.charAt(r)]++;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r)] == <span class="number">1</span>) sum++;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">count[s.charAt(l)]--;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] == <span class="number">0</span>) sum--;</span><br><span class="line">l++;</span><br><span class="line">&#125; </span><br><span class="line">maxLen = Math.max(maxLen, r - l + <span class="number">1</span>);</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-use-an-hashmap"><a class="markdownIt-Anchor" href="#method-2-use-an-hashmap"></a> Method 2: Use an hashmap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store char and number of occurance. </span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class="line"><span class="keyword">char</span> curr = s.charAt(end);</span><br><span class="line"><span class="keyword">if</span> (map.get(curr) == <span class="keyword">null</span>) map.put(curr, <span class="number">0</span>);</span><br><span class="line">map.put(curr, map.get(curr) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(curr)==<span class="number">1</span>) counter++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check size of k in current window</span></span><br><span class="line"><span class="keyword">while</span>(counter &gt; k) &#123;</span><br><span class="line"><span class="keyword">char</span> first = s.charAt(start);</span><br><span class="line">map.put(first, map.get(first)-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(first) == <span class="number">0</span>) counter--;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">len = Math.max(len, end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;/a&gt; LeetCode Q 386 - Longest Substring with At Most K Distinct Characters&lt;/h1&gt;
&lt;p&gt;Given a string S, find the length of the longest substring T that contains at most k distinct characters.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;eceba&amp;quot; and k = 3 ; Output: 4 ; Explanation: T = &amp;quot;eceb&amp;quot;&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;WORLD&amp;quot; and k = 4 ; Output: 4 ; Explanation: T = &amp;quot;WORL&amp;quot; or &amp;quot;ORLD&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Challenge&lt;/strong&gt; : O(n) time&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/21/leetcodeQ438/&quot; title=&quot;Find All Anagrams in a String&quot;&gt;Find All Anagrams in a String&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ347/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ347/</id>
    <published>2019-04-20T16:41:21.000Z</published>
    <updated>2019-04-20T17:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-347-top-k-frequent-elements"><a class="markdownIt-Anchor" href="#leetcode-q-347-top-k-frequent-elements"></a> LeetCode Q 347 - Top K Frequent Elements</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>Example 1:<br><code>Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]</code><br>Example 2:<br><code>Input: nums = [1], k = 1 ; Output: [1]</code><br><strong>Note</strong>: You may assume k is always valid, <strong>1 ≤ k ≤ number of unique elements</strong>. Your algorithm’s time complexity must be better than <strong>O(n log n)</strong>, where n is the array’s size.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Heap Sort: time O(NlogN)</strong><br><strong>Bucket Sort: tiem O(N)</strong></p><h3 id="solution-1-heap-sort"><a class="markdownIt-Anchor" href="#solution-1-heap-sort"></a> Solution 1: Heap Sort</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (map.get(a) - map.get(b)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line">pq.offer(num);</span><br><span class="line"><span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: pq)</span><br><span class="line">res.add(<span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bucket-sort-counting-sort"><a class="markdownIt-Anchor" href="#solution-2-bucket-sort-counting-sort"></a> Solution 2: Bucket Sort (Counting sort)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// first traverse: calculate frequencies, recode in the map</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// build buckets</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(num);</span><br><span class="line"><span class="keyword">if</span> (lists[freq] == <span class="keyword">null</span>) lists[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists[freq].add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse each bucket </span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lists.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; k != <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">res.addAll(lists[i]);</span><br><span class="line">k -= lists[i].size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;/a&gt; LeetCode Q 347 - Top K Frequent Elements&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [1], k = 1 ; Output: [1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt;: You may assume k is always valid, &lt;strong&gt;1 ≤ k ≤ number of unique elements&lt;/strong&gt;. Your algorithm’s time complexity must be better than &lt;strong&gt;O(n log n)&lt;/strong&gt;, where n is the array’s size.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Pairs</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ336/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ336/</id>
    <published>2019-04-20T16:23:37.000Z</published>
    <updated>2019-04-21T22:22:25.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-336-palindrome-pairs"><a class="markdownIt-Anchor" href="#leetcode-q-336-palindrome-pairs"></a> LeetCode Q 336 - Palindrome Pairs</h1><p>Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.</p><p><strong>Example 1:</strong><br><code>Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;] ; Output: [[0,1],[1,0],[3,2],[2,4]]</code><br>Explanation: The palindromes are [“dcbaabcd”,“abcddcba”,“slls”,“llssssll”]<br><strong>Example 2:</strong><br><code>Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;] ; Output: [[0,1],[1,0]]</code><br>Explanation: The palindromes are [“battab”,“tabbat”]</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is we first store each string and its index in the map.<br>Then, for each string, we divide it into two substrings(<strong>str1 and str2</strong>), and check all the substring pairs.</p><ol><li>if <code>str1</code> is Palindrome, then we reverse <code>str2</code>, and check if the map containsKey <code>reversedStr2</code>. If it contains, then we can concate String <code>reversedStr2</code> and <code>str1</code> to get the palindrome string. <strong>Note:</strong> the <code>reversedStr2</code> should be on the left and <code>str1</code> on the right.</li><li>if <code>str2</code> is Palindrome, then we reverse <code>str1</code>, and check if the map containsKey <code>reversedStr1</code>. If it contains, then we can concate String <code>str2</code> and <code>reversedStr1</code> to get the palindrome string. <strong>Note:</strong> the <code>str2</code> should be on the left and <code>reversedStr1</code> on the right.</li></ol><p><strong>Caution</strong>: MUST CHECK whether str.length() is equal to 0 in either if statement, because we need to make sure we do not add duplicate pairs (if str1.length() == 0, both of str1 and str2 will from input array).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)</span><br><span class="line">map.put(words[i], i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">String word = words[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word.length(); j++) &#123;</span><br><span class="line">String str1 = word.substring(<span class="number">0</span>, j);</span><br><span class="line">String str2 = word.substring(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str1)) &#123;</span><br><span class="line">String reversedStr2 = <span class="keyword">new</span> StringBuilder(str2).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr2) &amp;&amp; map.get(reversedStr2) != i &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">res.add(Arrays.asList(map.get(reversedStr2), str1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str2)) &#123;</span><br><span class="line">String reversedStr1 = <span class="keyword">new</span> StringBuilder(str1).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr1) &amp;&amp; map.get(reversedStr1) != i)</span><br><span class="line">res.add(Arrays.asList(i,map.get(reversedStr1)));   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i++) != str.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-336-palindrome-pairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-336-palindrome-pairs&quot;&gt;&lt;/a&gt; LeetCode Q 336 - Palindrome Pairs&lt;/h1&gt;
&lt;p&gt;Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;] ; Output: [[0,1],[1,0],[3,2],[2,4]]&lt;/code&gt;&lt;br&gt;
Explanation: The palindromes are [“dcbaabcd”,“abcddcba”,“slls”,“llssssll”]&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;] ; Output: [[0,1],[1,0]]&lt;/code&gt;&lt;br&gt;
Explanation: The palindromes are [“battab”,“tabbat”]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>H-Index</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ274-1/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ274-1/</id>
    <published>2019-04-20T16:19:42.000Z</published>
    <updated>2019-04-20T16:25:17.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-274-h-index"><a class="markdownIt-Anchor" href="#leetcode-q-274-h-index"></a> LeetCode Q 274 - H-Index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><p>Similar question: <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Comparing with <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a>, the given citations is unsorted. We can still use <strong>binary search</strong> to solve this question as we did in leetcodeQ275. Then the <strong>time complexity</strong> is <strong>O(NlogN)</strong>. But we can optimize the solution using <strong>bucket sort (counting sort)</strong>. The <strong>time complexity</strong> becomes <strong>O(N)</strong>.</p><p>Assume n is the total number of papers, if we have n+1 buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket. The only exception is that for any paper with larger number of reference than n, we put in the n-th bucket.</p><p>Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result.</p><p>Some tricky cases: [5,5] -&gt; 2 [0,0] -&gt; 0</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = citations.length;</span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> citation: citations) &#123;</span><br><span class="line"><span class="keyword">if</span> (citation &gt;= len) buckets[len]++;</span><br><span class="line"><span class="keyword">else</span> buckets[citation]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">count += buckets[i];</span><br><span class="line"><span class="keyword">if</span> (count &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-274-h-index&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-274-h-index&quot;&gt;&lt;/a&gt; LeetCode Q 274 - H-Index&lt;/h1&gt;
&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
&lt;p&gt;Similar question: &lt;a href=&quot;/2019/04/15/leetcodeQ275/&quot; title=&quot;H-Index II&quot;&gt;H-Index II&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number II</title>
    <link href="http://yoursite.com/2019/04/20/lintcodtQ776/"/>
    <id>http://yoursite.com/2019/04/20/lintcodtQ776/</id>
    <published>2019-04-20T15:24:13.000Z</published>
    <updated>2019-04-20T15:30:14.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-ii"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-ii"></a> LintCode Q 644 - Strobogrammatic Number II</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Find all strobogrammatic numbers that are of length = n.</p><a href="/2019/04/20/lintcodeQ644/" title="Strobogrammatic Number (Mirror Number)">Strobogrammatic Number (Mirror Number)</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We expanded the target String <strong>from center to two sides</strong> by recursively calling the helper method.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strs = helper(n - <span class="number">2</span>, target);</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line"><span class="keyword">if</span> (n != target) res.add(<span class="string">'0'</span> + str + <span class="string">'0'</span>);</span><br><span class="line">res.add(<span class="string">'1'</span> + str + <span class="string">'1'</span>);</span><br><span class="line">res.add(<span class="string">'6'</span> + str + <span class="string">'9'</span>);</span><br><span class="line">res.add(<span class="string">'8'</span> + str + <span class="string">'8'</span>);</span><br><span class="line">res.add(<span class="string">'9'</span> + str + <span class="string">'6'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number II&lt;/h1&gt;
&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;br&gt;
Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodeQ644/&quot; title=&quot;Strobogrammatic Number (Mirror Number)&quot;&gt;Strobogrammatic Number (Mirror Number)&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number (Mirror Number)</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ644/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ644/</id>
    <published>2019-04-20T15:16:14.000Z</published>
    <updated>2019-04-20T15:25:35.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-mirror-number"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-mirror-number"></a> LintCode Q 644 - Strobogrammatic Number (Mirror Number)</h1><p>GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.</p><p>Write a function to determine if a number is mirror. The number is represented as a string.</p><a href="/2019/04/20/lintcodtQ776/" title="Strobogrammatic Number II">Strobogrammatic Number II</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrobogrammatic</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">'0'</span>, <span class="string">'0'</span>); map.put(<span class="string">'1'</span>, <span class="string">'1'</span>); map.put(<span class="string">'6'</span>, <span class="string">'9'</span>); </span><br><span class="line">map.put(<span class="string">'9'</span>, <span class="string">'6'</span>); map.put(<span class="string">'8'</span>, <span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="keyword">if</span> ( !map.containsKey(num.charAt(i)) || </span><br><span class="line">      map.get(num.charAt(i)) != map.get(num.charAt(j)))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number (Mirror Number)&lt;/h1&gt;
&lt;p&gt;GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.&lt;/p&gt;
&lt;p&gt;Write a function to determine if a number is mirror. The number is represented as a string.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodtQ776/&quot; title=&quot;Strobogrammatic Number II&quot;&gt;Strobogrammatic Number II&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ145/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ145/</id>
    <published>2019-04-19T23:08:55.000Z</published>
    <updated>2019-04-19T23:10:08.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-145-binary-tree-postorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-145-binary-tree-postorder-traversal"></a> LeetCode Q 145 - Binary Tree Postorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(<span class="number">0</span>, curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 145 - Binary Tree Postorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ144/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ144/</id>
    <published>2019-04-19T23:04:45.000Z</published>
    <updated>2019-04-19T23:10:58.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-144-binary-tree-preorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-144-binary-tree-preorder-traversal"></a> LeetCode Q 144 - Binary Tree Preorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 144 - Binary Tree Preorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Inorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ94/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ94/</id>
    <published>2019-04-19T22:55:54.000Z</published>
    <updated>2019-04-19T23:11:24.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-94-binary-tree-inorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-94-binary-tree-inorder-traversal"></a> LeetCode Q 94 - Binary Tree Inorder Traversal</h1><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">TreeNode curr = root;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123; stack.push(curr); curr = curr.left; &#125;</span><br><span class="line">curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line">curr = curr.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 94 - Binary Tree Inorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;inorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Window Substring</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ76/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ76/</id>
    <published>2019-04-19T22:32:48.000Z</published>
    <updated>2019-04-19T22:55:31.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-76-minimum-window-substring"><a class="markdownIt-Anchor" href="#leetcode-q-76-minimum-window-substring"></a> LeetCode Q 76 - Minimum Window Substring</h1><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:<br><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot;</code><br><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-sliding-window-hashtable"><a class="markdownIt-Anchor" href="#solution-sliding-window-hashtable"></a> Solution : Sliding window + HashTable</h3><p><code>arr[]:</code> denotes how many letters are still in the string <strong>T</strong>. e.g. if t = “abc”, then in the array values of ‘a’, ‘b’ and ‘c’ are both 1.<br>So, during our traversal of the string <strong>S</strong>, when we encounter ‘a’, we update the table, changing the value of ‘a’ to be 0. Next time we encounter ‘a’, we change the value of ‘a’ to be -1 …</p><p><code>count:</code> denotes how many chars are still required to get a window in S that containing all letters in T. <code>if (count == 0)</code>, we update minLen.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span> || t.length() &gt; s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: t.toCharArray()) arr[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = t.length(), l = <span class="number">0</span>, r = <span class="number">0</span>, minLen = Integer.MAX_VALUE, head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(r)] &gt; <span class="number">0</span>) count--;</span><br><span class="line">arr[s.charAt(r++)]--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l &lt; minLen) &#123; minLen = r - l; head = l; &#125;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(l)] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">arr[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(head, head + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-76-minimum-window-substring&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-76-minimum-window-substring&quot;&gt;&lt;/a&gt; LeetCode Q 76 - Minimum Window Substring&lt;/h1&gt;
&lt;p&gt;Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If there is no such window in S that covers all characters in T, return the empty string “”.&lt;/li&gt;
&lt;li&gt;If there is such window, you are guaranteed that there will always be only one unique minimum window in S.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ187</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ187/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ187/</id>
    <published>2019-04-19T22:24:42.000Z</published>
    <updated>2019-04-19T22:32:16.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-187-repeated-dna-sequences"><a class="markdownIt-Anchor" href="#leetcode-q-187-repeated-dna-sequences"></a> LeetCode Q 187 - Repeated DNA Sequences</h1><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p><p>Example:<br><code>Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot; Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>TODO: use Rabin–Karp algorithm to optimize the solution.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; repeated = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!seen.add(s.substring(i, i + <span class="number">10</span>))) </span><br><span class="line">repeated.add(s.substring(i, i + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(repeated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;/a&gt; LeetCode Q 187 - Repeated DNA Sequences&lt;/h1&gt;
&lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;
&lt;p&gt;Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Happy Number</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ202/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ202/</id>
    <published>2019-04-19T22:22:40.000Z</published>
    <updated>2019-04-21T22:27:40.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-202-happy-number"><a class="markdownIt-Anchor" href="#leetcode-q-202-happy-number"></a> LeetCode Q 202 - Happy Number</h1><p>Write an algorithm to determine if a number is “happy”.</p><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p><p><strong>Example:</strong><br><code>Input: 19 Output: true</code><br>Explanation:<br>1^2 + 9^2 = 82<br>8^2 + 2^2 = 68<br>6^2 + 8^2 = 100<br>1^2 + 0^2 + 02 = 1</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">Set&lt;Integer&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (seen.contains(n)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">seen.add(n);</span><br><span class="line">n = helper(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">res += (n % <span class="number">10</span>) * (n % <span class="number">10</span>); <span class="comment">// (n % 10) ^ 2 is not correct</span></span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-202-happy-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-202-happy-number&quot;&gt;&lt;/a&gt; LeetCode Q 202 - Happy Number&lt;/h1&gt;
&lt;p&gt;Write an algorithm to determine if a number is “happy”.&lt;/p&gt;
&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: 19 Output: true&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
1^2 + 9^2 = 82&lt;br&gt;
8^2 + 2^2 = 68&lt;br&gt;
6^2 + 8^2 = 100&lt;br&gt;
1^2 + 0^2 + 02 = 1&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Count Primes</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ204/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ204/</id>
    <published>2019-04-19T22:15:51.000Z</published>
    <updated>2019-04-21T22:29:42.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-204-count-primes"><a class="markdownIt-Anchor" href="#leetcode-q-204-count-primes"></a> LeetCode Q 204 - Count Primes</h1><p>Count the number of prime numbers less than a non-negative number, n.<br><strong>Example:</strong><br><code>Input: 10 ; Output: 4</code><br>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span>[] notPrimes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!notPrimes[i]) &#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; i * j &lt; n; j++)</span><br><span class="line">notPrimes[i * j] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-204-count-primes&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-204-count-primes&quot;&gt;&lt;/a&gt; LeetCode Q 204 - Count Primes&lt;/h1&gt;
&lt;p&gt;Count the number of prime numbers less than a non-negative number, n.&lt;br&gt;
&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: 10 ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Sentence Similarity</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ856/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ856/</id>
    <published>2019-04-19T21:57:35.000Z</published>
    <updated>2019-04-19T22:12:04.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-856-sentence-similarity"><a class="markdownIt-Anchor" href="#lintcode-q-856-sentence-similarity"></a> LintCode Q 856 -  Sentence Similarity</h1><p>Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.</p><p>For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].</p><p><strong>Note</strong> that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are <strong>not</strong> necessarily similar.</p><p>However, <strong>similarity is symmetric</strong>. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.</p><p>Also, a word is always <strong>similar with itself</strong>. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.</p><p>Finally, <strong>sentences can only be similar if they have the same number of words</strong>. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ205/" title="Isomorphic Strings">Isomorphic Strings</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-hashmap"><a class="markdownIt-Anchor" href="#solution-hashmap"></a> Solution : HashMap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSentenceSimilarity</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (words1.length != words2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the mapping, one word may mapping to many words</span></span><br><span class="line">Map&lt;String, HashSet&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// using Set&lt;String&gt; is wrong</span></span><br><span class="line">Set&lt;String&gt; set;</span><br><span class="line"><span class="keyword">for</span> (List&lt;String&gt; pair: pairs) &#123;</span><br><span class="line">set = map.getOrDefault(pair.get(<span class="number">0</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">set.add(pair.get(<span class="number">1</span>));</span><br><span class="line">map.put(part.get(<span class="number">0</span>), set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (words1[i].equals(words2[i]))  <span class="comment">// a word is similar to itself</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> ( (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &amp;&amp; </span><br><span class="line">     (map.get(words2[i]) == <span class="keyword">null</span> || !map.get(words2[i]).contains(words1[i])) )</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-856-sentence-similarity&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-856-sentence-similarity&quot;&gt;&lt;/a&gt; LintCode Q 856 -  Sentence Similarity&lt;/h1&gt;
&lt;p&gt;Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.&lt;/p&gt;
&lt;p&gt;For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are &lt;strong&gt;not&lt;/strong&gt; necessarily similar.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;similarity is symmetric&lt;/strong&gt;. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.&lt;/p&gt;
&lt;p&gt;Also, a word is always &lt;strong&gt;similar with itself&lt;/strong&gt;. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.&lt;/p&gt;
&lt;p&gt;Finally, &lt;strong&gt;sentences can only be similar if they have the same number of words&lt;/strong&gt;. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ205/&quot; title=&quot;Isomorphic Strings&quot;&gt;Isomorphic Strings&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
</feed>
