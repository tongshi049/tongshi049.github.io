<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-30T20:30:47.892Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01 Matrix</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ542/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ542/</id>
    <published>2019-04-30T20:16:16.000Z</published>
    <updated>2019-04-30T20:30:47.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-542-01-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-542-01-matrix"></a> LeetCode Q 542 - 01 Matrix</h1><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.<br>The distance between two adjacent cells is 1.</p><p>Example 1:<br>Input:<br>[[0,0,0],<br>[0,1,0],<br>[0,0,0]]<br>Output:<br>[[0,0,0],<br>[0,1,0],<br>[0,0,0]]</p><p>Example 2:<br>Input:<br>[[0,0,0],<br>[0,1,0],<br>[1,1,1]]<br>Output:<br>[[0,0,0],<br>[0,1,0],<br>[1,2,1]]</p><p><strong>Note:</strong></p><ul><li>The number of elements of the given matrix will not exceed 10,000.</li><li>There are at least one 0 in the given matrix.</li><li>The cells are adjacent in only four directions: up, down, left and right.</li></ul><a id="more"></a><h2 id="solution-bfs-dp"><a class="markdownIt-Anchor" href="#solution-bfs-dp"></a> Solution : BFS / DP</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1: BFS</h3><p><strong>Steps:</strong><br>We regard the 2D matrix as a string. For an element in the matrix, we use <code>rowNum * colLength + colNum</code> to denote its index.</p><ol><li>push the <code>0s</code> in the matrix to the <code>queue</code>.</li><li>do the bfs, at each level<ul><li>pull the <code>index</code> from the <code>queue</code>. According to that <code>index</code>, we can determine the <code>rowNumber</code> and <code>colNumber</code>.</li><li>we traverse its left, right, up and down, if they haven’t been visited, then we offer them in the queue and visited set.</li><li>when we have finished traversing one layer, we increase the level.</li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(<span class="string">"0000"</span>);</span><br><span class="line">visitedA.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(target);</span><br><span class="line">visitedB.add(target);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-better-solution-dp"><a class="markdownIt-Anchor" href="#a-better-solution-dp"></a> A Better Solution: DP</h3><ol><li><p><strong>States:</strong> <code>dp[i][j]</code> the min distance of number at row i and col j.</p></li><li><p><strong>State Transfer Function:</strong></p><ul><li><p>Iterate the matrix <strong>from top left to bottom right</strong>:<br>Update <code>dp[i][j] = min(dp[i][j], min(dp[i][j - 1], dp[i - 1][j] + 1))</code><br>i.e., minimum of the current dist and distance from top or left neighbour +1, that would have been already calculated previously in the current iteration.</p></li><li><p>Do the back iteration in the similar manner: <strong>from bottom right to top left</strong>:<br>Update <code>dp[i][j] = min(dp[i][j], min(dp[i][j + 1], dp[i + 1][j] + 1))</code><br>i.e. minimum of current dist and distances calculated from bottom and right neighbours, that would be already available in current iteration.</p></li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = R - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = C - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; R - <span class="number">1</span>) dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (j &lt; C - <span class="number">1</span>) dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-542-01-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-542-01-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 542 - 01 Matrix&lt;/h1&gt;
&lt;p&gt;Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.&lt;br&gt;
The distance between two adjacent cells is 1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[0,0,0]]&lt;br&gt;
Output:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[0,0,0]]&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[1,1,1]]&lt;br&gt;
Output:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[1,2,1]]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of elements of the given matrix will not exceed 10,000.&lt;/li&gt;
&lt;li&gt;There are at least one 0 in the given matrix.&lt;/li&gt;
&lt;li&gt;The cells are adjacent in only four directions: up, down, left and right.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Open the Lock</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ752/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ752/</id>
    <published>2019-04-30T20:05:03.000Z</published>
    <updated>2019-04-30T20:15:50.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-752-open-the-lock"><a class="markdownIt-Anchor" href="#leetcode-q-752-open-the-lock"></a> LeetCode Q 752 - Open the Lock</h1><p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>. The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>. Each move consists of turning one wheel one slot.<br>The lock initially starts at <code>0000'</code>, a string representing the state of the 4 wheels.<br>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.<br>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p><p>Example 1:<br><code>Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot; ; Output: 6</code><br>Explanation:<br>A sequence of valid moves would be “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”.<br>Note that a sequence like “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” would be invalid,<br>because the wheels of the lock become stuck after the display becomes the dead end “0102”.</p><p>Example 2:<br><code>Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot; ; Output: 1</code><br>Explanation:<br>We can turn the last wheel in reverse to move from “0000” -&gt; “0009”.</p><p>Example 3:<br><code>Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;, &quot;9888&quot;], target = &quot;8888&quot; ; Output: -1</code><br>Explanation:<br>We can’t reach the target without getting stuck.</p><p>Example 4:<br><code>Input: deadends = [&quot;0000&quot;], target = &quot;8888&quot; ; Output: -1</code></p><p><strong>Note:</strong></p><ul><li>The length of deadends will be in the range [1, 500].</li><li>target will not be in the list deadends.</li><li>Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’.</li></ul><a id="more"></a><h2 id="solution-bfs-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-bfs-two-end-bfs-bidirectional-search"></a> Solution : BFS / Two-End BFS (Bidirectional Search)</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1: BFS</h3><p><strong>Tip:</strong><br>Chaning char[] is <strong>faster</strong> than string concatenation. That is,<br><code>char[] chs = cur.toCharArray(); chs[i] = (char)((cur.charAt(i) - '0' + 9) % 10 + '0'); String next = String.valueOf(chs);</code><br>is better than<br><code>String next = cur.substring(0, i) + (char)((cur.charAt(i) - '0' + 9) % 10 + '0') + cur.substring(i + 1);</code></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) </span><br><span class="line">    deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(<span class="string">"0000"</span>);</span><br><span class="line">visited.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur.equals(target)) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">    que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">    que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-2-two-end-bfs-bidirectional-search"></a> Solution 2: Two-End BFS (Bidirectional Search)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(<span class="string">"0000"</span>);</span><br><span class="line">visitedA.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(target);</span><br><span class="line">visitedB.add(target);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-752-open-the-lock&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-752-open-the-lock&quot;&gt;&lt;/a&gt; LeetCode Q 752 - Open the Lock&lt;/h1&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;&#39;9&#39;&lt;/code&gt; to be &lt;code&gt;&#39;0&#39;&lt;/code&gt;, or &lt;code&gt;&#39;0&#39;&lt;/code&gt; to be &lt;code&gt;&#39;9&#39;&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;br&gt;
The lock initially starts at &lt;code&gt;0000&#39;&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;br&gt;
You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;br&gt;
Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot; ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
A sequence of valid moves would be “0000” -&amp;gt; “1000” -&amp;gt; “1100” -&amp;gt; “1200” -&amp;gt; “1201” -&amp;gt; “1202” -&amp;gt; “0202”.&lt;br&gt;
Note that a sequence like “0000” -&amp;gt; “0001” -&amp;gt; “0002” -&amp;gt; “0102” -&amp;gt; “0202” would be invalid,&lt;br&gt;
because the wheels of the lock become stuck after the display becomes the dead end “0102”.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;8888&amp;quot;], target = &amp;quot;0009&amp;quot; ; Output: 1&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
We can turn the last wheel in reverse to move from “0000” -&amp;gt; “0009”.&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;8887&amp;quot;,&amp;quot;8889&amp;quot;,&amp;quot;8878&amp;quot;,&amp;quot;8898&amp;quot;,&amp;quot;8788&amp;quot;,&amp;quot;8988&amp;quot;,&amp;quot;7888&amp;quot;, &amp;quot;9888&amp;quot;], target = &amp;quot;8888&amp;quot; ; Output: -1&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
We can’t reach the target without getting stuck.&lt;/p&gt;
&lt;p&gt;Example 4:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;0000&amp;quot;], target = &amp;quot;8888&amp;quot; ; Output: -1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of deadends will be in the range [1, 500].&lt;/li&gt;
&lt;li&gt;target will not be in the list deadends.&lt;/li&gt;
&lt;li&gt;Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Ladder II</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ126/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ126/</id>
    <published>2019-04-30T19:34:17.000Z</published>
    <updated>2019-04-30T20:04:07.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-126-word-ladder-ii"><a class="markdownIt-Anchor" href="#leetcode-q-126-word-ladder-ii"></a> LeetCode Q 126 - Word Ladder II</h1><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ul><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li></ul><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume beginWord and endWord are non-empty and are not the same.</li></ul><p>Example 1:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code><br>Output:<br>[<br>[“hit”,“hot”,“dot”,“dog”,“cog”],<br>[“hit”,“hot”,“lot”,“log”,“cog”]<br>]</p><p>Example 2:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code><br>Output: []<br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><a id="more"></a><h2 id="solution-bfs-dfs"><a class="markdownIt-Anchor" href="#solution-bfs-dfs"></a> Solution : BFS + DFS</h2><ol><li><strong>BFS</strong>: find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap;</li><li><strong>DFS</strong>: output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123; </span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; neighbors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">bfs(start, end, dict, neighbors, distance);</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">dfs(start, end, neighbors, distance, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS: Trace every node's distance from the start node (level by level).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, String end, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; neighbors, Map&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: dict) neighbors.put(str, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(start); </span><br><span class="line">distance.put(start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String curr = que.poll();</span><br><span class="line"><span class="keyword">int</span> curDistance = distance.get(cur);                </span><br><span class="line">List&lt;String&gt; nextList = getNeighbors(cur, dict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String next: nextList) &#123;</span><br><span class="line">neighbors.get(curr).add(next);</span><br><span class="line"><span class="keyword">if</span> (!distance.contains(next)) &#123; <span class="comment">// Check if visited</span></span><br><span class="line">distance.put(next, curDistance + <span class="number">1</span>);</span><br><span class="line">que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS: output all paths with the shortest distance.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(String start, String end, Map&lt;String, List&lt;String&gt;&gt; neighbors, Map&lt;String, Integer&gt; distance, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt;()</span> path) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(path)); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path.add(start);</span><br><span class="line"><span class="keyword">for</span> (String next: neighbors.get(start)) &#123;</span><br><span class="line"><span class="keyword">if</span> (distance.get(next) == distance.get(start) + <span class="number">1</span>) </span><br><span class="line">dfs(next, end, neighbors, distance, res, path);</span><br><span class="line">&#125;</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all next level nodes.    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">chs[i] = ch;</span><br><span class="line"><span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">    res.add(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">chs[i] = old_ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-126-word-ladder-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-126-word-ladder-ii&quot;&gt;&lt;/a&gt; LeetCode Q 126 - Word Ladder II&lt;/h1&gt;
&lt;p&gt;Given two words (&lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt;), and a dictionary’s word list, find all shortest transformation sequence(s) from &lt;em&gt;beginWord&lt;/em&gt; to &lt;em&gt;endWord&lt;/em&gt;, such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only one letter can be changed at a time&lt;/li&gt;
&lt;li&gt;Each transformed word must exist in the word list. Note that beginWord is not a transformed word.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return an empty list if there is no such transformation sequence.&lt;/li&gt;
&lt;li&gt;All words have the same length.&lt;/li&gt;
&lt;li&gt;All words contain only lowercase alphabetic characters.&lt;/li&gt;
&lt;li&gt;You may assume no duplicates in the word list.&lt;/li&gt;
&lt;li&gt;You may assume beginWord and endWord are non-empty and are not the same.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[“hit”,“hot”,“dot”,“dog”,“cog”],&lt;br&gt;
[“hit”,“hot”,“lot”,“log”,“cog”]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;]&lt;/code&gt;&lt;br&gt;
Output: []&lt;br&gt;
Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Ladder</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ127/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ127/</id>
    <published>2019-04-30T17:17:04.000Z</published>
    <updated>2019-04-30T19:34:57.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-127-word-ladder"><a class="markdownIt-Anchor" href="#leetcode-q-127-word-ladder"></a> LeetCode Q 127 - Word Ladder</h1><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p>Example 1:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] Output: 5</code><br>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p><p>Example 2:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Output: 0</code><br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><a id="more"></a><h2 id="solution-bfs-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-bfs-two-end-bfs-bidirectional-search"></a> Solution : BFS / Two-End BFS (Bidirectional Search)</h2><h3 id="solution-1-bfs-time-limit-exceeds"><a class="markdownIt-Anchor" href="#solution-1-bfs-time-limit-exceeds"></a> Solution 1: BFS (Time Limit Exceeds)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, List&lt;String&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">wordList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(end)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(start); visited.add(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String curr = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = curr.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">chs[i] = ch;</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (next.equals(end)) <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; wordList.contains(next)) &#123;</span><br><span class="line">que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-2-two-end-bfs-bidirectional-search"></a> Solution 2: Two-End BFS (Bidirectional Search)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, List&lt;String&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">wordList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(end)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(start); visitedA.add(start);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(end); visitedB.add(end);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>;</span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>, setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String word = que.poll();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextList = getNext(word, wordDict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String next: nextList) &#123;</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">levle++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNext</span><span class="params">(String curr, List&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = curr.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (c != old) &#123;</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (dict.contains(next)) </span><br><span class="line">res.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#two-end-bfs-bidirectional-search"></a> Two-End BFS (Bidirectional Search)</h3><p><strong>Bidirectional search</strong> is a graph search algorithm which find <strong>smallest path</strong> form source to goal vertex. It runs two simultaneous search, i.e.</p><ol><li>Forward search form source/initial vertex toward goal vertex</li><li>Backward search form goal/target vertex toward source vertex</li></ol><p>Bidirectional search replaces single search graph(which is likely to grow exponentially) with two smaller sub graphs – one starting from <strong>initial vertex</strong> and other starting from <strong>goal vertex</strong>. The search terminates when two graphs <strong>intersect</strong>.</p><h4 id="why-two-end-bfs"><a class="markdownIt-Anchor" href="#why-two-end-bfs"></a> Why Two-End BFS?</h4><p>Because in many cases it is <strong>faster</strong>, it dramatically reduce the amount of required exploration.<br>Suppose if branching factor of tree is <em><strong>b</strong></em> and distance of goal vertex from source is <em><strong>d</strong></em>, then the normal BFS/DFS searching complexity would be <code>O(b^d)</code>. On the other hand, if we execute two search operation then the complexity would be <code>O(b^(d/2))</code> for each search and total complexity would be <code>O(b^(d/2)+b^(d/2)</code> which is far less than <code>O(b^d)</code>.</p><h4 id="when-to-use-bidirectional-approach"><a class="markdownIt-Anchor" href="#when-to-use-bidirectional-approach"></a> When to use bidirectional approach?</h4><p>We can consider bidirectional approach when</p><ul><li>Both initial and goal states are unique and completely defined.</li><li>The branching factor is exactly the same in both directions.</li></ul><h4 id="performance-measures"><a class="markdownIt-Anchor" href="#performance-measures"></a> Performance measures</h4><p>Time and Space Complexity : Time and space complexity is O(b^{d/2})</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-127-word-ladder&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-127-word-ladder&quot;&gt;&lt;/a&gt; LeetCode Q 127 - Word Ladder&lt;/h1&gt;
&lt;p&gt;Given two words (&lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt;), and a dictionary’s word list, find the length of shortest transformation sequence from &lt;em&gt;beginWord&lt;/em&gt; to &lt;em&gt;endWord&lt;/em&gt;, such that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Only one letter can be changed at a time.&lt;/li&gt;
&lt;li&gt;Each transformed word must exist in the word list. Note that &lt;em&gt;beginWord&lt;/em&gt; is not a transformed word.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return 0 if there is no such transformation sequence.&lt;/li&gt;
&lt;li&gt;All words have the same length.&lt;/li&gt;
&lt;li&gt;All words contain only lowercase alphabetic characters.&lt;/li&gt;
&lt;li&gt;You may assume no duplicates in the word list.&lt;/li&gt;
&lt;li&gt;You may assume &lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt; are non-empty and are not the same.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: As one shortest transformation is “hit” -&amp;gt; “hot” -&amp;gt; “dot” -&amp;gt; “dog” -&amp;gt; “cog”,&lt;br&gt;
return its length 5.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: 0&lt;/code&gt;&lt;br&gt;
Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Search II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ212/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ212/</id>
    <published>2019-04-29T17:31:48.000Z</published>
    <updated>2019-04-29T17:48:32.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-212-word-search-ii"><a class="markdownIt-Anchor" href="#leetcode-q-212-word-search-ii"></a> LeetCode Q 212 - Word Search II</h1><p>Given a 2D board and a list of words from the dictionary, find all words in the board.<br>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>Example:<br>Input:<br>board = [<br>[‘o’,‘a’,‘a’,‘n’],<br>[‘e’,‘t’,‘a’,‘e’],<br>[‘i’,‘h’,‘k’,‘r’],<br>[‘i’,‘f’,‘l’,‘v’]<br>]<br>words = [“oath”,“pea”,“eat”,“rain”]<br>Output: [“eat”,“oath”]</p><p><strong>Note:</strong></p><ul><li>All inputs are consist of lowercase letters a-z.</li><li>The values of words are distinct.</li></ul><a id="more"></a><h2 id="solution-trie-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-trie-dfs-backtracking"></a> Solution : Trie + DFS / Backtracking</h2><p>Compared with <a href="/2019/04/29/leetcodeQ79/" title="Word Search">Word Search</a>, we use DFS with a trie but a word.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>() </span>&#123;</span><br><span class="line">TrieNode[] children;</span><br><span class="line"><span class="keyword">boolean</span> isEnd;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>]) </span><br><span class="line">node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; res;  <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the trie</span></span><br><span class="line"><span class="keyword">for</span> (String word: words) trie.insert(word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> [board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">dfs(board, <span class="string">""</span>, i, j, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String curr, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || visited[row][col]) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">curr += board[row][col];</span><br><span class="line"><span class="keyword">if</span> (!startWith(curr)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (search(curr)) &#123; res.add(curr); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">dfs(board, row + <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row - <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row, col + <span class="number">1</span>, visited);</span><br><span class="line">dfs(board, row, col - <span class="number">1</span>, visited);</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-212-word-search-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-212-word-search-ii&quot;&gt;&lt;/a&gt; LeetCode Q 212 - Word Search II&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a list of words from the dictionary, find all words in the board.&lt;br&gt;
Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Input:&lt;br&gt;
board = [&lt;br&gt;
[‘o’,‘a’,‘a’,‘n’],&lt;br&gt;
[‘e’,‘t’,‘a’,‘e’],&lt;br&gt;
[‘i’,‘h’,‘k’,‘r’],&lt;br&gt;
[‘i’,‘f’,‘l’,‘v’]&lt;br&gt;
]&lt;br&gt;
words = [“oath”,“pea”,“eat”,“rain”]&lt;br&gt;
Output: [“eat”,“oath”]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All inputs are consist of lowercase letters a-z.&lt;/li&gt;
&lt;li&gt;The values of words are distinct.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Word Search</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ79/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ79/</id>
    <published>2019-04-29T17:22:35.000Z</published>
    <updated>2019-04-29T17:31:23.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-79-word-search"><a class="markdownIt-Anchor" href="#leetcode-q-79-word-search"></a> LeetCode Q 79 - Word Search</h1><p>Given a 2D board and a word, find if the word exists in the grid.<br>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:<br>board =<br>[<br>[‘A’,‘B’,‘C’,‘E’],<br>[‘S’,‘F’,‘C’,‘S’],<br>[‘A’,‘D’,‘E’,‘E’]<br>]</p><p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p>**Time Complexity:**O(n^2 * 4 * 3^(k-1)) = O(n^2 * 3^k).</p><p>Explanation: We start the word search over all n^2 nodes. For the first letter of the word search we can move in 4 directions but for every later one there are only three options (you can’t move back onto yourself).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || </span><br><span class="line">visited[row][col] || board[row][col] != word.charAt(pos)) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, pos + <span class="number">1</span>, row - <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row + <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col - <span class="number">1</span>) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-79-word-search&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-79-word-search&quot;&gt;&lt;/a&gt; LeetCode Q 79 - Word Search&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;br&gt;
The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
board =&lt;br&gt;
[&lt;br&gt;
[‘A’,‘B’,‘C’,‘E’],&lt;br&gt;
[‘S’,‘F’,‘C’,‘S’],&lt;br&gt;
[‘A’,‘D’,‘E’,‘E’]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Given word = “ABCCED”, return true.&lt;br&gt;
Given word = “SEE”, return true.&lt;br&gt;
Given word = “ABCB”, return false.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ52/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ52/</id>
    <published>2019-04-29T17:17:50.000Z</published>
    <updated>2019-04-29T17:22:58.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-52-n-queens-ii"><a class="markdownIt-Anchor" href="#leetcode-q-52-n-queens-ii"></a> LeetCode Q 52 - N-Queens II</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p><p>Example:<br><code>Input: 4 ; Output: 2</code><br>Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.<br>[<br>[&quot;.Q…&quot;,  // Solution 1<br>“…Q”,<br>“Q…”,<br>“…Q.”],</p><p>[&quot;…Q.&quot;,  // Solution 2<br>“Q…”,<br>“…Q”,<br>“.Q…”]<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">res++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-52-n-queens-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-52-n-queens-ii&quot;&gt;&lt;/a&gt; LeetCode Q 52 - N-Queens II&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return the number of distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.&lt;br&gt;
[&lt;br&gt;
[&amp;quot;.Q…&amp;quot;,  // Solution 1&lt;br&gt;
“…Q”,&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q.”],&lt;/p&gt;
&lt;p&gt;[&amp;quot;…Q.&amp;quot;,  // Solution 2&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q”,&lt;br&gt;
“.Q…”]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ51/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ51/</id>
    <published>2019-04-29T16:57:30.000Z</published>
    <updated>2019-04-29T17:22:54.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-51-n-queens"><a class="markdownIt-Anchor" href="#leetcode-q-51-n-queens"></a> LeetCode Q 51 - N-Queens</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p><p>Example:<br><code>Input: 4 Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ]</code><br>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> N) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j  = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line"> row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, N, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length)</span><br><span class="line">list.add(String.valueOf(board[i]));</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-51-n-queens&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-51-n-queens&quot;&gt;&lt;/a&gt; LeetCode Q 51 - N-Queens&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;br&gt;
Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 Output: [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;..Q.&amp;quot;], [&amp;quot;..Q.&amp;quot;, // Solution 2 &amp;quot;Q...&amp;quot;, &amp;quot;...Q&amp;quot;, &amp;quot;.Q..&amp;quot;] ]&lt;/code&gt;&lt;br&gt;
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Remove Invalid Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ301/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ301/</id>
    <published>2019-04-29T16:34:02.000Z</published>
    <updated>2019-04-29T16:56:29.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-301-remove-invalid-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-301-remove-invalid-parentheses"></a> LeetCode Q 301 - Remove Invalid Parentheses</h1><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.<br><strong>Note:</strong> The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p><p>Example 1:<br><code>Input: &quot;()())()&quot; ; Output: [&quot;()()()&quot;, &quot;(())()&quot;]</code><br>Example 2:<br><code>Input: &quot;(a)())()&quot; ; Output: [&quot;(a)()()&quot;, &quot;(a())()&quot;]</code><br>Example 3:<br><code>Input: &quot;)(&quot; ; Output: [&quot;&quot;]</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><ol><li>pre-process the String <code>s</code>, determine how many <code>(</code>s and <code>)</code>s we need to delete.</li><li>To avoid duplicates, use a set to store the result.</li><li>Backtrack finding the answer.<ul><li>corner cases: <code>if (rmL &lt; 0 || rmR &lt; 0 || open &lt; 0)</code> indicates an invalid string, we should return;</li><li>our goal(i.e. when to break the backtrack): <code>if (pos == s.length())</code> we should also stop the backtrack, and check<ul><li><code>if (rmL == 0 &amp;&amp; rmR == 0 &amp;&amp; open == 0)</code>, then update the result set;</li><li>else just ruturn;</li></ul></li><li>explore<ul><li>if current char is ‘(’ or ‘)’ we can either choose to <strong>use</strong> it or <strong>not</strong>.</li><li>if current char is a letter we update current string.</li></ul></li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; res; <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> rmL = <span class="number">0</span>, rmR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">rmL++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL != <span class="number">0</span>) rmL--;</span><br><span class="line"><span class="keyword">else</span> rmR++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(s, <span class="number">0</span>, <span class="string">""</span>, rmL, rmR, open);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> pos, String curr, <span class="keyword">int</span> rmL, <span class="keyword">int</span> rmR, <span class="keyword">int</span> open)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rmL &lt; <span class="number">0</span> || rmR &lt; <span class="number">0</span> || open &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL == <span class="number">0</span> &amp;&amp; rmR == <span class="number">0</span> &amp;&amp; open == <span class="number">0</span>) res.add(curr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = s.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open + <span class="number">1</span>); <span class="comment">// use '('</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL - <span class="number">1</span>, rmR, open); <span class="comment">// not use '('</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open - <span class="number">1</span>); <span class="comment">// use ')'</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL, rmR - <span class="number">1</span>, open); <span class="comment">// not use ')'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 301 - Remove Invalid Parentheses&lt;/h1&gt;
&lt;p&gt;Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The input string may contain letters other than the parentheses &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;()())()&amp;quot; ; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;(a)())()&amp;quot; ; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;)(&amp;quot; ; Output: [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Generate Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ22/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ22/</id>
    <published>2019-04-29T16:30:18.000Z</published>
    <updated>2019-04-29T16:33:43.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-22-generate-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-22-generate-parentheses"></a> LeetCode Q 22 - Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:<br>[<br>“((()))”,<br>“(()())”,<br>“(())()”,<br>“()(())”,<br>“()()()”<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; n || right &gt; n || left &lt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curr.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(n, left + <span class="number">1</span>, right, curr + <span class="string">'('</span>);</span><br><span class="line">dfs(n, left, right + <span class="number">1</span>, curr + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-22-generate-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-22-generate-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 22 - Generate Parentheses&lt;/h1&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;br&gt;
[&lt;br&gt;
“((()))”,&lt;br&gt;
“(()())”,&lt;br&gt;
“(())()”,&lt;br&gt;
“()(())”,&lt;br&gt;
“()()()”&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Letter Case Permutation</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ784/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ784/</id>
    <published>2019-04-29T16:11:58.000Z</published>
    <updated>2019-04-29T16:29:39.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-784-letter-case-permutation"><a class="markdownIt-Anchor" href="#leetcode-q-784-letter-case-permutation"></a> LeetCode Q 784 - Letter Case Permutation</h1><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p><p>Examples:<br><code>Input: S = &quot;a1b2&quot; ; Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></p><p><code>Input: S = &quot;3z4&quot; ; Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</code></p><p><code>Input: S = &quot;12345&quot; ; Output: [&quot;12345&quot;]</code></p><p><strong>Note:</strong></p><ul><li>S will be a string with length between 1 and 12.</li><li>S will consist only of letters or digits.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-1-dfs-backtracking"></a> Solution 1 : DFS / Backtracking</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(S, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String S, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == S.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = S.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(ch)) &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toUpperCase(ch));</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toLowerCase(ch));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(S.charAt(i))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">String str = que.poll();</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = Character.toUpperCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">chs[i] = Character.toLowerCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(que);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-784-letter-case-permutation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-784-letter-case-permutation&quot;&gt;&lt;/a&gt; LeetCode Q 784 - Letter Case Permutation&lt;/h1&gt;
&lt;p&gt;Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;a1b2&amp;quot; ; Output: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;3z4&amp;quot; ; Output: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;12345&amp;quot; ; Output: [&amp;quot;12345&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S will be a string with length between 1 and 12.&lt;/li&gt;
&lt;li&gt;S will consist only of letters or digits.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>Permutations II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQQ47/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQQ47/</id>
    <published>2019-04-28T21:28:10.000Z</published>
    <updated>2019-04-30T17:19:36.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-47-permutations-ii"><a class="markdownIt-Anchor" href="#leetcode-q-47-permutations-ii"></a> LeetCode Q 47 - Permutations II</h1><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p>Example:<br><code>Input: [1,1,2]</code><br>Output:<br>[<br>[1,1,2],<br>[1,2,1],<br>[2,1,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Tips:</strong></p><ul><li>Use an extra boolean array <code>boolean[] used</code> to indicate whether the value is added to list.</li><li>Sort the array <code>int[] nums</code> to make sure we can skip the same value.</li><li><strong>When a number has the same value with its previous, we can use this number only if his previous is used.</strong></li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] = nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">visited[i] = <span class="keyword">true</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp, visited);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">visited[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-47-permutations-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-47-permutations-ii&quot;&gt;&lt;/a&gt; LeetCode Q 47 - Permutations II&lt;/h1&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,1,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,1,2],&lt;br&gt;
[1,2,1],&lt;br&gt;
[2,1,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>Permutations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ46/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ46/</id>
    <published>2019-04-28T21:25:40.000Z</published>
    <updated>2019-04-29T16:12:23.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-46-permutations"><a class="markdownIt-Anchor" href="#leetcode-q-46-permutations"></a> LeetCode Q 46 - Permutations</h1><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p>Example:<br><code>Input: [1,2,3]</code><br>Output:<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(nums[i])) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-46-permutations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-46-permutations&quot;&gt;&lt;/a&gt; LeetCode Q 46 - Permutations&lt;/h1&gt;
&lt;p&gt;Given a collection of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3,2],&lt;br&gt;
[2,1,3],&lt;br&gt;
[2,3,1],&lt;br&gt;
[3,1,2],&lt;br&gt;
[3,2,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>Subsets II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ90/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ90/</id>
    <published>2019-04-28T21:22:53.000Z</published>
    <updated>2019-04-28T21:25:00.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets-ii"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets-ii"></a> LeetCode Q 78 - Subsets II</h1><p>Given a collection of integers that might contain duplicates, <em><strong>nums</strong></em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: [1,2,2]</code><br>Output:<br>[<br>[2],<br>[1],<br>[1,2,2],<br>[2,2],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != pos &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets-ii&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets II&lt;/h1&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, &lt;em&gt;&lt;strong&gt;nums&lt;/strong&gt;&lt;/em&gt;, return all possible subsets (the power set).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2],&lt;br&gt;
[1],&lt;br&gt;
[1,2,2],&lt;br&gt;
[2,2],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ78/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ78/</id>
    <published>2019-04-28T21:21:07.000Z</published>
    <updated>2019-04-28T21:22:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets"></a> LeetCode Q 78 - Subsets</h1><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: nums = [1,2,3]</code><br>Output:<br>[<br>[3],<br>[1],<br>[2],<br>[1,2,3],<br>[1,3],<br>[2,3],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets&lt;/h1&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: nums = [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[3],&lt;br&gt;
[1],&lt;br&gt;
[2],&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum III</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ216/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ216/</id>
    <published>2019-04-28T21:17:33.000Z</published>
    <updated>2019-04-28T21:20:41.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-216-combination-sum-iii"><a class="markdownIt-Anchor" href="#leetcode-q-216-combination-sum-iii"></a> LeetCode Q 216 - Combination Sum III</h1><p>Find all possible combinations of <em><strong>k</strong></em> numbers that add up to a number <em><strong>n</strong></em>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: k = 3, n = 7 ; Output: [[1,2,4]]</code><br>Example 2:<br><code>Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(k, target, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k || target &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, target - i, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-216-combination-sum-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-216-combination-sum-iii&quot;&gt;&lt;/a&gt; LeetCode Q 216 - Combination Sum III&lt;/h1&gt;
&lt;p&gt;Find all possible combinations of &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; numbers that add up to a number &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 7 ; Output: [[1,2,4]]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ77/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ77/</id>
    <published>2019-04-28T21:13:16.000Z</published>
    <updated>2019-04-28T21:19:38.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-77-combinations"><a class="markdownIt-Anchor" href="#leetcode-q-77-combinations"></a> LeetCode Q 77 - Combinations</h1><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><code>Input: n = 4, k = 2</code><br>Output:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || k.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() &gt; k) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, k, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-77-combinations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-77-combinations&quot;&gt;&lt;/a&gt; LeetCode Q 77 - Combinations&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: n = 4, k = 2&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2,4],&lt;br&gt;
[3,4],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[1,3],&lt;br&gt;
[1,4],&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ40/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ40/</id>
    <published>2019-04-28T21:09:18.000Z</published>
    <updated>2019-04-28T21:14:42.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum-ii"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum-ii"></a> LeetCode Q 39 - Combination Sum II</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>Each number in candidates may <strong>only be used once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [10,1,2,7,6,1,5], target = 8,</code><br>A solution set is:<br>[<br>[1, 7],<br>[1, 2, 5],<br>[2, 6],<br>[1, 1, 6]<br>]<br>Example 2:<br><code>Input: candidates = [2,5,2,1,2], target = 5,</code><br>A solution set is:<br>[<br>[1,2,2],<br>[5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (cand == <span class="keyword">null</span> || cand.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(cand, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; cand.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; cand[i] = cand[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum-ii&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum II&lt;/h1&gt;
&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
Each number in candidates may &lt;strong&gt;only be used once&lt;/strong&gt; in the combination.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [10,1,2,7,6,1,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1, 7],&lt;br&gt;
[1, 2, 5],&lt;br&gt;
[2, 6],&lt;br&gt;
[1, 1, 6]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,5,2,1,2], target = 5,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1,2,2],&lt;br&gt;
[5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ39/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ39/</id>
    <published>2019-04-28T21:05:38.000Z</published>
    <updated>2019-04-28T21:09:00.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum"></a> LeetCode Q 39 - Combination Sum</h1><p>Given a <strong>set</strong> of candidate numbers (candidates) <strong>(without duplicates)</strong> and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The <strong>same</strong> repeated number may be chosen from candidates unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [2,3,6,7], target = 7,</code><br>A solution set is:<br>[<br>[7],<br>[2,2,3]<br>]<br>Example 2:<br><code>Input: candidates = [2,3,5], target = 8,</code><br>A solution set is:<br>[<br>[2,2,2,2],<br>[2,3,3],<br>[3,5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (can == <span class="keyword">null</span> || can.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(can, target, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> currSum, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currSum == target) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; can.length; i++) &#123;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum&lt;/h1&gt;
&lt;p&gt;Given a &lt;strong&gt;set&lt;/strong&gt; of candidate numbers (candidates) &lt;strong&gt;(without duplicates)&lt;/strong&gt; and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
The &lt;strong&gt;same&lt;/strong&gt; repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,6,7], target = 7,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[7],&lt;br&gt;
[2,2,3]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[2,2,2,2],&lt;br&gt;
[2,3,3],&lt;br&gt;
[3,5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Letter Combinations of a Phone Number</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ17/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ17/</id>
    <published>2019-04-28T21:01:18.000Z</published>
    <updated>2019-04-28T21:08:14.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-17-letter-combinations-of-a-phone-number"><a class="markdownIt-Anchor" href="#leetcode-q-17-letter-combinations-of-a-phone-number"></a> LeetCode Q 17 - Letter Combinations of a Phone Number</h1><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>Example:<br><code>Input: &quot;23&quot; ;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></p><p><strong>Note:</strong> Although the above answer is in lexicographical order, your answer could be in any order you want.</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] KEYS = &#123; <span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(digits, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// corner cases</span></span><br><span class="line"><span class="keyword">if</span> (pos == digits.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String letters = KEYS[digits.charAt(pos) - <span class="string">'0'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> letter: letters.toCharArray())</span><br><span class="line">backtrack(digits, pos + <span class="number">1</span>, curr + letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;/a&gt; LeetCode Q 17 - Letter Combinations of a Phone Number&lt;/h1&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;23&amp;quot; ;Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
</feed>
