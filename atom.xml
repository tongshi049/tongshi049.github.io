<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-25T23:28:07.182Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maximal Square</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ221/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ221/</id>
    <published>2019-04-25T23:14:44.000Z</published>
    <updated>2019-04-25T23:28:07.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-221-maximal-square"><a class="markdownIt-Anchor" href="#leetcode-q-221-maximal-square"></a> LeetCode Q 221 -  Maximal Square</h1><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:<br>Input:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>Output: 4</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong> <code>dp(i,j)</code> represents the side length of the maximum square whose bottom right corner is the cell with index <code>(i,j)</code> in the original matrix.</p></li><li><p><strong>state transfer fuction:</strong><br>Starting from index (0,0), for every <em><strong>1</strong></em> found in the original matrix, we update the value of the current element as<br><code>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1)) + 1</code>.</p></li></ol><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.min(Math.min(dp[i][j], dp[i+<span class="number">1</span>][j]), dp[i][j+<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen * maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-221-maximal-square&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-221-maximal-square&quot;&gt;&lt;/a&gt; LeetCode Q 221 -  Maximal Square&lt;/h1&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Input:&lt;br&gt;
1 0 1 0 0&lt;br&gt;
1 0 1 1 1&lt;br&gt;
1 1 1 1 1&lt;br&gt;
1 0 0 1 0&lt;br&gt;
Output: 4&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Minimum ASCII Delete Sum for Two Strings</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ712/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ712/</id>
    <published>2019-04-25T22:58:26.000Z</published>
    <updated>2019-04-25T23:14:29.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-712-minimum-ascii-delete-sum-for-two-strings"><a class="markdownIt-Anchor" href="#leetcode-q-712-minimum-ascii-delete-sum-for-two-strings"></a> LeetCode Q 712 -  Minimum ASCII Delete Sum for Two Strings</h1><p>Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.</p><p>Example 1:<br><code>Input: s1 = &quot;sea&quot;, s2 = &quot;eat&quot; ; Output: 231</code><br>Explanation: Deleting “s” from “sea” adds the ASCII value of “s” (115) to the sum. Deleting “t” from “eat” adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.<br>Example 2:<br><code>Input: s1 = &quot;delete&quot;, s2 = &quot;leet&quot; ; Output: 403</code><br>Explanation: Deleting “dee” from “delete” to turn the string into “let”, adds 100[d]+101[e]+101[e] to the sum.  Deleting “e” from “leet” adds 101[e] to the sum. At the end, both strings are equal to “let”, and the answer is 100+101+101+101 = 403. If instead we turned both strings into “lee” or “eet”, we would get answers of 433 or 417, which are higher.</p><p><strong>Note:</strong></p><ul><li>0 &lt; s1.length, s2.length &lt;= 1000.</li><li>All elements of each string will have an ASCII value in [97, 122].</li></ul><p>Similar Question: <a href="/2019/04/25/leetcodeQ712/" title="Minimum ASCII Delete Sum for Two Strings">Minimum ASCII Delete Sum for Two Strings</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>Different with <a href="/2019/04/25/leetcodeQ712/" title="Minimum ASCII Delete Sum for Two Strings">Minimum ASCII Delete Sum for Two Strings</a>, to solve this question we find the <strong>maximum ASCII for common substrings</strong>, and <strong>delete it from the sum of ASCII value of two strings.</strong></p><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) </span><br><span class="line">sum += (<span class="keyword">int</span>)s1.charAt(i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) </span><br><span class="line">sum += (<span class="keyword">int</span>)s2.charAt(j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j))</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j] + (<span class="keyword">int</span>)s1.charAt(i), Math.max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum - <span class="number">2</span> * dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-712-minimum-ascii-delete-sum-for-two-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-712-minimum-ascii-delete-sum-for-two-strings&quot;&gt;&lt;/a&gt; LeetCode Q 712 -  Minimum ASCII Delete Sum for Two Strings&lt;/h1&gt;
&lt;p&gt;Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot; ; Output: 231&lt;/code&gt;&lt;br&gt;
Explanation: Deleting “s” from “sea” adds the ASCII value of “s” (115) to the sum. Deleting “t” from “eat” adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot; ; Output: 403&lt;/code&gt;&lt;br&gt;
Explanation: Deleting “dee” from “delete” to turn the string into “let”, adds 100[d]+101[e]+101[e] to the sum.  Deleting “e” from “leet” adds 101[e] to the sum. At the end, both strings are equal to “let”, and the answer is 100+101+101+101 = 403. If instead we turned both strings into “lee” or “eet”, we would get answers of 433 or 417, which are higher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt; s1.length, s2.length &amp;lt;= 1000.&lt;/li&gt;
&lt;li&gt;All elements of each string will have an ASCII value in [97, 122].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/25/leetcodeQ712/&quot; title=&quot;Minimum ASCII Delete Sum for Two Strings&quot;&gt;Minimum ASCII Delete Sum for Two Strings&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Delete Operation for Two Strings</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ583/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ583/</id>
    <published>2019-04-25T22:46:55.000Z</published>
    <updated>2019-04-25T22:57:42.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-583-delete-operation-for-two-strings"><a class="markdownIt-Anchor" href="#leetcode-q-583-delete-operation-for-two-strings"></a> LeetCode Q 583 -  Delete Operation for Two Strings</h1><p>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</p><p>Example 1: <code>Input: &quot;sea&quot;, &quot;eat&quot; ; Output: 2</code><br>Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.<br><strong>Note:</strong></p><ul><li>The length of given words won’t exceed 500.</li><li>Characters in given words can only be lower-case letters.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><strong>State:</strong> <code>dp[i][j]</code> denotes the minimum number of steps to make <code>word1.substring(0, i+1)</code> and <code>word2.substring(0, j+1)</code> the same;</li><li><strong>state transfer function:</strong><ul><li><code>if (word1.charAt(i) == word2.charAt(j))</code>, we don’t need to do anying therefore<br><code>dp[i][j] = dp[i-1][j-1]</code></li><li>else <code>dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + 1</code>, that is we can either delete char <em><strong>i</strong></em> from <strong>word1</strong> or char <em><strong>j</strong></em> from <strong>word2</strong>.</li></ul></li><li><strong>boundary case:</strong><br><code>dp[0][j] = j, j = 0, 1, 2,... dp[i][0] = i, i = 0, 1, 2,...</code><br>Previously, I only set dp[0][1] = dp[1][0] = 1, so I made mistake!</li></ol><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word1.length() == <span class="number">0</span>) <span class="keyword">return</span> word2.length();</span><br><span class="line"><span class="keyword">if</span> (word2.length() == <span class="number">0</span>) <span class="keyword">return</span> word1.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length(); i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.length(); j++) </span><br><span class="line">dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.length(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) </span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-583-delete-operation-for-two-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-583-delete-operation-for-two-strings&quot;&gt;&lt;/a&gt; LeetCode Q 583 -  Delete Operation for Two Strings&lt;/h1&gt;
&lt;p&gt;Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.&lt;/p&gt;
&lt;p&gt;Example 1: &lt;code&gt;Input: &amp;quot;sea&amp;quot;, &amp;quot;eat&amp;quot; ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of given words won’t exceed 500.&lt;/li&gt;
&lt;li&gt;Characters in given words can only be lower-case letters.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Number of Longest Increasing Subsequence</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ673/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ673/</id>
    <published>2019-04-25T22:23:11.000Z</published>
    <updated>2019-04-25T22:48:08.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-673-number-of-longest-increasing-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-673-number-of-longest-increasing-subsequence"></a> LeetCode Q 673 -  Number of Longest Increasing Subsequence</h1><p>Given an unsorted array of integers, find the number of longest increasing subsequence.</p><p>Example 1:<br><code>Input: [1,3,5,4,7] ; Output: 2</code><br>Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].<br>Example 2:<br><code>Input: [2,2,2,2,2] ; Output: 5</code><br>Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences’ length is 1, so output 5.<br><strong>Note:</strong> Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.</p><p>Similar Question: <a href="/2019/04/15/leetcodeQ300/" title="Longest Increasing Subsequence">Longest Increasing Subsequence</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong></p><ul><li><code>len[i]</code>, record the longest increasing subsequence till <em><strong>ith</strong></em> num in <strong>nums</strong>. The length of <strong>len</strong> should be the <em><strong>nums.length</strong></em>.</li><li><code>count[i]</code>, the number of the string whose length is i. The length of <strong>len</strong> should be the <em><strong>nums.length</strong></em>.</li></ul></li><li><p><strong>state transfer fuction:</strong><br><code>len[i] = Math.max(len[j] + 1, len[i])</code>, where j = 1,…,i-1 and nums[i] &gt; nums[j].<br><strong>Note then when building array len, we should also update the array count.</strong></p><ul><li><code>if (len[i] &lt; len[j] + 1)</code> then <code>count[i] = count[j];</code></li><li><code>if (len[i] == len[j] + 1)</code> then <code>count[i] += count[j];</code></li></ul></li><li><p><strong>boundary cases:</strong> <code>dp[i] = count[i] = 1</code></p></li></ol><p><strong>Time Complexity: O(n^2)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">len[i] = count[i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// update len[i] and count[i] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (len[i] == len[j] + <span class="number">1</span>) &#123;</span><br><span class="line">count[i] += count[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len[i] &lt; len[j] + <span class="number">1</span>) &#123;</span><br><span class="line">len[i] = len[j] + <span class="number">1</span>;</span><br><span class="line">count[i] = count[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update maxLen</span></span><br><span class="line"><span class="keyword">if</span> (maxLen == len[i]) &#123;</span><br><span class="line">res += count[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxLen &lt; len[i]) &#123;</span><br><span class="line">maxLen = len[i];</span><br><span class="line">res = count[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-673-number-of-longest-increasing-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-673-number-of-longest-increasing-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 673 -  Number of Longest Increasing Subsequence&lt;/h1&gt;
&lt;p&gt;Given an unsorted array of integers, find the number of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1,3,5,4,7] ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [2,2,2,2,2] ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences’ length is 1, so output 5.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/15/leetcodeQ300/&quot; title=&quot;Longest Increasing Subsequence&quot;&gt;Longest Increasing Subsequence&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Word Break II</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ140/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ140/</id>
    <published>2019-04-25T22:08:57.000Z</published>
    <updated>2019-04-25T22:26:28.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-140-word-break-ii"><a class="markdownIt-Anchor" href="#leetcode-q-140-word-break-ii"></a> LeetCode Q 140 - Word Break II</h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:<br><code>Input: s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;] Output: [ &quot;cats and dog&quot;, &quot;cat sand dog&quot; ]</code><br>Example 2:<br><code>Input: s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;] Output: [ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot; ]</code><br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:<br><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] Output: []</code></p><a id="more"></a><h2 id="solution-backtracking-with-memorization"><a class="markdownIt-Anchor" href="#solution-backtracking-with-memorization"></a> Solution : Backtracking with memorization</h2><p><strong><font color="#ff0066">Using DFS directly will lead to TLE, so just use HashMap to save the previous results to prune duplicated branches.</font></strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, ArrayList&lt;String&gt;&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">memo = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">return</span> wordBreakHelper(s, wordDict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Strig&gt; <span class="title">wordBreakHelper</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (memo.containsKey(s)) <span class="keyword">return</span> memo.get(s);</span><br><span class="line"></span><br><span class="line">List&lt;Strig&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">if</span> (wordDict.contains(s)) res.add(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; s.length; i++) &#123;</span><br><span class="line">String word = s.substring(<span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">if</span> (!wordDict.contains(word)) <span class="keyword">continue</span>;</span><br><span class="line">List&lt;String&gt; strs = wordBreak(s.substring(len), wordDict);</span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line">res.add(word + <span class="string">" "</span> + str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memo.put(s, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-140-word-break-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-140-word-break-ii&quot;&gt;&lt;/a&gt; LeetCode Q 140 - Word Break II&lt;/h1&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The same word in the dictionary may be reused multiple times in the segmentation.&lt;/li&gt;
&lt;li&gt;You may assume the dictionary does not contain duplicate words.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;, &amp;quot;cats&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;dog&amp;quot;] Output: [ &amp;quot;cats and dog&amp;quot;, &amp;quot;cat sand dog&amp;quot; ]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;pineapplepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;, &amp;quot;applepen&amp;quot;, &amp;quot;pine&amp;quot;, &amp;quot;pineapple&amp;quot;] Output: [ &amp;quot;pine apple pen apple&amp;quot;, &amp;quot;pineapple pen apple&amp;quot;, &amp;quot;pine applepen apple&amp;quot; ]&lt;/code&gt;&lt;br&gt;
Explanation: Note that you are allowed to reuse a dictionary word.&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;] Output: []&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Memorization" scheme="http://yoursite.com/tags/Memorization/"/>
    
  </entry>
  
  <entry>
    <title>Word Break</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ139/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ139/</id>
    <published>2019-04-25T21:49:53.000Z</published>
    <updated>2019-04-25T22:25:46.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-139-word-break"><a class="markdownIt-Anchor" href="#leetcode-q-139-word-break"></a> LeetCode Q 139 - Word Break</h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:<br><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] ; Output: true</code><br>Explanation: Return true because “leetcode” can be segmented as “leet code”.<br>Example 2:<br><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]; Output: true</code><br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”. <strong>Note that you are allowed to reuse a dictionary word.</strong><br>Example 3:<br><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] ; Output: false</code></p><a id="more"></a><h2 id="solution-dp-bottom-up"><a class="markdownIt-Anchor" href="#solution-dp-bottom-up"></a> Solution : DP bottom-up</h2><ol><li><p><strong>State:</strong> <code>boolean dp[i]</code> represents if <code>s.substring(0, i+1)</code> is valid.</p></li><li><p><strong>state transfer fuction:</strong><br>For String  <code>s.substring(0, i+1)</code>, we divide it into two parts, one is <code>s.substring(0, j)</code> and another is <code>s.substring(j, i+1)</code> if they are all valid then <code>s.substring(0, i+1)</code> is valid.<br>Therefore,<br><code>dp[i] = dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+1));</code></p></li></ol><p><strong>Caution:</strong> when we find one valid partition of <code>s.substring(0, i+1)</code>, we need to <strong>break</strong> the <em><strong>for</strong></em> loop.</p><ol start="3"><li><strong>boundary cases:</strong> <code>dp[0] = true</code>.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>))) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>] = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-139-word-break&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-139-word-break&quot;&gt;&lt;/a&gt; LeetCode Q 139 - Word Break&lt;/h1&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The same word in the dictionary may be reused multiple times in the segmentation.&lt;/li&gt;
&lt;li&gt;You may assume the dictionary does not contain duplicate words.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: Return true because “leetcode” can be segmented as “leet code”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;applepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;]; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”. &lt;strong&gt;Note that you are allowed to reuse a dictionary word.&lt;/strong&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;] ; Output: false&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Swaps To Make Sequences Increasing</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ801/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ801/</id>
    <published>2019-04-25T21:07:17.000Z</published>
    <updated>2019-04-25T22:30:20.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-801-minimum-swaps-to-make-sequences-increasing"><a class="markdownIt-Anchor" href="#leetcode-q-801-minimum-swaps-to-make-sequences-increasing"></a> LeetCode Q 801 -  Minimum Swaps To Make Sequences Increasing</h1><p>We have two integer sequences A and B of the same non-zero length.<br>We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.<br>At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] &lt; A[1] &lt; A[2] &lt; … &lt; A[A.length - 1].)<br>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p><p>Example:<br><code>Input: A = [1,3,5,4], B = [1,2,3,7] ; Output: 1</code><br>Explanation: Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.</p><p><strong>Note:</strong></p><ul><li>A, B are arrays with the same length, and that length will be in the range [1, 1000].</li><li>A[i], B[i] are integer values in the range [0, 2000].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong> <code>dp[i][j]</code> denotes the minimum steps we need to make <code>A.substring(i - 1)</code> is the same as <code>B.substring(i - 1)</code> and j represents the operation type. To let those two strings equal, we have two choices, one is swap <em><strong>ith</strong></em> char in <em><strong>A</strong></em> and <em><strong>B</strong></em>, or do nothing.</p><ul><li><code>dp[i][0]</code>: we don’t swap <em><strong>ith</strong></em> char in <em><strong>A</strong></em> and <em><strong>B</strong></em>.</li><li><code>dp[i][1]</code>: we swap them.</li></ul></li><li><p><strong>state transfer fuction:</strong><br>Since this question is guaranteed to have the answer, therefore at least one of the following two conditions exists:</p><ol><li>A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]</li><li>A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]</li></ol></li></ol><ul><li>if <strong>condition 1</strong> exists,<ul><li>if we don’t need to swap chars, then<br><code>dp[i][0] = min(dp[i-1][0], dp[i][0])</code></li><li>if we still swap chars, we also need to swap <em><strong>(i-1)th</strong></em> char in A and B, then<br><code>dp[i][1] = min(dp[i-1][1] + 1, dp[i][1])</code></li></ul></li><li>if <strong>condition 2</strong> exists,<ul><li>if we don’t need to swap chars, then we need to swap <em><strong>(i-1)th</strong></em> char in A and B, which means we can only get to <code>dp[i][0]</code> from <code>dp[i-1][1]</code>, therefore<br><code>dp[i][0] = min(dp[i-1][1], dp[i][0]))</code></li><li>if we still swap chars, we don’t need to swap <em><strong>(i-1)th</strong></em> char in A and B, then<br><code>dp[i][1] = min(dp[i-1][0] + 1, dp[i][1])</code></li></ul></li></ul><ol start="3"><li><p><strong>boundary cases:</strong><br><code>dp[0][0] = 0, dp[0][1] = 1</code>, other numbers in <em><strong>dp</strong></em> are all initialized as <strong>INF</strong>.</p></li><li><p><strong>Optimization:</strong><br>Since <code>dp[i]</code> is only depends on <code>dp[i-1]</code>, we can use sliding array to optimize space complexity to O(1).</p></li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(2n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length != A.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; A[i-<span class="number">1</span>] &amp;&amp; B[i] &gt; B[i-<span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>, dp[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; B[i-<span class="number">1</span>] &amp;&amp; B[i] &gt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, dp[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(dp[len-<span class="number">1</span>][<span class="number">0</span>], dp[len-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-801-minimum-swaps-to-make-sequences-increasing&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-801-minimum-swaps-to-make-sequences-increasing&quot;&gt;&lt;/a&gt; LeetCode Q 801 -  Minimum Swaps To Make Sequences Increasing&lt;/h1&gt;
&lt;p&gt;We have two integer sequences A and B of the same non-zero length.&lt;br&gt;
We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.&lt;br&gt;
At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] &amp;lt; A[1] &amp;lt; A[2] &amp;lt; … &amp;lt; A[A.length - 1].)&lt;br&gt;
Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: A = [1,3,5,4], B = [1,2,3,7] ; Output: 1&lt;/code&gt;&lt;br&gt;
Explanation: Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A, B are arrays with the same length, and that length will be in the range [1, 1000].&lt;/li&gt;
&lt;li&gt;A[i], B[i] are integer values in the range [0, 2000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Domino and Tromino Tiling</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ790/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ790/</id>
    <published>2019-04-25T20:46:51.000Z</published>
    <updated>2019-04-25T22:25:29.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-790-domino-and-tromino-tiling"><a class="markdownIt-Anchor" href="#leetcode-q-790-domino-and-tromino-tiling"></a> LeetCode Q 790 -  Domino and Tromino Tiling</h1><p>We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.<br><code>XX &lt;- domino XX &lt;- &quot;L&quot; tromino X</code><br>Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7.</strong></p><p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p><p>Example:<br><code>Input: 3 ; Output: 5</code><br>Explanation:<br>The five different ways are listed below, different letters indicates different tiles:<br><code>XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY</code><br><strong>Note:</strong> N  will be in range [1, 1000].</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><ol><li><p><strong>State:</strong> <code>f[i][j]</code>, i: until which col the floor is all covered; j: the tail states.</p><ul><li><code>f[i][0]</code>: there is no redundant tail at ith col. (1st row: i, 2nd row: i)</li><li><code>f[i][1]</code>: there is one more tail at 1st row. (1st row: i + 1, 2nd row: i)</li><li><code>f[i][2]</code>: there is one more tail at 1st row. (1st row: i, 2nd row: i + 1)</li></ul></li><li><p><strong>state transfer fuction:</strong></p><ul><li><code>f[i][0] = f[i-1][0] + f[i - 2][0] + f[i-2][1] + f[i-2][2];</code><br>Put one type I vertically, or put two I types horizontally, or put L type (two directions)</li><li><code>f[i][1] = f[i-1][0] + f[i-1][2];</code><br>Put a type I across the top row, or put an L-shape</li><li><code>f[i][2] = f[i-1][0] + f[i-1][1];</code><br>Place a type I across the next line, or put an L type</li></ul></li><li><p><strong>boundary cases:</strong><br><code>f[0][0] = f[1][0] = f[1][1] = f[1][2] = 1</code></p></li></ol><p><strong>Caution:</strong> use <em><strong>long</strong></em> to avoid <strong>integer overflow</strong></p><ol start="4"><li><strong>Optimization:</strong><br>Since <code>f[i]</code> is only depends on <code>f[i-1]</code> and <code>f[i-2]</code>, we can use sliding array to optimize space complexity to O(1).</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(3n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000000007</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">2</span>) <span class="keyword">return</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[][] f = <span class="keyword">new</span> <span class="keyword">long</span>[N+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">1</span>] = f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">2</span>][<span class="number">0</span>] + f[i-<span class="number">2</span>][<span class="number">1</span>] + f[i-<span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">f[i][<span class="number">1</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">1</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">f[i][<span class="number">2</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)f[N][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-790-domino-and-tromino-tiling&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-790-domino-and-tromino-tiling&quot;&gt;&lt;/a&gt; LeetCode Q 790 -  Domino and Tromino Tiling&lt;/h1&gt;
&lt;p&gt;We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.&lt;br&gt;
&lt;code&gt;XX &amp;lt;- domino XX &amp;lt;- &amp;quot;L&amp;quot; tromino X&lt;/code&gt;&lt;br&gt;
Given N, how many ways are there to tile a 2 x N board? &lt;strong&gt;Return your answer modulo 10^9 + 7.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 3 ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The five different ways are listed below, different letters indicates different tiles:&lt;br&gt;
&lt;code&gt;XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; N  will be in range [1, 1000].&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Delete and Earn</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ740/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ740/</id>
    <published>2019-04-25T19:15:34.000Z</published>
    <updated>2019-04-25T22:26:58.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-740-delete-and-earn"><a class="markdownIt-Anchor" href="#leetcode-q-740-delete-and-earn"></a> LeetCode Q 740 -  Delete and Earn</h1><p>Given an array nums of integers, you can perform operations on the array.<br>In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.<br>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p>Example 1:<br><code>Input: nums = [3, 4, 2] ; Output: 6</code><br>Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.</p><p>Example 2:<br><code>Input: nums = [2, 2, 3, 3, 3, 4] ; Output: 9</code><br>Explanation: Delete 3 to earn 3 points, deleting both 2’s and the 4.<br>Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.<br>9 total points are earned.</p><p><strong>Note:</strong></p><ul><li>The length of nums is at most 20000.</li><li>Each element nums[i] is an integer in the range [1, 10000].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><p>First, We use an array <code>int[] count</code> store the times of each element appeared in <em><strong>nums</strong></em>. Since <em><strong>nums[i]</strong></em> is in the range [1, 10000]. We can initialize <code>int[] count = new int[10001]</code>.</p><p>Then, traverse <em><strong>nums</strong></em> and build <em><strong>count</strong></em>.</p><p>Next, use DP algorithm to find the answer.</p><ol><li><strong>State:</strong> <code>dp[i]</code>, the best score we can get till <em><strong>i</strong></em>.</li><li><strong>State Transfer Function:</strong><br><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * counter[i]);</code><br>We have two options:</li></ol><ul><li>We pick <em><strong>i</strong></em>. Since we must <strong>delete</strong> <em><strong>i-1</strong></em> and <em><strong>i+1</strong></em>, that is we can only reach <em><strong>i</strong></em> from <em><strong>i-2</strong></em>.</li><li>We don’t pick <em><strong>i</strong></em>. We pick <em><strong>i - 1</strong></em>.</li></ul><p>We choose one from these two options, which has higher value.</p><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) count[num]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">dp[<span class="number">1</span>] = count[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10001</span>; i++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + i * counter[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">10000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-740-delete-and-earn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-740-delete-and-earn&quot;&gt;&lt;/a&gt; LeetCode Q 740 -  Delete and Earn&lt;/h1&gt;
&lt;p&gt;Given an array nums of integers, you can perform operations on the array.&lt;br&gt;
In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.&lt;br&gt;
You start with 0 points. Return the maximum number of points you can earn by applying such operations.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [3, 4, 2] ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [2, 2, 3, 3, 3, 4] ; Output: 9&lt;/code&gt;&lt;br&gt;
Explanation: Delete 3 to earn 3 points, deleting both 2’s and the 4.&lt;br&gt;
Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.&lt;br&gt;
9 total points are earned.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of nums is at most 20000.&lt;/li&gt;
&lt;li&gt;Each element nums[i] is an integer in the range [1, 10000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum IV</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ377/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ377/</id>
    <published>2019-04-24T22:58:09.000Z</published>
    <updated>2019-04-25T22:27:05.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-377-combination-sum-iv"><a class="markdownIt-Anchor" href="#leetcode-q-377-combination-sum-iv"></a> LeetCode Q 377 - Combination Sum IV</h1><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><p>Example:<br><code>nums = [1, 2, 3] ; target = 4</code><br>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)<br><strong>Note</strong> that different sequences are counted as different combinations.<br>Therefore the output is 7.</p><p><strong>Follow up:</strong></p><ul><li>What if negative numbers are allowed in the given array?</li><li>How does it change the problem?</li><li>What limitation we need to add to the question to allow negative numbers?</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><p><strong>State Transfer Function:</strong><br><code>dp[i] += dp[i - num], where num belongs to nums.</code></p><p><strong>Time Complexity: O(n * t)</strong><br><strong>Space Complexity: O(t)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= num) dp[i] += dp[i - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-recursion-hashmap"><a class="markdownIt-Anchor" href="#solution-2-recursion-hashmap"></a> Solution 2: Recursion + HashMap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || target &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( target == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target)) <span class="keyword">return</span> map.get(target);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">    count += combinationSum4(nums, target - num);</span><br><span class="line">map.put(target, count);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="follow-up"><a class="markdownIt-Anchor" href="#follow-up"></a> Follow up:</h3><p><strong>In order to allow negative integers, the length of the combination sum needs to be restricted, or the search will not stop. We need to use memory to avoid repeated calculations.</strong></p><p>In order to solve this question, we use backtrack with memory. In <a href="/2019/04/25/leetcodeQ140/" title="Word Breaker II">Word Breaker II</a>, we also use backtrack + memory method.</p><p><strong>Code: Backtrack with memorizing</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum42</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || MaxLen &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">return</span> helper2(nums, <span class="number">0</span>, target, MaxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Map&lt;Integer,Integer&gt;&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len &gt; MaxLen) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (map2.containsKey(target) &amp;&amp; map2.get(target).containsKey(len))</span><br><span class="line"><span class="keyword">return</span> map2.get(target).get(len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( target == <span class="number">0</span> )   count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">count+= helper2(nums, len+<span class="number">1</span>, target-num, MaxLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!map2.containsKey(target)) </span><br><span class="line">map2.put(target, <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;());</span><br><span class="line">Map&lt;Integer,Integer&gt; memo = map2.get(target);</span><br><span class="line"></span><br><span class="line">memo.put(len, count);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-377-combination-sum-iv&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-377-combination-sum-iv&quot;&gt;&lt;/a&gt; LeetCode Q 377 - Combination Sum IV&lt;/h1&gt;
&lt;p&gt;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;nums = [1, 2, 3] ; target = 4&lt;/code&gt;&lt;br&gt;
The possible combination ways are:&lt;br&gt;
(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt; that different sequences are counted as different combinations.&lt;br&gt;
Therefore the output is 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if negative numbers are allowed in the given array?&lt;/li&gt;
&lt;li&gt;How does it change the problem?&lt;/li&gt;
&lt;li&gt;What limitation we need to add to the question to allow negative numbers?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Recurtion" scheme="http://yoursite.com/tags/Recurtion/"/>
    
  </entry>
  
  <entry>
    <title>Wiggle Subsequence</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ376/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ376/</id>
    <published>2019-04-24T22:38:24.000Z</published>
    <updated>2019-04-25T22:27:23.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-376-wiggle-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-376-wiggle-subsequence"></a> LeetCode Q 376 - Wiggle Subsequence</h1><p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.<br>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.<br>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Example 1:<br><code>Input: [1,7,4,9,2,5] ; Output: 6</code><br>Explanation: The entire sequence is a wiggle sequence.<br>Example 2:<br><code>Input: [1,17,5,10,13,15,10,5,16,8] ; Output: 7</code><br>Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].<br>Example 3:<br><code>Input: [1,2,3,4,5,6,7,8,9] ; Output: 2</code></p><p><strong>Follow up:</strong> Can you do it in <strong>O(n)</strong> time?</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-traditional-dp"><a class="markdownIt-Anchor" href="#solution-1-traditional-dp"></a> Solution 1 : traditional DP</h3><p>We use two arrays to store the states.</p><ol><li><code>up[i]</code>: the <em><strong>ith</strong></em> number is the <strong>peak</strong>.</li><li><code>sell[i]</code>: the <em><strong>ith</strong></em> number is the <strong>vally</strong>.</li></ol><p>We update these two arrays depends on the following case:</p><ol><li><code>if (nums[i] &gt; nums[i - 1])</code>, which means the curr number is larger than its left, then we update <code>up[i] = Math.max(up[i - 1], down[i - 1] + 1)</code> and <code>down[i] keeps the same</code> (i.e. <code>down[i] = down[i - 1]</code>);</li><li><code>if (nums[i] &lt; nums[i - 1])</code>, which means the curr number is smaller than its left, then we update <code>down[i] = Math.max(down[i - 1], up[i - 1] + 1)</code> and <code>up[i] keeps the same</code> (i.e. <code>up[i] = up[i - 1]</code>);</li><li><code>if (nums[i] == nums[i - 1])</code>, we will neither update <code>up[i]</code> nor <code>sell[i]</code>, that is <code>up[i] = up[i - 1]</code> and <code>down[i] = down[i - 1]</code>.</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">up[<span class="number">0</span>] = <span class="number">1</span>; down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">down[i] = Math.max(down[i - <span class="number">1</span>], up[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(up[nums.length - <span class="number">1</span>], down[nums.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-optimized-space"><a class="markdownIt-Anchor" href="#solution-2-dp-optimized-space"></a> Solution 2 : DP Optimized Space</h3><p>Using <em><strong>up</strong></em> and <em><strong>down</strong></em> instead of <code>up[i]</code> and <code>down[i]</code>, optimizing the <strong>space complecity</strong> to be <strong>O(1)</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">up = Math.max(up, down + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">down = Math.max(down, up + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-376-wiggle-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-376-wiggle-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 376 - Wiggle Subsequence&lt;/h1&gt;
&lt;p&gt;A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.&lt;br&gt;
For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.&lt;br&gt;
Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1,7,4,9,2,5] ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: The entire sequence is a wiggle sequence.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1,17,5,10,13,15,10,5,16,8] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,4,5,6,7,8,9] ; Output: 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Can you do it in &lt;strong&gt;O(n)&lt;/strong&gt; time?&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Partition Equal Subset Sum</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ416/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ416/</id>
    <published>2019-04-24T22:19:44.000Z</published>
    <updated>2019-04-25T22:27:30.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-416-partition-equal-subset-sum"><a class="markdownIt-Anchor" href="#leetcode-q-416-partition-equal-subset-sum"></a> LeetCode Q 416 - Partition Equal Subset Sum</h1><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.<br><strong>Note:</strong></p><ul><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ul><p>Example 1:<br><code>Input: [1, 5, 11, 5] ; Output: true</code><br>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:<br><code>Input: [1, 2, 3, 5] ; Output: false</code><br>Explanation: The array cannot be partitioned into equal sum subsets.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><ol><li><p>We calculate the <strong>sum</strong> of the array, if the <strong>sum</strong> cannot divided by two, then directly returning <strong>false</strong>.</p></li><li><p>boolean array <code>dp[]</code> is used to store the sum values of the array. If <code>dp[sum / 2]</code> can be achieved, then we can return <strong>true</strong>.</p></li></ol><p><strong>State Transfer Function</strong><br><code>dp[i] = dp[i] || dp[i - nums[j]];</code> i: sum value;</p><p><strong>Time Complexity: O(kn)</strong><br><strong>Time Complexity: O(kn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= nums[i - <span class="number">1</span>]; j--)</span><br><span class="line">dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[sum / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#ff0066">Wrong Code:</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum / <span class="number">2</span>; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= num) dp[i] = dp[i] || dp[i - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Since each num can only be used once, this code is <font color="#ff0066">wrong!!!</font></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-416-partition-equal-subset-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-416-partition-equal-subset-sum&quot;&gt;&lt;/a&gt; LeetCode Q 416 - Partition Equal Subset Sum&lt;/h1&gt;
&lt;p&gt;Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each of the array element will not exceed 100.&lt;/li&gt;
&lt;li&gt;The array size will not exceed 200.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1, 5, 11, 5] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: The array can be partitioned as [1, 5, 5] and [11].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1, 2, 3, 5] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: The array cannot be partitioned into equal sum subsets.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Target Sum</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ494/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ494/</id>
    <published>2019-04-24T22:03:16.000Z</published>
    <updated>2019-04-25T22:27:36.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-494-target-sum"><a class="markdownIt-Anchor" href="#leetcode-q-494-target-sum"></a> LeetCode Q 494 - Target Sum</h1><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.<br>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p>Example 1:<br><code>Input: nums is [1, 1, 1, 1, 1], S is 3. ; Output: 5</code><br>Explanation:<br><code>-1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3</code><br>There are 5 ways to assign symbols to make the sum of nums be target 3.<br><strong>Note:</strong></p><ul><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.<br>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-1-dfs-backtracking"></a> Solution 1 : DFS / backtracking</h3><p><strong>Time Complexity: O(2^n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">backtrack(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S, <span class="keyword">int</span> index, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (currSum == S) res++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explore</span></span><br><span class="line">backtrack(nums, S, index + <span class="number">1</span>, currSum + nums[index]);</span><br><span class="line">backtrack(nums, S, index + <span class="number">1</span>, currSum - nums[index]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp"><a class="markdownIt-Anchor" href="#solution-2-dp"></a> Solution 2 : DP</h3><p><code>dp[i][j]</code> refers to the number of assignments which can lead to a sum of j upto the ith index.</p><p><strong>State Transfer Function</strong><br><code>dp[i][sum+nums[i]] = dp[i][sum+nums[i]]+dp[i-1][sum] dp[i][sum-nums[i]] = dp[i][sum-nums[i]]+dp[i-1][sum]</code></p><p><strong>Note:</strong> we add an offset sum to the second index to avoid negative index value.</p><p><strong>Time Complexity: O(kn)</strong><br><strong>Time Complexity: O(kn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][sum + nums[i]] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">0</span>][sum - nums[i]] += <span class="number">1</span>; <span class="comment">// += not = !</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * sum + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums[i];</span><br><span class="line">dp[i][j + n] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">dp[i][j - n] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][sum + S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-494-target-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-494-target-sum&quot;&gt;&lt;/a&gt; LeetCode Q 494 - Target Sum&lt;/h1&gt;
&lt;p&gt;You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.&lt;br&gt;
Find out how many ways to assign symbols to make sum of integers equal to target S.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums is [1, 1, 1, 1, 1], S is 3. ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;-1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3&lt;/code&gt;&lt;br&gt;
There are 5 ways to assign symbols to make the sum of nums be target 3.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of the given array is positive and will not exceed 20.&lt;/li&gt;
&lt;li&gt;The sum of elements in the given array will not exceed 1000.&lt;br&gt;
Your output answer is guaranteed to be fitted in a 32-bit integer.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="backtracking" scheme="http://yoursite.com/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Palindromic Substrings</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ647/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ647/</id>
    <published>2019-04-24T21:54:37.000Z</published>
    <updated>2019-04-25T22:27:52.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-647-palindromic-substrings"><a class="markdownIt-Anchor" href="#leetcode-q-647-palindromic-substrings"></a> LeetCode Q 647 - Palindromic Substrings</h1><p>Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p>Example 1:<br><code>Input: &quot;abc&quot; ; Output: 3</code><br>Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2:<br><code>Input: &quot;aaa&quot; ; Output: 6</code><br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p><p><strong>Note:</strong> The input string length won’t exceed 1000.</p><a id="more"></a><h2 id="solution-expand-around-center"><a class="markdownIt-Anchor" href="#solution-expand-around-center"></a> Solution : Expand Around Center</h2><p>Similar Question: <a href="/2019/04/22/leetcodeQ5/" title="Longest Palindromic Substring">Longest Palindromic Substring</a></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span>&lt; s.length(); i++) &#123;</span><br><span class="line">expandAroundCerter(s, i, i);</span><br><span class="line">expandAroundCerter(s, i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandAroundCerter</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() </span><br><span class="line">&amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">  start--; end++; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-647-palindromic-substrings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-647-palindromic-substrings&quot;&gt;&lt;/a&gt; LeetCode Q 647 - Palindromic Substrings&lt;/h1&gt;
&lt;p&gt;Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;abc&amp;quot; ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: Three palindromic strings: “a”, “b”, “c”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;aaa&amp;quot; ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The input string length won’t exceed 1000.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock with Transaction Fee</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ714/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ714/</id>
    <published>2019-04-24T21:15:14.000Z</published>
    <updated>2019-04-25T22:28:03.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-714-best-time-to-buy-and-sell-stock-with-transaction-fee"><a class="markdownIt-Anchor" href="#leetcode-q-714-best-time-to-buy-and-sell-stock-with-transaction-fee"></a> LeetCode Q 714 - Best Time to Buy and Sell Stock with Transaction Fee</h1><p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.<br>You may complete <strong>as many transactions as you like</strong>, but you need to <strong>pay the transaction fee for each transaction</strong>. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)<br>Return the <strong>maximum profit</strong> you can make.</p><p>Example 1:<br><code>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 ; Output: 8</code><br>Explanation: The maximum profit can be achieved by:</p><ul><li>Buying at prices[0] = 1</li><li>Selling at prices[3] = 8</li><li>Buying at prices[4] = 4</li><li>Selling at prices[5] = 9<br>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</li></ul><p><strong>Note:</strong></p><ul><li>0 &lt; prices.length &lt;= 50000.</li><li>0 &lt; prices[i] &lt; 50000.</li><li>0 &lt;= fee &lt; 50000.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-traditional-dp"><a class="markdownIt-Anchor" href="#solution-traditional-dp"></a> Solution: traditional DP</h3><p>We use two arrays to store the states.</p><ol><li><code>buy[i]</code>: it represents we end with a <strong>buy</strong> action at day k (k &lt;= i).</li><li><code>sell[i]</code>: it represents we end with a <strong>sell</strong> action at day k (k &lt;= i).</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(2n) -&gt; O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] buy = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"><span class="keyword">int</span>[] sell = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">buy[i] = Math.max(buy[i - <span class="number">1</span>], -prices[i] + sell[i - <span class="number">1</span>]);</span><br><span class="line">sell[i] = Math.max(sell[i - <span class="number">1</span>], prices[i] + buy[i] - fee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sell[prices.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-dp-optimized-space"><a class="markdownIt-Anchor" href="#solution-dp-optimized-space"></a> Solution: DP Optimized Space</h3><p>Since <code>buy[i]</code> and <code>sell[i]</code> only depends on <code>buy[i - 1]</code> and <code>sell[i - 1]</code> respectively, instead of using arrays we can just use to vars to store the states, which optimizing the <strong>space complecity</strong> to be <strong>O(1)</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> buy = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">buy = Math.max(buy, sell - prices[i]);</span><br><span class="line">sell = Math.max(sell, prices[i] + buy - fee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-714-best-time-to-buy-and-sell-stock-with-transaction-fee&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-714-best-time-to-buy-and-sell-stock-with-transaction-fee&quot;&gt;&lt;/a&gt; LeetCode Q 714 - Best Time to Buy and Sell Stock with Transaction Fee&lt;/h1&gt;
&lt;p&gt;Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.&lt;br&gt;
You may complete &lt;strong&gt;as many transactions as you like&lt;/strong&gt;, but you need to &lt;strong&gt;pay the transaction fee for each transaction&lt;/strong&gt;. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)&lt;br&gt;
Return the &lt;strong&gt;maximum profit&lt;/strong&gt; you can make.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: prices = [1, 3, 2, 8, 4, 9], fee = 2 ; Output: 8&lt;/code&gt;&lt;br&gt;
Explanation: The maximum profit can be achieved by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buying at prices[0] = 1&lt;/li&gt;
&lt;li&gt;Selling at prices[3] = 8&lt;/li&gt;
&lt;li&gt;Buying at prices[4] = 4&lt;/li&gt;
&lt;li&gt;Selling at prices[5] = 9&lt;br&gt;
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt; prices.length &amp;lt;= 50000.&lt;/li&gt;
&lt;li&gt;0 &amp;lt; prices[i] &amp;lt; 50000.&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= fee &amp;lt; 50000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Counting Bits</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ338/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ338/</id>
    <published>2019-04-24T20:03:00.000Z</published>
    <updated>2019-04-25T22:28:18.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-338-counting-bits"><a class="markdownIt-Anchor" href="#leetcode-q-338-counting-bits"></a> LeetCode Q 338 - Counting Bits</h1><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p><p>Example 1: <code>Input: 2 ; Output: [0,1,1]</code><br>Example 2: <code>Input: 5 ; Output: [0,1,1,2,1,2]</code></p><p><strong>Follow up:</strong></p><ul><li>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in <strong>linear time O(n)</strong> possibly in a single pass?</li><li>Space complexity should be O(n).</li><li>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>First, we try some examples to find the pattern.<br>`</p><table><thead><tr><th></th><th>binary</th><th>dp</th></tr></thead><tbody><tr><td>1</td><td>0001</td><td>1</td></tr><tr><td>2</td><td>0010</td><td>1</td></tr><tr><td>3</td><td>0011</td><td>2</td></tr><tr><td>4</td><td>0100</td><td>1</td></tr><tr><td>5</td><td>0101</td><td>2</td></tr><tr><td>6</td><td>0110</td><td>2</td></tr><tr><td>7</td><td>0111</td><td>3</td></tr><tr><td>8</td><td>1000</td><td>1</td></tr><tr><td>9</td><td>1001</td><td>2</td></tr><tr><td>10</td><td>1010</td><td>2</td></tr><tr><td>11</td><td>1011</td><td>3</td></tr><tr><td>12</td><td>1100</td><td>2</td></tr></tbody></table><p>We can find</p><ol><li>When the number is power of 2, i.e. (1, 2, 4, 8,…) then there is only <strong>one</strong> <em><strong>1</strong></em> in its binary representation.</li><li>A target can be divided into two numbers. One is <strong>the largeset number</strong> which is the power of <em><strong>2</strong></em> and at the same time <strong>less than target</strong>.<br>For example, 3 = 2 + 1; 10 = 8 + 2; 11 = 8 + 3.<br>The number of <em><strong>1s</strong></em> in this target is the <strong>sum</strong> of the number of <em><strong>1s</strong></em> in these two <strong>sub-numbers</strong>. Since one <strong>sum-number</strong> is power of <em><strong>2</strong></em>, the number of <em><strong>1s</strong></em> in it is <em><strong>1</strong></em>. Then, we can get the <strong>state transfer function as follows</strong><br><code>dp[i] = dp[i - num] + 1</code>, where num is the largeset number which is the power of 2 and at the same time less than target.<br>For example, <code>11 = 3 + 8, dp[11] = dp[3] + 1</code>;</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">int</span> pow = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt;= num; i++, t++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == pow) &#123; <span class="comment">// update that largest power of 2 </span></span><br><span class="line">pow * = <span class="number">2</span>;</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dp[i] = dp[t] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[num];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-338-counting-bits&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-338-counting-bits&quot;&gt;&lt;/a&gt; LeetCode Q 338 - Counting Bits&lt;/h1&gt;
&lt;p&gt;Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.&lt;/p&gt;
&lt;p&gt;Example 1: &lt;code&gt;Input: 2 ; Output: [0,1,1]&lt;/code&gt;&lt;br&gt;
Example 2: &lt;code&gt;Input: 5 ; Output: [0,1,1,2,1,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in &lt;strong&gt;linear time O(n)&lt;/strong&gt; possibly in a single pass?&lt;/li&gt;
&lt;li&gt;Space complexity should be O(n).&lt;/li&gt;
&lt;li&gt;Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Coin Change</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ322/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ322/</id>
    <published>2019-04-24T19:46:44.000Z</published>
    <updated>2019-04-25T22:28:26.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-322-coin-change"><a class="markdownIt-Anchor" href="#leetcode-q-322-coin-change"></a> LeetCode Q 322 - Coin Change</h1><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:<br><code>Input: coins = [1, 2, 5], amount = 11 ; Output: 3</code><br>Explanation: 11 = 5 + 5 + 1<br>Example 2:<br><code>Input: coins = [2], amount = 3 ; Output: -1</code><br><strong>Note:</strong> You may assume that you have an infinite number of each kind of coin.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p><strong>Bottom-up DP Method</strong></p><p><strong>State Transfer Function:</strong><br><code>dp[i] = MIN(dp[i - coin] + 1), when dp[i - coin] has valid value.</code></p><p><strong>Time Complexity: O(kn), k: target sum, n: number of diff coins</strong><br><strong>Space Complexity: O(k)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (coins == <span class="keyword">null</span> || coins.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> coin: coins) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= coin &amp;&amp; dp[i - coin] != Integer.MAX_VALUE)</span><br><span class="line">dp[i] = Math.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-322-coin-change&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-322-coin-change&quot;&gt;&lt;/a&gt; LeetCode Q 322 - Coin Change&lt;/h1&gt;
&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: coins = [1, 2, 5], amount = 11 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: 11 = 5 + 5 + 1&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: coins = [2], amount = 3 ; Output: -1&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; You may assume that you have an infinite number of each kind of coin.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Range Sum Query 2D - Immutable</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ304/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ304/</id>
    <published>2019-04-24T15:04:40.000Z</published>
    <updated>2019-04-25T22:28:36.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-304-range-sum-query-2d-immutable"><a class="markdownIt-Anchor" href="#leetcode-q-304-range-sum-query-2d-immutable"></a> LeetCode Q 304 - Range Sum Query 2D - Immutable</h1><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p><p>Example:<br><code>Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -&gt; 8 sumRegion(1, 1, 2, 2) -&gt; 11 sumRegion(1, 2, 2, 4) -&gt; 12</code><br><strong>Note:</strong></p><ul><li>You may assume that the matrix does not change.</li><li>There are many calls to sumRegion function.</li><li>You may assume that row1 ≤ row2 and col1 ≤ col2.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>This is similar to <a href="/2019/04/24/leetcodeQ303/" title="Range Sum Query - Immutable">Range Sum Query - Immutable</a>. To improve the efficiency, we record the sums in an 2D array. These sum values are<br><code>sum[r][c] = sum[r][c-1]+sum[r-1][c]-sum[r-1][c-1]+matrix[r][c]</code>.</p><p>Then, <strong>sum of rectangle</strong> can be obtained as:<br><code>sum[r2][c2] - sum[r2][c1-1] - sum[r1-1][c2] + sum[r1-1][r2-1]</code>.</p><p><strong>Time Complexity: O(m*n); m, n: number of rows and cols</strong><br><strong>Space Complexity: O(m*n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">sum = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; matrix.length; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; matrix[<span class="number">0</span>].length; c++) &#123;</span><br><span class="line">sum[r+<span class="number">1</span>][c+<span class="number">1</span>] = sum[r+<span class="number">1</span>][c] + sum[r][c+<span class="number">1</span>] - sum[r][c] + matrix[r][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sum[row2+<span class="number">1</span>][col1] - sum[row1][col2+<span class="number">1</span>] + sum[row1][col1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-304-range-sum-query-2d-immutable&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-304-range-sum-query-2d-immutable&quot;&gt;&lt;/a&gt; LeetCode Q 304 - Range Sum Query 2D - Immutable&lt;/h1&gt;
&lt;p&gt;Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -&amp;gt; 8 sumRegion(1, 1, 2, 2) -&amp;gt; 11 sumRegion(1, 2, 2, 4) -&amp;gt; 12&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume that the matrix does not change.&lt;/li&gt;
&lt;li&gt;There are many calls to sumRegion function.&lt;/li&gt;
&lt;li&gt;You may assume that row1 ≤ row2 and col1 ≤ col2.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Range Sum Query - Immutable</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ303/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ303/</id>
    <published>2019-04-24T14:57:39.000Z</published>
    <updated>2019-04-25T22:28:43.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-303-range-sum-query-immutable"><a class="markdownIt-Anchor" href="#leetcode-q-303-range-sum-query-immutable"></a> LeetCode Q 303 - Range Sum Query - Immutable</h1><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><p>Example:<br><code>Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&gt; 1 sumRange(2, 5) -&gt; -1 sumRange(0, 5) -&gt; -3</code><br><strong>Note:</strong></p><ul><li>You may assume that the <strong>array does not change</strong>.</li><li>There are <strong>many calls</strong> to <em>sumRange</em> function.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>Since the array does not change and there are many calls to the <em>sumRange</em> function. Therefore, we consider to preprocess the array, calculating <code>Sum(nums[1], ... nums[i])</code> and storing these values in an array.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++)</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sum[j + <span class="number">1</span>] - sum[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-303-range-sum-query-immutable&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-303-range-sum-query-immutable&quot;&gt;&lt;/a&gt; LeetCode Q 303 - Range Sum Query - Immutable&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume that the &lt;strong&gt;array does not change&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;There are &lt;strong&gt;many calls&lt;/strong&gt; to &lt;em&gt;sumRange&lt;/em&gt; function.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Android Unlock Patterns</title>
    <link href="http://yoursite.com/2019/04/24/lintcodeQ909/"/>
    <id>http://yoursite.com/2019/04/24/lintcodeQ909/</id>
    <published>2019-04-24T14:52:14.000Z</published>
    <updated>2019-04-24T14:56:04.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-909-android-unlock-patterns"><a class="markdownIt-Anchor" href="#lintcode-q-909-android-unlock-patterns"></a> LintCode Q 909 - Android Unlock Patterns</h1><p>Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.<br>Rules for a valid pattern:</p><ul><li>Each pattern must connect at least m keys and at most n keys.</li><li>All the keys must be distinct.</li><li>If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.</li><li>The order of keys used matters.</li></ul><p>Example1<br><code>Input: m = 1, n = 1 ; Output: 9</code><br>Example2<br><code>Input: m = 1, n = 2 ; Output: 65</code></p><a id="more"></a><h2 id="solution-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-dfs-backtracking"></a> Solution : DFS / backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfPatterns</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[][] skip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">skip[<span class="number">1</span>][<span class="number">3</span>] = skip[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">skip[<span class="number">1</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">skip[<span class="number">3</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">3</span>] = <span class="number">6</span>;</span><br><span class="line">skip[<span class="number">7</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">7</span>] = <span class="number">8</span>;</span><br><span class="line">skip[<span class="number">1</span>][<span class="number">9</span>] = skip[<span class="number">9</span>][<span class="number">1</span>] = skip[<span class="number">3</span>][<span class="number">7</span>] = skip[<span class="number">7</span>][<span class="number">3</span>] = skip[<span class="number">2</span>][<span class="number">8</span>] = skip[<span class="number">8</span>][<span class="number">2</span>] = skip[<span class="number">4</span>][<span class="number">6</span>] = skip[<span class="number">6</span>][<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &lt;= n; i++) &#123;</span><br><span class="line">res += DFS(visited, skip, <span class="number">1</span>, i - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">res += DFS(visited, skip, <span class="number">2</span>, i - <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">res += DFS(visited, skip, <span class="number">5</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">boolean</span> visited[], <span class="keyword">int</span>[][] skip, <span class="keyword">int</span> cur, <span class="keyword">int</span> remain)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary cases</span></span><br><span class="line"><span class="keyword">if</span> (remain &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (remain == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//choose</span></span><br><span class="line">visited[cur] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explore</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i] &amp;&amp; (skip[cur][i] == <span class="number">0</span> || visited[skip[cur][i]]))</span><br><span class="line">res += DFS(visited, skip, i, remain - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unchoose</span></span><br><span class="line">visited[cur] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-909-android-unlock-patterns&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-909-android-unlock-patterns&quot;&gt;&lt;/a&gt; LintCode Q 909 - Android Unlock Patterns&lt;/h1&gt;
&lt;p&gt;Given an Android 3x3 key lock screen and two integers m and n, where 1 ≤ m ≤ n ≤ 9, count the total number of unlock patterns of the Android lock screen, which consist of minimum of m keys and maximum n keys.&lt;br&gt;
Rules for a valid pattern:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each pattern must connect at least m keys and at most n keys.&lt;/li&gt;
&lt;li&gt;All the keys must be distinct.&lt;/li&gt;
&lt;li&gt;If the line connecting two consecutive keys in the pattern passes through any other keys, the other keys must have previously selected in the pattern. No jumps through non selected key is allowed.&lt;/li&gt;
&lt;li&gt;The order of keys used matters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example1&lt;br&gt;
&lt;code&gt;Input: m = 1, n = 1 ; Output: 9&lt;/code&gt;&lt;br&gt;
Example2&lt;br&gt;
&lt;code&gt;Input: m = 1, n = 2 ; Output: 65&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="backtracking" scheme="http://yoursite.com/tags/backtracking/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
</feed>
