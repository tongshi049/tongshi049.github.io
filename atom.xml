<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-03T00:45:43.617Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Is Graph Bipartite?</title>
    <link href="http://yoursite.com/2019/05/02/leetcodeQ785/"/>
    <id>http://yoursite.com/2019/05/02/leetcodeQ785/</id>
    <published>2019-05-02T23:39:45.000Z</published>
    <updated>2019-05-03T00:45:43.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-785-is-graph-bipartite"><a class="markdownIt-Anchor" href="#leetcode-q-785-is-graph-bipartite"></a> LeetCode Q 785 - Is Graph Bipartite?</h1><p>Given an undirected graph, return true if and only if it is bipartite.<br>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.<br>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.</p><p>Example 1:<br><code>Input: [[1,3], [0,2], [1,3], [0,2]] ; Output: true</code><br>Explanation:<br>The graph looks like this:<br>0----1<br>|    |<br>|    |<br>3----2<br>We can divide the vertices into two groups: {0, 2} and {1, 3}.</p><p>Example 2:<br><code>Input: [[1,2,3], [0,2], [0,1,3], [0,2]] ; Output: false</code><br>Explanation:<br>The graph looks like this:<br>0----1<br>| \  |<br>|  \ |<br>3----2<br>We cannot find a way to divide the set of nodes into two independent subsets.</p><p><strong>Note:</strong></p><ul><li>graph will have length in range [1, 100].</li><li>graph[i] will contain integers in range [0, graph.length - 1].</li><li>graph[i] will not contain i or duplicate values.</li><li>The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>By <strong>coloring</strong> each node in the graph <strong>black</strong> or <strong>white</strong>, we can check is a graph is <strong>bipartite</strong>.</p><p>Traverse the graph, coloring the <strong>adjenct nodes</strong> to <strong>different colors</strong>. If we can finish the coloring procedure successfully, the graph is <strong>bipartite</strong>, otherwise it isn’t.</p><p>We can do this using DFS or BFS.</p><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><code>int[] colors</code> has three values, 0 : unvisiting, 1 : white, 2: black</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.length;   <span class="comment">// n nodes</span></span><br><span class="line"><span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; graph[i].length != <span class="number">0</span>) &#123;</span><br><span class="line">colors[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[curr]) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[next] == -<span class="number">1</span>) &#123;</span><br><span class="line">que.offer(next); colors[next] = <span class="number">1</span> - colors[curr];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[next] == colors[curr]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.length;   <span class="comment">// n nodes</span></span><br><span class="line"><span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !validColor(graph, colors, <span class="number">0</span>, i))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validColor</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> currColor, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (colors[node] != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> colors[node] == color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[curr]) &#123;</span><br><span class="line"><span class="keyword">if</span> (color[next] != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> color[next] == <span class="number">1</span> - currColor;</span><br><span class="line">color[next] == <span class="number">1</span> - currColor;</span><br><span class="line">dfs(graph, next, <span class="number">1</span> - currColor, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-785-is-graph-bipartite&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-785-is-graph-bipartite&quot;&gt;&lt;/a&gt; LeetCode Q 785 - Is Graph Bipartite?&lt;/h1&gt;
&lt;p&gt;Given an undirected graph, return true if and only if it is bipartite.&lt;br&gt;
Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.&lt;br&gt;
The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[1,3], [0,2], [1,3], [0,2]] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The graph looks like this:&lt;br&gt;
0----1&lt;br&gt;
|    |&lt;br&gt;
|    |&lt;br&gt;
3----2&lt;br&gt;
We can divide the vertices into two groups: {0, 2} and {1, 3}.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[1,2,3], [0,2], [0,1,3], [0,2]] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The graph looks like this:&lt;br&gt;
0----1&lt;br&gt;
| \  |&lt;br&gt;
|  \ |&lt;br&gt;
3----2&lt;br&gt;
We cannot find a way to divide the set of nodes into two independent subsets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;graph will have length in range [1, 100].&lt;/li&gt;
&lt;li&gt;graph[i] will contain integers in range [0, graph.length - 1].&lt;/li&gt;
&lt;li&gt;graph[i] will not contain i or duplicate values.&lt;/li&gt;
&lt;li&gt;The graph is undirected: if any element j is in graph[i], then i will be in graph[j].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Clone Graph</title>
    <link href="http://yoursite.com/2019/05/02/leetcodeQ133/"/>
    <id>http://yoursite.com/2019/05/02/leetcodeQ133/</id>
    <published>2019-05-02T23:19:05.000Z</published>
    <updated>2019-05-03T00:21:11.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-892-clone-graph"><a class="markdownIt-Anchor" href="#leetcode-q-892-clone-graph"></a> LeetCode Q 892 - Clone Graph</h1><p>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.</p><p><strong>Note:</strong></p><ul><li>The number of nodes will be between 1 and 100.</li><li>The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.</li><li>Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.</li><li>You must return the copy of the given node as a reference to the cloned graph.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Definition for a Node.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">    val = _val;</span><br><span class="line">    neighbors = _neighbors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(node); set.add(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy nodes</span></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">Node curr = que.poll();</span><br><span class="line">map.put(curr, <span class="keyword">new</span> Node(curr.val, <span class="keyword">new</span> List&lt;Node&gt;()));</span><br><span class="line"><span class="keyword">for</span> (Node nei: curr.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span> (set.contains(nei)) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(nei); set.add(nei);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy edges</span></span><br><span class="line"><span class="keyword">for</span> (Node curr: map.keySet) &#123;</span><br><span class="line"><span class="keyword">for</span> (Node nei: map.get(curr)) &#123;</span><br><span class="line">map.get(curr).neighbors.add(map.get(nei));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(root, <span class="keyword">new</span> Node(root.val, <span class="keyword">new</span> ArrayList&lt;Node&gt;()));</span><br><span class="line"></span><br><span class="line">dfs(map, root);</span><br><span class="line"><span class="keyword">return</span> map.get(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;Node, Node&gt; map, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node nei: node.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(nei)) &#123;</span><br><span class="line">map.put(nei, <span class="keyword">new</span> Node(nei.value, <span class="keyword">new</span> List&lt;Node&gt;()));</span><br><span class="line">dfs(map, nei);</span><br><span class="line">&#125;</span><br><span class="line">map.get(node).neighbors.add(nei);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-892-clone-graph&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-892-clone-graph&quot;&gt;&lt;/a&gt; LeetCode Q 892 - Clone Graph&lt;/h1&gt;
&lt;p&gt;Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes will be between 1 and 100.&lt;/li&gt;
&lt;li&gt;The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.&lt;/li&gt;
&lt;li&gt;Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.&lt;/li&gt;
&lt;li&gt;You must return the copy of the given node as a reference to the cloned graph.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Alien Dictionary</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ892/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ892/</id>
    <published>2019-05-02T22:58:18.000Z</published>
    <updated>2019-05-02T23:18:03.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-892-alien-dictionary"><a class="markdownIt-Anchor" href="#lintcode-q-892-alien-dictionary"></a> LintCode Q 892 - Alien Dictionary</h1><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p><p>Example 1:<br><code>Input：[&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;] ; Output：&quot;wertf&quot;</code><br>Explanation：<br>from “wrt&quot;and&quot;wrf” ,we can get ‘t’&lt;‘f’<br>from “wrt&quot;and&quot;er” ,we can get ‘w’&lt;‘e’<br>from “er&quot;and&quot;ett” ,we can get ‘r’&lt;‘t’<br>from “ett&quot;and&quot;rtff” ,we can get ‘e’&lt;‘r’<br>So return “wertf”</p><p>Example 2:<br><code>Input：[&quot;z&quot;,&quot;x&quot;] ; Output：&quot;zx&quot;</code><br>Explanation：<br>from “z” and “x”，we can get ‘z’ &lt; ‘x’<br>So return “zx”</p><p><strong>Notice:</strong></p><ul><li>You may assume all letters are in lowercase.</li><li>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.</li><li>If the order is invalid, return an empty string.</li><li>There may be multiple valid order of letters, return the smallest in normal lexicographical order</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Set&lt;Character&gt;&gt; graph = buildGraph(words);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> topologySorting(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Character, Set&lt;Character&gt;&gt; buildGraph(String[] words) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) </span><br><span class="line">graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words[i].length; index++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word[i].charAt(index) != word[i + <span class="number">1</span>].charAt(index)) &#123;</span><br><span class="line">graph.get(word[i].charAt(index), word[i + <span class="number">1</span>].charAt(index));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">topologySorting</span><span class="params">(Map&lt;Character, Set&lt;Character&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.size();</span><br><span class="line">Map&lt;Character, Integer&gt; order = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: graph.keySet()) </span><br><span class="line">order.put(ch, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: graph.keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> next: graph.get(ch)) </span><br><span class="line">order.put(next, order.get(next) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Character&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;();  <span class="comment">// not LinkedList</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: order.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (order.get(ch) == <span class="number">0</span>) que.offer(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">char</span> curr = que.poll();</span><br><span class="line">sb.append(curr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> next: graph.get(curr)) &#123;</span><br><span class="line">map.put(next, map.get(next) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (map.get(next) == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb.length() != order.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tip: why using PriorityQueue not just LinkedList</strong><br>Since for test case <code>[&quot;zy&quot;, &quot;zx&quot;]</code>, the correct output should be <code>&quot;yxz&quot;</code>. If using LinkedList, we get <code>&quot;yzx&quot;</code> which is not correct.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-892-alien-dictionary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-892-alien-dictionary&quot;&gt;&lt;/a&gt; LintCode Q 892 - Alien Dictionary&lt;/h1&gt;
&lt;p&gt;There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;] ; Output：&amp;quot;wertf&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
from “wrt&amp;quot;and&amp;quot;wrf” ,we can get ‘t’&amp;lt;‘f’&lt;br&gt;
from “wrt&amp;quot;and&amp;quot;er” ,we can get ‘w’&amp;lt;‘e’&lt;br&gt;
from “er&amp;quot;and&amp;quot;ett” ,we can get ‘r’&amp;lt;‘t’&lt;br&gt;
from “ett&amp;quot;and&amp;quot;rtff” ,we can get ‘e’&amp;lt;‘r’&lt;br&gt;
So return “wertf”&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;] ; Output：&amp;quot;zx&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
from “z” and “x”，we can get ‘z’ &amp;lt; ‘x’&lt;br&gt;
So return “zx”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume all letters are in lowercase.&lt;/li&gt;
&lt;li&gt;You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.&lt;/li&gt;
&lt;li&gt;If the order is invalid, return an empty string.&lt;/li&gt;
&lt;li&gt;There may be multiple valid order of letters, return the smallest in normal lexicographical order&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Topological Sorting</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ127/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ127/</id>
    <published>2019-05-02T22:28:46.000Z</published>
    <updated>2019-05-02T23:24:44.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-127-topological-sorting"><a class="markdownIt-Anchor" href="#lintcode-q-127-topological-sorting"></a> LintCode Q 127 - Topological Sorting</h1><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p><ul><li>For each directed edge A -&gt; B in graph, A must before B in the order list.</li><li>The first node in the order can be any node in the graph with no nodes direct to it.</li><li>Find any topological order for the given graph.</li></ul><p><strong>Challenge:</strong> Can you do it in both BFS and DFS?</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>Definition for Directed graph.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedGraphNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> label;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; neighbors;</span><br><span class="line">DirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Set&lt;DirectedGraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) </span><br><span class="line">dfs(node, visited, res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DirectedGraphNode node, Set&lt;DirectedGraphNode&gt; visited, ArrayList&lt;DirectedGraphNode&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited.add(node);</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: node.neighbors) &#123;</span><br><span class="line">dfs(next, visited, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res.add(<span class="number">0</span>, node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs-topology-sorting"><a class="markdownIt-Anchor" href="#solution-2-bfs-topology-sorting"></a> Solution 2 : BFS / Topology Sorting</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.size();</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) &#123;</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: node.neighbors) &#123;</span><br><span class="line">order[next.label]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;DirectedGraphNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) &#123;</span><br><span class="line"><span class="keyword">if</span> (order[node.label] == <span class="number">0</span>) que.offer(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">DirectedGraphNode curr = que.poll();</span><br><span class="line">res.add(curr);</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: curr.neighbors) &#123;</span><br><span class="line">order[next.label]--;</span><br><span class="line"><span class="keyword">if</span> (order[next.label] == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-127-topological-sorting&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-127-topological-sorting&quot;&gt;&lt;/a&gt; LintCode Q 127 - Topological Sorting&lt;/h1&gt;
&lt;p&gt;Given an directed graph, a topological order of the graph nodes is defined as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each directed edge A -&amp;gt; B in graph, A must before B in the order list.&lt;/li&gt;
&lt;li&gt;The first node in the order can be any node in the graph with no nodes direct to it.&lt;/li&gt;
&lt;li&gt;Find any topological order for the given graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Challenge:&lt;/strong&gt; Can you do it in both BFS and DFS?&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Graph Valid Tree</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ178/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ178/</id>
    <published>2019-05-02T21:26:21.000Z</published>
    <updated>2019-05-02T22:28:11.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-178-graph-valid-tree"><a class="markdownIt-Anchor" href="#lintcode-q-178-graph-valid-tree"></a> LintCode Q 178 - Graph Valid Tree</h1><p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p><p>Example 1:<br><code>Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] ; Output: true.</code></p><p>Example 2:<br><code>Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] ; Output: false.</code></p><p><strong>Notice:</strong> You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong><font color="#06bcf9">An undirected graph is tree if it has following properties.</font></strong></p><ol><li>There is no cycle.</li><li>The graph is connected.</li></ol><p><strong><font color="#06bcf9">How to check if a graph satisfies the above two properties?</font></strong></p><ol><li>If there are <em><strong>N</strong></em> nodes and <em><strong>N-1</strong></em> edges, then the graph has no cycle. That is <code>edges = n - 1</code>.</li><li>There is no island in the graph, <em>if and only if</em> we can visit every node in the graph from any <strong>arbitrary</strong> node in the graph.</li></ol><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (edges.length != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the graph</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">graph.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line">graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(<span class="number">0</span>); visited.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph.get(curr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited.contains(next)) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(next);</span><br><span class="line">visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vistied.size() == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-disjoint-set-union-find-set"><a class="markdownIt-Anchor" href="#solution-2-disjoint-set-union-find-set"></a> Solution 2 : Disjoint Set / Union Find Set</h3><ol><li>Build the union, if I am trying to union an existing edge, then return false;</li><li>Check if there is only one union in the graph.</li></ol><p><strong>Another way:</strong></p><ol><li>Add a count field in the UnionFindSet, denoting the number of different unions.</li><li>check if the <code>count</code> for the given graph equals <code>1</code>.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[size]; rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != parent[x])</span><br><span class="line">parent[x] = Find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = Find(x), py = Find(y);</span><br><span class="line"><span class="keyword">if</span> (rank(px) &gt; rank(py)) parent[py] = px;</span><br><span class="line"><span class="keyword">if</span> (rank(py) &gt; rank(px)) parent[px] = py;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">parent[py] = px;</span><br><span class="line">rank[px]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (edges.length != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(edge[<span class="number">0</span>]) == ufs.find(edge[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(i - <span class="number">1</span>) != ufs.find(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-178-graph-valid-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-178-graph-valid-tree&quot;&gt;&lt;/a&gt; LintCode Q 178 - Graph Valid Tree&lt;/h1&gt;
&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] ; Output: true.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] ; Output: false.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Serialize and Deserialize Binary Tree</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ297/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ297/</id>
    <published>2019-05-01T20:16:30.000Z</published>
    <updated>2019-05-01T20:43:01.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-297-serialize-and-deserialize-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-297-serialize-and-deserialize-binary-tree"></a> LeetCode Q 297 - Serialize and Deserialize Binary Tree</h1><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Example:<br>You may serialize the following tree: as “[1,2,3,null,null,4,5]”<br>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>You can find Binary Tree Representation in BFS <a href="https://www.lintcode.com/help/binary-tree-representation/" target="_blank" rel="noopener">here</a></p><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root.val + <span class="string">","</span> + serialize(root.left) + <span class="string">","</span> + serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">String[] strs= data.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">return</span> deserializeDFS(strs, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserializeDFS</span><span class="params">(strs, <span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (strs[index[<span class="number">0</span>]].equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">index[<span class="number">0</span>]++; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode (Integer.parseInt(strs[index[<span class="number">0</span>]]));</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line">root.left = deserializeDFS(strs, index);</span><br><span class="line">root.right = deserializeDFS(strs, index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(root.val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"#"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sb.append(curr.val);</span><br><span class="line">que.offer(curr.left);</span><br><span class="line">que.offer(curr.right);</span><br><span class="line">&#125; </span><br><span class="line">que.offer(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString.substring(<span class="number">0</span>, sb.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String[] strs = data.split(<span class="string">","</span>);</span><br><span class="line">Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">TreeNode head = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">que.offer(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &lt; s.length()) &#123;</span><br><span class="line">TreeNode curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (strs[idx].equals(<span class="string">'#'</span>)) &#123;</span><br><span class="line">curr.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[idx]));</span><br><span class="line">que.offer(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strs[idx].equals(<span class="string">'#'</span>)) &#123;</span><br><span class="line">curr.right = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[idx]));</span><br><span class="line">que.offer(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-297-serialize-and-deserialize-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-297-serialize-and-deserialize-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 297 - Serialize and Deserialize Binary Tree&lt;/h1&gt;
&lt;p&gt;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;br&gt;
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
You may serialize the following tree: as “[1,2,3,null,null,4,5]”&lt;br&gt;
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.&lt;/p&gt;
&lt;p&gt;Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ102/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ102/</id>
    <published>2019-05-01T20:05:26.000Z</published>
    <updated>2019-05-01T20:16:53.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-102-binary-tree-level-order-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-102-binary-tree-level-order-traversal"></a> LeetCode Q 102 - Binary Tree Level Order Traversal</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>3<br>/ <br>9  20<br>/  <br>15   7<br>return its level order traversal as:<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode node = que.poll();</span><br><span class="line">temp.add(node.val);</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-102-binary-tree-level-order-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-102-binary-tree-level-order-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 102 - Binary Tree Level Order Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;
3&lt;br&gt;
/ &lt;br&gt;
9  20&lt;br&gt;
/  &lt;br&gt;
15   7&lt;br&gt;
return its level order traversal as:&lt;br&gt;
[&lt;br&gt;
[3],&lt;br&gt;
[9,20],&lt;br&gt;
[15,7]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Cut Off Trees for Golf Event</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ675/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ675/</id>
    <published>2019-05-01T19:23:30.000Z</published>
    <updated>2019-05-01T19:59:39.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-675-cut-off-trees-for-golf-event"><a class="markdownIt-Anchor" href="#leetcode-q-675-cut-off-trees-for-golf-event"></a> LeetCode Q 675 - Cut Off Trees for Golf Event</h1><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p><ul><li>0 represents the obstacle can’t be reached.</li><li>1 represents the ground can be walked through.</li><li>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.</li></ul><p>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.<br>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p><p>Example 1:<br>Input:<br>[<br>[1,2,3],<br>[0,0,4],<br>[7,6,5]<br>]<br>Output: 6</p><p>Example 2:</p><p>Input:<br>[<br>[1,2,3],<br>[0,0,0],<br>[7,6,5]<br>]<br>Output: -1</p><p>Example 3:<br>Input:<br>[<br>[2,3,4],<br>[0,0,5],<br>[8,7,6]<br>]<br>Output: 6<br>Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</p><p><strong>Hint:</strong> size of the given matrix will not exceed 50x50.</p><a id="more"></a><h2 id="solution-bfs-priorityqueue"><a class="markdownIt-Anchor" href="#solution-bfs-priorityqueue"></a> Solution : BFS + PriorityQueue</h2><p><strong>PriorityQueue:</strong> store each tree, order them according to their heights for low to high.</p><p><strong>BFS:</strong> find min steps</p><p><strong>Time complexity analysis:</strong><br>The <strong>worst case</strong> time complexity could be <code>O(m^2 * n^2) (m = number of rows, n = number of columns)</code> since there are <code>m * n</code> <strong>trees</strong> and for <strong>each BFS</strong> worst case time complexity is <code>O(m * n)</code> too.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the priorityqueue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; r++) &#123;</span><br><span class="line"><span class="keyword">if</span> (forest.get(r).get(c) &gt; <span class="number">0</span>)</span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c, forest.get(r).get(c)&#125;); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs find the min step</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line"><span class="keyword">int</span> dist = getDistBFS(forest, sr, sc, tree[<span class="number">0</span>], tree[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (dist == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">sum += dist;</span><br><span class="line">sr = tree[<span class="number">0</span>]; sc = tree[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistBFS</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> tr, <span class="keyword">int</span> tc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[sr][sc] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (curr[<span class="number">0</span>] == tr &amp;&amp; curr[<span class="number">1</span>] == tc) <span class="keyword">return</span> curr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) &#123;</span><br><span class="line"><span class="keyword">int</span> r = curr[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> c = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; R &amp;&amp; c &lt; C &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c, curr[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-675-cut-off-trees-for-golf-event&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-675-cut-off-trees-for-golf-event&quot;&gt;&lt;/a&gt; LeetCode Q 675 - Cut Off Trees for Golf Event&lt;/h1&gt;
&lt;p&gt;You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 represents the obstacle can’t be reached.&lt;/li&gt;
&lt;li&gt;1 represents the ground can be walked through.&lt;/li&gt;
&lt;li&gt;The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).&lt;br&gt;
You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.&lt;br&gt;
You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[0,0,4],&lt;br&gt;
[7,6,5]&lt;br&gt;
]&lt;br&gt;
Output: 6&lt;/p&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;p&gt;Input:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[0,0,0],&lt;br&gt;
[7,6,5]&lt;br&gt;
]&lt;br&gt;
Output: -1&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
Input:&lt;br&gt;
[&lt;br&gt;
[2,3,4],&lt;br&gt;
[0,0,5],&lt;br&gt;
[8,7,6]&lt;br&gt;
]&lt;br&gt;
Output: 6&lt;br&gt;
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt; size of the given matrix will not exceed 50x50.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Shortest Bridge</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ934/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ934/</id>
    <published>2019-05-01T16:41:11.000Z</published>
    <updated>2019-05-01T19:44:57.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-934-shortest-bridge"><a class="markdownIt-Anchor" href="#leetcode-q-934-shortest-bridge"></a> LeetCode Q 934 - Shortest Bridge</h1><p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)<br>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.<br>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p><p>Example 1:<br><code>Input: [[0,1],[1,0]] ; Output: 1</code></p><p>Example 2:<br><code>Input: [[0,1,0],[0,0,0],[0,0,1]] ; Output: 2</code></p><p>Example 3:<br><code>Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]; Output: 1</code></p><p><strong>Note:</strong></p><ul><li>1 &lt;= A.length = A[0].length &lt;= 100</li><li>A[i][j] == 0 or A[i][j] == 1</li></ul><a id="more"></a><h2 id="solution-dfs-bfs"><a class="markdownIt-Anchor" href="#solution-dfs-bfs"></a> Solution : DFS + BFS</h2><p><strong>DFS:</strong> find the first island, offer all its lands to the que.</p><p><strong>BFS:</strong> expand the found island layer by layer until it reaches another one.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. DFS to find one island, put its land in the queue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (A[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">dfs(A, visited, r, c, que);</span><br><span class="line">found = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. BFS to expand the current found island to let it reach another one</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) &#123;</span><br><span class="line"><span class="keyword">int</span> i = curr[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> j = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; R &amp;&amp; j &lt; C &amp;&amp; !visited[i][j] ) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) <span class="keyword">return</span> level;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c, Queue&lt;<span class="keyword">int</span>[]&gt; que)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == A.length || c == A[<span class="number">0</span>].length || visited[r][c] || A[r][c] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) dfs(A, visited, dirs, que, r + dir[<span class="number">0</span>], c + dir[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-934-shortest-bridge&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-934-shortest-bridge&quot;&gt;&lt;/a&gt; LeetCode Q 934 - Shortest Bridge&lt;/h1&gt;
&lt;p&gt;In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)&lt;br&gt;
Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.&lt;br&gt;
Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[0,1],[1,0]] ; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[0,1,0],[0,0,0],[0,0,1]] ; Output: 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= A.length = A[0].length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;A[i][j] == 0 or A[i][j] == 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>01 Matrix</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ542/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ542/</id>
    <published>2019-04-30T20:16:16.000Z</published>
    <updated>2019-05-01T16:50:14.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-542-01-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-542-01-matrix"></a> LeetCode Q 542 - 01 Matrix</h1><p>Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.<br>The distance between two adjacent cells is 1.</p><p>Example 1:<br>Input:<br>[[0,0,0],<br>[0,1,0],<br>[0,0,0]]<br>Output:<br>[[0,0,0],<br>[0,1,0],<br>[0,0,0]]<br>Example 2:<br>Input:<br>[[0,0,0],<br>[0,1,0],<br>[1,1,1]]<br>Output:<br>[[0,0,0],<br>[0,1,0],<br>[1,2,1]]</p><p><strong>Note:</strong></p><ul><li>The number of elements of the given matrix will not exceed 10,000.</li><li>There are at least one 0 in the given matrix.</li><li>The cells are adjacent in only four directions: up, down, left and right.</li></ul><a id="more"></a><h2 id="solution-bfs-dp"><a class="markdownIt-Anchor" href="#solution-bfs-dp"></a> Solution : BFS / DP</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1: BFS</h3><p><strong>Steps:</strong><br>We regard the 2D matrix as a string. For an element in the matrix, we use <code>rowNum * colLength + colNum</code> to denote its index.</p><ol><li>push the <code>0s</code> in the matrix to the <code>queue</code>.</li><li>do the bfs, at each level<ul><li>pull the <code>index</code> from the <code>queue</code>. According to that <code>index</code>, we can determine the <code>rowNumber</code> and <code>colNumber</code>.</li><li>we traverse its left, right, up and down, if they haven’t been visited, then we offer them in the queue and visited set.</li><li>when we have finished traversing one layer, we increase the level.</li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(<span class="string">"0000"</span>);</span><br><span class="line">visitedA.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(target);</span><br><span class="line">visitedB.add(target);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="a-better-solution-dp"><a class="markdownIt-Anchor" href="#a-better-solution-dp"></a> A Better Solution: DP</h3><ol><li><p><strong>States:</strong> <code>dp[i][j]</code> the min distance of number at row i and col j.</p></li><li><p><strong>State Transfer Function:</strong></p><ul><li><p>Iterate the matrix <strong>from top left to bottom right</strong>:<br>Update <code>dp[i][j] = min(dp[i][j], min(dp[i][j - 1], dp[i - 1][j] + 1))</code><br>i.e., minimum of the current dist and distance from top or left neighbour +1, that would have been already calculated previously in the current iteration.</p></li><li><p>Do the back iteration in the similar manner: <strong>from bottom right to top left</strong>:<br>Update <code>dp[i][j] = min(dp[i][j], min(dp[i][j + 1], dp[i + 1][j] + 1))</code><br>i.e. minimum of current dist and distances calculated from bottom and right neighbours, that would be already available in current iteration.</p></li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] updateMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> matrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = <span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = Math.min(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = R - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = C - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &lt; R - <span class="number">1</span>) dp[i][j] = Math.min(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (j &lt; C - <span class="number">1</span>) dp[i][j] = Math.min(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-542-01-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-542-01-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 542 - 01 Matrix&lt;/h1&gt;
&lt;p&gt;Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.&lt;br&gt;
The distance between two adjacent cells is 1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[0,0,0]]&lt;br&gt;
Output:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[0,0,0]]&lt;br&gt;
Example 2:&lt;br&gt;
Input:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[1,1,1]]&lt;br&gt;
Output:&lt;br&gt;
[[0,0,0],&lt;br&gt;
[0,1,0],&lt;br&gt;
[1,2,1]]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of elements of the given matrix will not exceed 10,000.&lt;/li&gt;
&lt;li&gt;There are at least one 0 in the given matrix.&lt;/li&gt;
&lt;li&gt;The cells are adjacent in only four directions: up, down, left and right.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Open the Lock</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ752/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ752/</id>
    <published>2019-04-30T20:05:03.000Z</published>
    <updated>2019-04-30T20:15:50.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-752-open-the-lock"><a class="markdownIt-Anchor" href="#leetcode-q-752-open-the-lock"></a> LeetCode Q 752 - Open the Lock</h1><p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code>. The wheels can rotate freely and wrap around: for example we can turn <code>'9'</code> to be <code>'0'</code>, or <code>'0'</code> to be <code>'9'</code>. Each move consists of turning one wheel one slot.<br>The lock initially starts at <code>0000'</code>, a string representing the state of the 4 wheels.<br>You are given a list of <code>deadends</code> dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.<br>Given a <code>target</code> representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p><p>Example 1:<br><code>Input: deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot; ; Output: 6</code><br>Explanation:<br>A sequence of valid moves would be “0000” -&gt; “1000” -&gt; “1100” -&gt; “1200” -&gt; “1201” -&gt; “1202” -&gt; “0202”.<br>Note that a sequence like “0000” -&gt; “0001” -&gt; “0002” -&gt; “0102” -&gt; “0202” would be invalid,<br>because the wheels of the lock become stuck after the display becomes the dead end “0102”.</p><p>Example 2:<br><code>Input: deadends = [&quot;8888&quot;], target = &quot;0009&quot; ; Output: 1</code><br>Explanation:<br>We can turn the last wheel in reverse to move from “0000” -&gt; “0009”.</p><p>Example 3:<br><code>Input: deadends = [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;, &quot;9888&quot;], target = &quot;8888&quot; ; Output: -1</code><br>Explanation:<br>We can’t reach the target without getting stuck.</p><p>Example 4:<br><code>Input: deadends = [&quot;0000&quot;], target = &quot;8888&quot; ; Output: -1</code></p><p><strong>Note:</strong></p><ul><li>The length of deadends will be in the range [1, 500].</li><li>target will not be in the list deadends.</li><li>Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’.</li></ul><a id="more"></a><h2 id="solution-bfs-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-bfs-two-end-bfs-bidirectional-search"></a> Solution : BFS / Two-End BFS (Bidirectional Search)</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1: BFS</h3><p><strong>Tip:</strong><br>Chaning char[] is <strong>faster</strong> than string concatenation. That is,<br><code>char[] chs = cur.toCharArray(); chs[i] = (char)((cur.charAt(i) - '0' + 9) % 10 + '0'); String next = String.valueOf(chs);</code><br>is better than<br><code>String next = cur.substring(0, i) + (char)((cur.charAt(i) - '0' + 9) % 10 + '0') + cur.substring(i + 1);</code></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) </span><br><span class="line">    deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(<span class="string">"0000"</span>);</span><br><span class="line">visited.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cur.equals(target)) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">    que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">    que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-2-two-end-bfs-bidirectional-search"></a> Solution 2: Two-End BFS (Bidirectional Search)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">Set&lt;String&gt; deadSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String str : deadends) deadSet.add(str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (deadSet.contains(target) || deadSet.contains(<span class="string">"0000"</span>)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(<span class="string">"0000"</span>);</span><br><span class="line">visitedA.add(<span class="string">"0000"</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(target);</span><br><span class="line">visitedB.add(target);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>; </span><br><span class="line">Set&lt;String&gt; setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result++;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">String cur = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = cur.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">9</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chs[i] = (<span class="keyword">char</span>)((cur.charAt(i) - <span class="string">'0'</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next) &amp;&amp; !deadSet.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-752-open-the-lock&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-752-open-the-lock&quot;&gt;&lt;/a&gt; LeetCode Q 752 - Open the Lock&lt;/h1&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;&#39;9&#39;&lt;/code&gt; to be &lt;code&gt;&#39;0&#39;&lt;/code&gt;, or &lt;code&gt;&#39;0&#39;&lt;/code&gt; to be &lt;code&gt;&#39;9&#39;&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;br&gt;
The lock initially starts at &lt;code&gt;0000&#39;&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;br&gt;
You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;br&gt;
Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot; ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
A sequence of valid moves would be “0000” -&amp;gt; “1000” -&amp;gt; “1100” -&amp;gt; “1200” -&amp;gt; “1201” -&amp;gt; “1202” -&amp;gt; “0202”.&lt;br&gt;
Note that a sequence like “0000” -&amp;gt; “0001” -&amp;gt; “0002” -&amp;gt; “0102” -&amp;gt; “0202” would be invalid,&lt;br&gt;
because the wheels of the lock become stuck after the display becomes the dead end “0102”.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;8888&amp;quot;], target = &amp;quot;0009&amp;quot; ; Output: 1&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
We can turn the last wheel in reverse to move from “0000” -&amp;gt; “0009”.&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;8887&amp;quot;,&amp;quot;8889&amp;quot;,&amp;quot;8878&amp;quot;,&amp;quot;8898&amp;quot;,&amp;quot;8788&amp;quot;,&amp;quot;8988&amp;quot;,&amp;quot;7888&amp;quot;, &amp;quot;9888&amp;quot;], target = &amp;quot;8888&amp;quot; ; Output: -1&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
We can’t reach the target without getting stuck.&lt;/p&gt;
&lt;p&gt;Example 4:&lt;br&gt;
&lt;code&gt;Input: deadends = [&amp;quot;0000&amp;quot;], target = &amp;quot;8888&amp;quot; ; Output: -1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of deadends will be in the range [1, 500].&lt;/li&gt;
&lt;li&gt;target will not be in the list deadends.&lt;/li&gt;
&lt;li&gt;Every string in deadends and the string target will be a string of 4 digits from the 10,000 possibilities ‘0000’ to ‘9999’.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Ladder II</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ126/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ126/</id>
    <published>2019-04-30T19:34:17.000Z</published>
    <updated>2019-04-30T20:04:07.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-126-word-ladder-ii"><a class="markdownIt-Anchor" href="#leetcode-q-126-word-ladder-ii"></a> LeetCode Q 126 - Word Ladder II</h1><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find all shortest transformation sequence(s) from <em>beginWord</em> to <em>endWord</em>, such that:</p><ul><li>Only one letter can be changed at a time</li><li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li></ul><p><strong>Note:</strong></p><ul><li>Return an empty list if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume beginWord and endWord are non-empty and are not the same.</li></ul><p>Example 1:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</code><br>Output:<br>[<br>[“hit”,“hot”,“dot”,“dog”,“cog”],<br>[“hit”,“hot”,“lot”,“log”,“cog”]<br>]</p><p>Example 2:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</code><br>Output: []<br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><a id="more"></a><h2 id="solution-bfs-dfs"><a class="markdownIt-Anchor" href="#solution-bfs-dfs"></a> Solution : BFS + DFS</h2><ol><li><strong>BFS</strong>: find the shortest distance between start and end, tracing the distance of crossing nodes from start node to end node, and store node’s next level neighbors to HashMap;</li><li><strong>DFS</strong>: output paths with the same distance as the shortest distance from distance HashMap: compare if the distance of the next level node equals the distance of the current node + 1.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String start, String end, List&lt;String&gt; wordList) &#123; </span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; neighbors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, Integer&gt; distance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">bfs(start, end, dict, neighbors, distance);</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">dfs(start, end, neighbors, distance, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS: Trace every node's distance from the start node (level by level).</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(String start, String end, Set&lt;String&gt; dict, Map&lt;String, List&lt;String&gt;&gt; neighbors, Map&lt;String, Integer&gt; distance)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: dict) neighbors.put(str, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(start); </span><br><span class="line">distance.put(start, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String curr = que.poll();</span><br><span class="line"><span class="keyword">int</span> curDistance = distance.get(cur);                </span><br><span class="line">List&lt;String&gt; nextList = getNeighbors(cur, dict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String next: nextList) &#123;</span><br><span class="line">neighbors.get(curr).add(next);</span><br><span class="line"><span class="keyword">if</span> (!distance.contains(next)) &#123; <span class="comment">// Check if visited</span></span><br><span class="line">distance.put(next, curDistance + <span class="number">1</span>);</span><br><span class="line">que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS: output all paths with the shortest distance.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(String start, String end, Map&lt;String, List&lt;String&gt;&gt; neighbors, Map&lt;String, Integer&gt; distance, List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt;()</span> path) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(path)); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">path.add(start);</span><br><span class="line"><span class="keyword">for</span> (String next: neighbors.get(start)) &#123;</span><br><span class="line"><span class="keyword">if</span> (distance.get(next) == distance.get(start) + <span class="number">1</span>) </span><br><span class="line">dfs(next, end, neighbors, distance, res, path);</span><br><span class="line">&#125;</span><br><span class="line">path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all next level nodes.    </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">chs[i] = ch;</span><br><span class="line"><span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">    res.add(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">chs[i] = old_ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-126-word-ladder-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-126-word-ladder-ii&quot;&gt;&lt;/a&gt; LeetCode Q 126 - Word Ladder II&lt;/h1&gt;
&lt;p&gt;Given two words (&lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt;), and a dictionary’s word list, find all shortest transformation sequence(s) from &lt;em&gt;beginWord&lt;/em&gt; to &lt;em&gt;endWord&lt;/em&gt;, such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only one letter can be changed at a time&lt;/li&gt;
&lt;li&gt;Each transformed word must exist in the word list. Note that beginWord is not a transformed word.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return an empty list if there is no such transformation sequence.&lt;/li&gt;
&lt;li&gt;All words have the same length.&lt;/li&gt;
&lt;li&gt;All words contain only lowercase alphabetic characters.&lt;/li&gt;
&lt;li&gt;You may assume no duplicates in the word list.&lt;/li&gt;
&lt;li&gt;You may assume beginWord and endWord are non-empty and are not the same.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[“hit”,“hot”,“dot”,“dog”,“cog”],&lt;br&gt;
[“hit”,“hot”,“lot”,“log”,“cog”]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;]&lt;/code&gt;&lt;br&gt;
Output: []&lt;br&gt;
Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Ladder</title>
    <link href="http://yoursite.com/2019/04/30/leetcodeQ127/"/>
    <id>http://yoursite.com/2019/04/30/leetcodeQ127/</id>
    <published>2019-04-30T17:17:04.000Z</published>
    <updated>2019-04-30T19:34:57.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-127-word-ladder"><a class="markdownIt-Anchor" href="#leetcode-q-127-word-ladder"></a> LeetCode Q 127 - Word Ladder</h1><p>Given two words (<em>beginWord</em> and <em>endWord</em>), and a dictionary’s word list, find the length of shortest transformation sequence from <em>beginWord</em> to <em>endWord</em>, such that:</p><ol><li>Only one letter can be changed at a time.</li><li>Each transformed word must exist in the word list. Note that <em>beginWord</em> is not a transformed word.</li></ol><p><strong>Note:</strong></p><ul><li>Return 0 if there is no such transformation sequence.</li><li>All words have the same length.</li><li>All words contain only lowercase alphabetic characters.</li><li>You may assume no duplicates in the word list.</li><li>You may assume <em>beginWord</em> and <em>endWord</em> are non-empty and are not the same.</li></ul><p>Example 1:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] Output: 5</code><br>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p><p>Example 2:<br><code>Input: beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;] Output: 0</code><br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p><a id="more"></a><h2 id="solution-bfs-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-bfs-two-end-bfs-bidirectional-search"></a> Solution : BFS / Two-End BFS (Bidirectional Search)</h2><h3 id="solution-1-bfs-time-limit-exceeds"><a class="markdownIt-Anchor" href="#solution-1-bfs-time-limit-exceeds"></a> Solution 1: BFS (Time Limit Exceeds)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, List&lt;String&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">wordList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(end)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(start); visited.add(start);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String curr = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = curr.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">chs[i] = ch;</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (next.equals(end)) <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (!visited.contains(next) &amp;&amp; wordList.contains(next)) &#123;</span><br><span class="line">que.offer(next); visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#solution-2-two-end-bfs-bidirectional-search"></a> Solution 2: Two-End BFS (Bidirectional Search)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String start, String end, List&lt;String&gt; </span></span></span><br><span class="line"><span class="function"><span class="params">wordList)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!wordList.contains(end)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (start.equals(end)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedA = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queA.offer(start); visitedA.add(start);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; queB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; visitedB = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">queB.offer(end); visitedB.add(end);</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que = <span class="keyword">null</span>;</span><br><span class="line">Set&lt;String&gt; setCurr = <span class="keyword">null</span>, setOp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!queA.isEmpty() &amp;&amp; !queB.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (queA.size() &lt;= queB.size()) &#123;</span><br><span class="line">que = queA; setCurr = visitedA; setOp = visitedB;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">que = queB; setCurr = visitedB; setOp = visitedA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line">String word = que.poll();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; nextList = getNext(word, wordDict);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String next: nextList) &#123;</span><br><span class="line"><span class="keyword">if</span> (setOp.contains(next)) <span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!setCurr.contains(next)) &#123;</span><br><span class="line">que.offer(next); setCurr.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">levle++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">getNext</span><span class="params">(String curr, List&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span>[] chs = curr.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>; ++c) &#123;</span><br><span class="line"><span class="keyword">if</span> (c != old) &#123;</span><br><span class="line">String next = String.valueOf(chs);</span><br><span class="line"><span class="keyword">if</span> (dict.contains(next)) </span><br><span class="line">res.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="two-end-bfs-bidirectional-search"><a class="markdownIt-Anchor" href="#two-end-bfs-bidirectional-search"></a> Two-End BFS (Bidirectional Search)</h3><p><strong>Bidirectional search</strong> is a graph search algorithm which find <strong>smallest path</strong> form source to goal vertex. It runs two simultaneous search, i.e.</p><ol><li>Forward search form source/initial vertex toward goal vertex</li><li>Backward search form goal/target vertex toward source vertex</li></ol><p>Bidirectional search replaces single search graph(which is likely to grow exponentially) with two smaller sub graphs – one starting from <strong>initial vertex</strong> and other starting from <strong>goal vertex</strong>. The search terminates when two graphs <strong>intersect</strong>.</p><h4 id="why-two-end-bfs"><a class="markdownIt-Anchor" href="#why-two-end-bfs"></a> Why Two-End BFS?</h4><p>Because in many cases it is <strong>faster</strong>, it dramatically reduce the amount of required exploration.<br>Suppose if branching factor of tree is <em><strong>b</strong></em> and distance of goal vertex from source is <em><strong>d</strong></em>, then the normal BFS/DFS searching complexity would be <code>O(b^d)</code>. On the other hand, if we execute two search operation then the complexity would be <code>O(b^(d/2))</code> for each search and total complexity would be <code>O(b^(d/2)+b^(d/2)</code> which is far less than <code>O(b^d)</code>.</p><h4 id="when-to-use-bidirectional-approach"><a class="markdownIt-Anchor" href="#when-to-use-bidirectional-approach"></a> When to use bidirectional approach?</h4><p>We can consider bidirectional approach when</p><ul><li>Both initial and goal states are unique and completely defined.</li><li>The branching factor is exactly the same in both directions.</li></ul><h4 id="performance-measures"><a class="markdownIt-Anchor" href="#performance-measures"></a> Performance measures</h4><p>Time and Space Complexity : Time and space complexity is O(b^{d/2})</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-127-word-ladder&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-127-word-ladder&quot;&gt;&lt;/a&gt; LeetCode Q 127 - Word Ladder&lt;/h1&gt;
&lt;p&gt;Given two words (&lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt;), and a dictionary’s word list, find the length of shortest transformation sequence from &lt;em&gt;beginWord&lt;/em&gt; to &lt;em&gt;endWord&lt;/em&gt;, such that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Only one letter can be changed at a time.&lt;/li&gt;
&lt;li&gt;Each transformed word must exist in the word list. Note that &lt;em&gt;beginWord&lt;/em&gt; is not a transformed word.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Return 0 if there is no such transformation sequence.&lt;/li&gt;
&lt;li&gt;All words have the same length.&lt;/li&gt;
&lt;li&gt;All words contain only lowercase alphabetic characters.&lt;/li&gt;
&lt;li&gt;You may assume no duplicates in the word list.&lt;/li&gt;
&lt;li&gt;You may assume &lt;em&gt;beginWord&lt;/em&gt; and &lt;em&gt;endWord&lt;/em&gt; are non-empty and are not the same.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;] Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: As one shortest transformation is “hit” -&amp;gt; “hot” -&amp;gt; “dot” -&amp;gt; “dog” -&amp;gt; “cog”,&lt;br&gt;
return its length 5.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: beginWord = &amp;quot;hit&amp;quot;, endWord = &amp;quot;cog&amp;quot;, wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;] Output: 0&lt;/code&gt;&lt;br&gt;
Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Word Search II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ212/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ212/</id>
    <published>2019-04-29T17:31:48.000Z</published>
    <updated>2019-04-29T17:48:32.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-212-word-search-ii"><a class="markdownIt-Anchor" href="#leetcode-q-212-word-search-ii"></a> LeetCode Q 212 - Word Search II</h1><p>Given a 2D board and a list of words from the dictionary, find all words in the board.<br>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>Example:<br>Input:<br>board = [<br>[‘o’,‘a’,‘a’,‘n’],<br>[‘e’,‘t’,‘a’,‘e’],<br>[‘i’,‘h’,‘k’,‘r’],<br>[‘i’,‘f’,‘l’,‘v’]<br>]<br>words = [“oath”,“pea”,“eat”,“rain”]<br>Output: [“eat”,“oath”]</p><p><strong>Note:</strong></p><ul><li>All inputs are consist of lowercase letters a-z.</li><li>The values of words are distinct.</li></ul><a id="more"></a><h2 id="solution-trie-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-trie-dfs-backtracking"></a> Solution : Trie + DFS / Backtracking</h2><p>Compared with <a href="/2019/04/29/leetcodeQ79/" title="Word Search">Word Search</a>, we use DFS with a trie but a word.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>() </span>&#123;</span><br><span class="line">TrieNode[] children;</span><br><span class="line"><span class="keyword">boolean</span> isEnd;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>]) </span><br><span class="line">node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; res;  <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the trie</span></span><br><span class="line"><span class="keyword">for</span> (String word: words) trie.insert(word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> [board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">dfs(board, <span class="string">""</span>, i, j, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String curr, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || visited[row][col]) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">curr += board[row][col];</span><br><span class="line"><span class="keyword">if</span> (!startWith(curr)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (search(curr)) &#123; res.add(curr); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">dfs(board, row + <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row - <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row, col + <span class="number">1</span>, visited);</span><br><span class="line">dfs(board, row, col - <span class="number">1</span>, visited);</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-212-word-search-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-212-word-search-ii&quot;&gt;&lt;/a&gt; LeetCode Q 212 - Word Search II&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a list of words from the dictionary, find all words in the board.&lt;br&gt;
Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Input:&lt;br&gt;
board = [&lt;br&gt;
[‘o’,‘a’,‘a’,‘n’],&lt;br&gt;
[‘e’,‘t’,‘a’,‘e’],&lt;br&gt;
[‘i’,‘h’,‘k’,‘r’],&lt;br&gt;
[‘i’,‘f’,‘l’,‘v’]&lt;br&gt;
]&lt;br&gt;
words = [“oath”,“pea”,“eat”,“rain”]&lt;br&gt;
Output: [“eat”,“oath”]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All inputs are consist of lowercase letters a-z.&lt;/li&gt;
&lt;li&gt;The values of words are distinct.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Word Search</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ79/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ79/</id>
    <published>2019-04-29T17:22:35.000Z</published>
    <updated>2019-04-29T17:31:23.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-79-word-search"><a class="markdownIt-Anchor" href="#leetcode-q-79-word-search"></a> LeetCode Q 79 - Word Search</h1><p>Given a 2D board and a word, find if the word exists in the grid.<br>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:<br>board =<br>[<br>[‘A’,‘B’,‘C’,‘E’],<br>[‘S’,‘F’,‘C’,‘S’],<br>[‘A’,‘D’,‘E’,‘E’]<br>]</p><p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p>**Time Complexity:**O(n^2 * 4 * 3^(k-1)) = O(n^2 * 3^k).</p><p>Explanation: We start the word search over all n^2 nodes. For the first letter of the word search we can move in 4 directions but for every later one there are only three options (you can’t move back onto yourself).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || </span><br><span class="line">visited[row][col] || board[row][col] != word.charAt(pos)) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, pos + <span class="number">1</span>, row - <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row + <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col - <span class="number">1</span>) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-79-word-search&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-79-word-search&quot;&gt;&lt;/a&gt; LeetCode Q 79 - Word Search&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;br&gt;
The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
board =&lt;br&gt;
[&lt;br&gt;
[‘A’,‘B’,‘C’,‘E’],&lt;br&gt;
[‘S’,‘F’,‘C’,‘S’],&lt;br&gt;
[‘A’,‘D’,‘E’,‘E’]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Given word = “ABCCED”, return true.&lt;br&gt;
Given word = “SEE”, return true.&lt;br&gt;
Given word = “ABCB”, return false.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ52/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ52/</id>
    <published>2019-04-29T17:17:50.000Z</published>
    <updated>2019-04-29T17:22:58.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-52-n-queens-ii"><a class="markdownIt-Anchor" href="#leetcode-q-52-n-queens-ii"></a> LeetCode Q 52 - N-Queens II</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p><p>Example:<br><code>Input: 4 ; Output: 2</code><br>Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.<br>[<br>[&quot;.Q…&quot;,  // Solution 1<br>“…Q”,<br>“Q…”,<br>“…Q.”],</p><p>[&quot;…Q.&quot;,  // Solution 2<br>“Q…”,<br>“…Q”,<br>“.Q…”]<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">res++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-52-n-queens-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-52-n-queens-ii&quot;&gt;&lt;/a&gt; LeetCode Q 52 - N-Queens II&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return the number of distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.&lt;br&gt;
[&lt;br&gt;
[&amp;quot;.Q…&amp;quot;,  // Solution 1&lt;br&gt;
“…Q”,&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q.”],&lt;/p&gt;
&lt;p&gt;[&amp;quot;…Q.&amp;quot;,  // Solution 2&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q”,&lt;br&gt;
“.Q…”]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ51/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ51/</id>
    <published>2019-04-29T16:57:30.000Z</published>
    <updated>2019-04-29T17:22:54.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-51-n-queens"><a class="markdownIt-Anchor" href="#leetcode-q-51-n-queens"></a> LeetCode Q 51 - N-Queens</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p><p>Example:<br><code>Input: 4 Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ]</code><br>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> N) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j  = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line"> row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, N, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length)</span><br><span class="line">list.add(String.valueOf(board[i]));</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-51-n-queens&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-51-n-queens&quot;&gt;&lt;/a&gt; LeetCode Q 51 - N-Queens&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;br&gt;
Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 Output: [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;..Q.&amp;quot;], [&amp;quot;..Q.&amp;quot;, // Solution 2 &amp;quot;Q...&amp;quot;, &amp;quot;...Q&amp;quot;, &amp;quot;.Q..&amp;quot;] ]&lt;/code&gt;&lt;br&gt;
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Remove Invalid Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ301/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ301/</id>
    <published>2019-04-29T16:34:02.000Z</published>
    <updated>2019-04-29T16:56:29.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-301-remove-invalid-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-301-remove-invalid-parentheses"></a> LeetCode Q 301 - Remove Invalid Parentheses</h1><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.<br><strong>Note:</strong> The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p><p>Example 1:<br><code>Input: &quot;()())()&quot; ; Output: [&quot;()()()&quot;, &quot;(())()&quot;]</code><br>Example 2:<br><code>Input: &quot;(a)())()&quot; ; Output: [&quot;(a)()()&quot;, &quot;(a())()&quot;]</code><br>Example 3:<br><code>Input: &quot;)(&quot; ; Output: [&quot;&quot;]</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><ol><li>pre-process the String <code>s</code>, determine how many <code>(</code>s and <code>)</code>s we need to delete.</li><li>To avoid duplicates, use a set to store the result.</li><li>Backtrack finding the answer.<ul><li>corner cases: <code>if (rmL &lt; 0 || rmR &lt; 0 || open &lt; 0)</code> indicates an invalid string, we should return;</li><li>our goal(i.e. when to break the backtrack): <code>if (pos == s.length())</code> we should also stop the backtrack, and check<ul><li><code>if (rmL == 0 &amp;&amp; rmR == 0 &amp;&amp; open == 0)</code>, then update the result set;</li><li>else just ruturn;</li></ul></li><li>explore<ul><li>if current char is ‘(’ or ‘)’ we can either choose to <strong>use</strong> it or <strong>not</strong>.</li><li>if current char is a letter we update current string.</li></ul></li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; res; <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> rmL = <span class="number">0</span>, rmR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">rmL++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL != <span class="number">0</span>) rmL--;</span><br><span class="line"><span class="keyword">else</span> rmR++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(s, <span class="number">0</span>, <span class="string">""</span>, rmL, rmR, open);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> pos, String curr, <span class="keyword">int</span> rmL, <span class="keyword">int</span> rmR, <span class="keyword">int</span> open)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rmL &lt; <span class="number">0</span> || rmR &lt; <span class="number">0</span> || open &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL == <span class="number">0</span> &amp;&amp; rmR == <span class="number">0</span> &amp;&amp; open == <span class="number">0</span>) res.add(curr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = s.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open + <span class="number">1</span>); <span class="comment">// use '('</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL - <span class="number">1</span>, rmR, open); <span class="comment">// not use '('</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open - <span class="number">1</span>); <span class="comment">// use ')'</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL, rmR - <span class="number">1</span>, open); <span class="comment">// not use ')'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 301 - Remove Invalid Parentheses&lt;/h1&gt;
&lt;p&gt;Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The input string may contain letters other than the parentheses &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;()())()&amp;quot; ; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;(a)())()&amp;quot; ; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;)(&amp;quot; ; Output: [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Generate Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ22/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ22/</id>
    <published>2019-04-29T16:30:18.000Z</published>
    <updated>2019-04-29T16:33:43.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-22-generate-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-22-generate-parentheses"></a> LeetCode Q 22 - Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:<br>[<br>“((()))”,<br>“(()())”,<br>“(())()”,<br>“()(())”,<br>“()()()”<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; n || right &gt; n || left &lt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curr.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(n, left + <span class="number">1</span>, right, curr + <span class="string">'('</span>);</span><br><span class="line">dfs(n, left, right + <span class="number">1</span>, curr + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-22-generate-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-22-generate-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 22 - Generate Parentheses&lt;/h1&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;br&gt;
[&lt;br&gt;
“((()))”,&lt;br&gt;
“(()())”,&lt;br&gt;
“(())()”,&lt;br&gt;
“()(())”,&lt;br&gt;
“()()()”&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Letter Case Permutation</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ784/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ784/</id>
    <published>2019-04-29T16:11:58.000Z</published>
    <updated>2019-04-29T16:29:39.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-784-letter-case-permutation"><a class="markdownIt-Anchor" href="#leetcode-q-784-letter-case-permutation"></a> LeetCode Q 784 - Letter Case Permutation</h1><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p><p>Examples:<br><code>Input: S = &quot;a1b2&quot; ; Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></p><p><code>Input: S = &quot;3z4&quot; ; Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</code></p><p><code>Input: S = &quot;12345&quot; ; Output: [&quot;12345&quot;]</code></p><p><strong>Note:</strong></p><ul><li>S will be a string with length between 1 and 12.</li><li>S will consist only of letters or digits.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-1-dfs-backtracking"></a> Solution 1 : DFS / Backtracking</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(S, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String S, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == S.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = S.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(ch)) &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toUpperCase(ch));</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toLowerCase(ch));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(S.charAt(i))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">String str = que.poll();</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = Character.toUpperCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">chs[i] = Character.toLowerCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(que);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-784-letter-case-permutation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-784-letter-case-permutation&quot;&gt;&lt;/a&gt; LeetCode Q 784 - Letter Case Permutation&lt;/h1&gt;
&lt;p&gt;Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;a1b2&amp;quot; ; Output: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;3z4&amp;quot; ; Output: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;12345&amp;quot; ; Output: [&amp;quot;12345&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S will be a string with length between 1 and 12.&lt;/li&gt;
&lt;li&gt;S will consist only of letters or digits.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
</feed>
