<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-17T15:56:33.386Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Contiguous Array</title>
    <link href="http://yoursite.com/2019/04/17/leetcodeQ525/"/>
    <id>http://yoursite.com/2019/04/17/leetcodeQ525/</id>
    <published>2019-04-17T15:11:34.000Z</published>
    <updated>2019-04-17T15:56:33.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-525-contiguous-array"><a class="markdownIt-Anchor" href="#leetcode-q-525-contiguous-array"></a> LeetCode Q 525 - Contiguous Array</h1><p>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Our solution will be explained with an example.<br><code>input array: [0, 1, 0, 0, 0, 1, 1, 1]</code><br>Use a variable <code>sum</code>. Traverse the array, when meet a 0, sum - 1; when meed a 1, sum + 1.<br>From the following image, we can find that if at any moment, the countcount becomes zero, it implies that we’ve encountered equal number of zeros and ones from the beginning till the current index of the array(ii). Not only this, another point to be noted is that if we encounter the same countcount twice while traversing the array, it means that the number of zeros and ones are equal between the indices corresponding to the equal countcount values.</p><img src="leetcodeQ525.png" width="50%" height="50%"><p>Therefore, we use a map to store that information. Say <strong>key</strong> is the sum val, <strong>value</strong> denotes the index. In every iteration, 1) update sum; 2) see if that sum is already a key of the map, if it is then update maxLen = Max(maxLen, i - map.get(sum)).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, maxLength = <span class="number">0</span>; map.put(<span class="number">0</span>, -<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">sum--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">sum++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(sum))</span><br><span class="line">maxLength = Math.max(maxLength, i - map.get(sum));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">map.put(sum, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-525-contiguous-array&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-525-contiguous-array&quot;&gt;&lt;/a&gt; LeetCode Q 525 - Contiguous Array&lt;/h1&gt;
&lt;p&gt;Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum</title>
    <link href="http://yoursite.com/2019/04/17/leetcodeQ1/"/>
    <id>http://yoursite.com/2019/04/17/leetcodeQ1/</id>
    <published>2019-04-17T15:05:56.000Z</published>
    <updated>2019-04-17T15:09:19.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1-two-sum"><a class="markdownIt-Anchor" href="#leetcode-q-1-two-sum"></a> LeetCode Q 1 - Two Sum</h1><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target - nums[i]))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">map.put(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1-two-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1-two-sum&quot;&gt;&lt;/a&gt; LeetCode Q 1 - Two Sum&lt;/h1&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have &lt;strong&gt;exactly&lt;/strong&gt; one solution, and you may not use the same element twice.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>4Sum II</title>
    <link href="http://yoursite.com/2019/04/17/leetcodeQ454/"/>
    <id>http://yoursite.com/2019/04/17/leetcodeQ454/</id>
    <published>2019-04-17T14:53:43.000Z</published>
    <updated>2019-04-17T15:10:13.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-454-4sum-ii"><a class="markdownIt-Anchor" href="#leetcode-q-454-4sum-ii"></a> LeetCode Q 454 - 4Sum II</h1><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The solution is quite similar to <a href="/2019/04/17/leetcodeQ1/" title="Two Sum">Two Sum</a>.<br>We use a HashMap to store the possible sum of every pair in A and B.<br>Then we check if the sum of some pair in C and D equals to -key in the map.</p><p><strong>Time Complexity: O(n^2)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a: A) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> b: B) &#123;</span><br><span class="line">map.put(a + b, map.getOrDefault(a + b, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c: C) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d: D) &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(-c-d)) res += map.get(-c-d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-454-4sum-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-454-4sum-ii&quot;&gt;&lt;/a&gt; LeetCode Q 454 - 4Sum II&lt;/h1&gt;
&lt;p&gt;Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.&lt;/p&gt;
&lt;p&gt;To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -2^28 to 2^28 - 1 and the result is guaranteed to be at most 2^31 - 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>4Sum</title>
    <link href="http://yoursite.com/2019/04/17/leetcodeQ18/"/>
    <id>http://yoursite.com/2019/04/17/leetcodeQ18/</id>
    <published>2019-04-17T14:40:41.000Z</published>
    <updated>2019-04-17T15:05:23.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-18-4sum"><a class="markdownIt-Anchor" href="#leetcode-q-18-4sum"></a> LeetCode Q 18 - 4Sum</h1><p>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that <code>a + b + c + d = target?</code>Find all unique quadruplets in the array which gives the sum of target.</p><p>**Note:**The solution set must not contain duplicate quadruplets.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The key points are, 1) how we deal with duplicates, 2) how to make use of boundary case to make our code more effecient.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">4</span> || nums[<span class="number">0</span>] * <span class="number">4</span> &gt; target || nums[len - <span class="number">1</span>] * <span class="number">4</span> &lt; target)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target) <span class="keyword">break</span>; <span class="comment">// i is too large;</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>] + nums[len - <span class="number">3</span>] &lt; target) <span class="keyword">continue</span>; <span class="comment">// i is too small;</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] + nums[j + <span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target) <span class="keyword">break</span>; <span class="comment">// j is too large;</span></span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] + nums[len - <span class="number">1</span>] + nums[len - <span class="number">2</span>] &lt; target) <span class="keyword">continue</span>; <span class="comment">// j is too small;</span></span><br><span class="line"><span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = j + <span class="number">1</span>, end = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[i] + nums[j] + nums[start] + nums[end];</span><br><span class="line"><span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">res.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));</span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; nums[start] = nums[start+<span class="number">1</span>]) start++;</span><br><span class="line"><span class="keyword">while</span> (start &lt; end &amp;&amp; nums[end] = nums[end-<span class="number">1</span>]) end--;</span><br><span class="line">start++; end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) end--;</span><br><span class="line"><span class="keyword">else</span> start++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-18-4sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-18-4sum&quot;&gt;&lt;/a&gt; LeetCode Q 18 - 4Sum&lt;/h1&gt;
&lt;p&gt;Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that &lt;code&gt;a + b + c + d = target?&lt;/code&gt;Find all unique quadruplets in the array which gives the sum of target.&lt;/p&gt;
&lt;p&gt;**Note:**The solution set must not contain duplicate quadruplets.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring Without Repeating Characters</title>
    <link href="http://yoursite.com/2019/04/17/leetcodeQ3/"/>
    <id>http://yoursite.com/2019/04/17/leetcodeQ3/</id>
    <published>2019-04-17T14:27:02.000Z</published>
    <updated>2019-04-17T14:40:05.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-3-longest-substring-without-repeating-characters"><a class="markdownIt-Anchor" href="#leetcode-q-3-longest-substring-without-repeating-characters"></a> LeetCode Q 3 - Longest Substring Without Repeating Characters</h1><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The solution is intuitional. Use two pointers applying sliding window algorithm and sweeping the whole string, then find the max length.</p><p>We can use a <strong>HashSet</strong> or an <strong>array</strong> to detect repeated character.</p><h3 id="method-1-use-a-hashset"><a class="markdownIt-Anchor" href="#method-1-use-a-hashset"></a> Method 1: Use a HashSet</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length(); ) &#123;</span><br><span class="line"><span class="keyword">if</span> (set.contains(s.charAt(r))) &#123;</span><br><span class="line">set.add(s.charAt(r++));</span><br><span class="line">maxLen = Math.max(maxLen, set.size());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">set.remove(s.charAt(l++));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runtime: 9ms.</strong></p><h3 id="method-2-use-an-array"><a class="markdownIt-Anchor" href="#method-2-use-an-array"></a> Method 2: Use an array</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.length(); r++) &#123;</span><br><span class="line">count[s.charAt(r)]++;</span><br><span class="line"><span class="keyword">while</span> (count[s.charAt(r)] &gt; <span class="number">1</span>)</span><br><span class="line">count[s.charAt(l++)]--;</span><br><span class="line">maxLen = Math.max(maxLen, r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runtime: 3ms.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-3-longest-substring-without-repeating-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-3-longest-substring-without-repeating-characters&quot;&gt;&lt;/a&gt; LeetCode Q 3 - Longest Substring Without Repeating Characters&lt;/h1&gt;
&lt;p&gt;Given a string, find the length of the &lt;strong&gt;longest substring&lt;/strong&gt; without repeating characters.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Reflection in Java</title>
    <link href="http://yoursite.com/2019/04/16/reflection-in-java/"/>
    <id>http://yoursite.com/2019/04/16/reflection-in-java/</id>
    <published>2019-04-17T02:13:50.000Z</published>
    <updated>2019-04-17T02:14:50.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="reflection-in-java-to-be-continued"><a class="markdownIt-Anchor" href="#reflection-in-java-to-be-continued"></a> Reflection in Java (to be continued)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;reflection-in-java-to-be-continued&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#reflection-in-java-to-be-continued&quot;&gt;&lt;/a&gt; Reflection in Java 
      
    
    </summary>
    
    
      <category term="Java Baisc" scheme="http://yoursite.com/tags/Java-Baisc/"/>
    
      <category term="Reflection" scheme="http://yoursite.com/tags/Reflection/"/>
    
  </entry>
  
  <entry>
    <title>synchronized Keyword in Java</title>
    <link href="http://yoursite.com/2019/04/16/synchronized-keyword-java/"/>
    <id>http://yoursite.com/2019/04/16/synchronized-keyword-java/</id>
    <published>2019-04-17T01:31:26.000Z</published>
    <updated>2019-04-17T02:11:09.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-introduction"><a class="markdownIt-Anchor" href="#1-introduction"></a> 1. Introduction</h2><p> The synchronized keyword is all about different threads reading and writing to the same variables, objects and resources. This is not a trivial topic in Java, but here is a quote from Sun:</p><blockquote style="text-align:justify;background-color: #ccfff5">&emsp;synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object's variables are done through synchronized methods.</blockquote><p> In a very, very small nutshell: When you have two threads that are reading and writing to the same ‘resource’.</p><a id="more"></a><h2 id="2-usage"><a class="markdownIt-Anchor" href="#2-usage"></a> 2. Usage</h2><p>The synchronized keyword can be used on different levels:</p><ul><li><strong>Instance methods</strong></li><li><strong>Static methods</strong></li><li><strong>Code blocks</strong></li></ul><p> When we use a synchronized block, internally Java uses a monitor also known as monitor lock or intrinsic lock, to provide synchronization. These monitors are bound to an object, thus all synchronized blocks of the same object can have only one thread executing them at the same time.</p><h3 id="21-synchronized-instantce-method"><a class="markdownIt-Anchor" href="#21-synchronized-instantce-method"></a> 2.1 synchronized instantce method</h3><p> Simply add the synchronized keyword in the method declaration to make the method synchronized:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronisedCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setSum(getSum() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table bgcolor="#ccf2ff" "><td style="font-weight: bold;">&emsp;Instance methods are synchronized over the instance of the class owning the method. Which means only one thread per instance of the class can execute this method.</td></table><h3 id="22-synchronized-static-method"><a class="markdownIt-Anchor" href="#22-synchronized-static-method"></a> 2.2 synchronized static method</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synchronisedCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">setSum(getSum() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table bgcolor="#ccf2ff" "><td style="font-weight: bold;">&emsp;These methods are synchronized on the Class object associated with the class and since only one Class object exists per JVM per class, only one thread can execute inside a static synchronized method per class, irrespective of the number of instances it has.</td></table><h3 id="23-synchronized-blocks-within-methods"><a class="markdownIt-Anchor" href="#23-synchronized-blocks-within-methods"></a> 2.3 synchronized blocks within methods</h3><p> Sometimes we do not want to synchronize the entire method but only some instructions within it. This can be achieved by applying synchronized to a block:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performSynchrinisedTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">setCount(getCount()+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table bgcolor="#ccf2ff" "><td style="font-weight: bold;">&emsp;Notice, that we passed a parameter this to the synchronized block. This is the monitor object, the code inside the block get synchronized on the monitor object. Simply put, only one thread per monitor object can execute inside that block of code.</td></table><p>In case the method is <em>static</em>, we would <strong>pass class name</strong> in place of the object reference. And the class would be a monitor for synchronization of the block:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performStaticSyncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SynchronisedBlocks.class) &#123;</span><br><span class="line">setStaticCount(getStaticCount() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-introduction&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-introduction&quot;&gt;&lt;/a&gt; 1. Introduction&lt;/h2&gt;
&lt;p&gt; The synchronized keyword is all about different threads reading and writing to the same variables, objects and resources. This is not a trivial topic in Java, but here is a quote from Sun:&lt;/p&gt;
&lt;blockquote style=&quot;text-align:justify;background-color: #ccfff5&quot;&gt;
&amp;emsp;synchronized methods enable a simple strategy for preventing thread interference and memory consistency errors: if an object is visible to more than one thread, all reads or writes to that object&#39;s variables are done through synchronized methods.
&lt;/blockquote&gt;
&lt;p&gt; In a very, very small nutshell: When you have two threads that are reading and writing to the same ‘resource’.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="http://yoursite.com/tags/Java-Basic/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java Thread - Commonly Used Methods - java.lang.Object Class</title>
    <link href="http://yoursite.com/2019/04/16/java-lang-object-method/"/>
    <id>http://yoursite.com/2019/04/16/java-lang-object-method/</id>
    <published>2019-04-17T00:21:17.000Z</published>
    <updated>2019-04-17T01:14:29.030Z</updated>
    
    <content type="html"><![CDATA[<p><font size="+1"><code>wait()</code> and <code>notify()</code> method is in java.lang.Object Class</font><br><strong><font color="#06bcf9">Why they are in java.lang.Object Class rather than in java.lang.Thread Class?</font></strong></p><table bgcolor="#ccf2ff" "><td>&emsp;The threads are the things accessing the data structure. The locks are on the data structure object in order to keep the threads from accessing the data structure in an unsafe way.<br>&emsp;In Java, we use lock objects as synchronization, mutex, and communication points between threads. We <span style="font-weight: bold;">synchronize on a lock object</span> to get mutex access to an important code block and to synchronize memory. We <span style="font-weight: bold;">wait on an object</span> if we are waiting for some condition to change – some resource to become available. We <span style="font-weight: bold;">notify on an object</span> if we want to awaken sleeping threads.</td></table><a id="more"></a><h2 id="1-nofity-javalangobject"><a class="markdownIt-Anchor" href="#1-nofity-javalangobject"></a> 1. nofity() – java.lang.Object</h2><p><strong><code>public final void notify()</code></strong><br> Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.<br> The awakened thread will not be able to proceed until the current thread <strong>relinquishes the lock on this object</strong>. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread <strong>enjoys no reliable privilege or disadvantage</strong> in being the next thread to lock this object.</p><p> This method should only <strong>be called by a thread that is the owner of this object’s monitor</strong>. A thread becomes the owner of the object’s monitor in one of three ways:</p><ul><li>By executing a synchronized instance method of that object.</li><li>By executing the body of a synchronized statement that synchronizes on the object.</li><li>For objects of type Class, by executing a synchronized static method of that class.<br>Only one thread at a time can own an object’s monitor.</li></ul><p><strong><font color="#06bcf9">Tips:</font></strong></p><table bgcolor="#ccf2ff" "><td><span style="font-weight: bold;">wait() <span style="font-weight: bold;">makes current thread release the lock.</span><br><span style="font-weight: bold;">notify()</span> signals other waiting thread(s) which then try to acquire the lock.</span></td></table><h2 id="2-nofityall-javalangobject"><a class="markdownIt-Anchor" href="#2-nofityall-javalangobject"></a> 2. nofityAll() – java.lang.Object</h2><p><strong><code>public final void notifyAll()</code></strong><br> Wakes up all threads that are waiting on this object’s monitor. A thread waits on an object’s monitor by calling one of the wait methods.</p><h2 id="3-wait-javalangobject"><a class="markdownIt-Anchor" href="#3-wait-javalangobject"></a> 3. wait() – java.lang.Object</h2><p><strong><code>public final void wait(long timeout) throws InterruptedException</code></strong><br> Causes the current thread to <strong>wait</strong> until either another thread invokes the <strong>notify() method or the notifyAll()</strong> method for this object, or <strong>a specified amount of time has elapsed</strong>.<br> <strong>The current thread must own this object’s monitor</strong>.</p><p> This method causes the current thread (call it T) to place itself in the <strong><font size="+1">wait set</font></strong> for this object and then to relinquish any and all synchronization claims on this object. Thread T becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:</p><ul><li>Some other thread invokes the notify method for this object and thread T happens to be arbitrarily chosen as the thread to be awakened.</li><li>Some other thread invokes the notifyAll method for this object.<br>Some other thread interrupts thread T.</li><li>The specified amount of real time has elapsed, more or less. If timeout is zero, however, then real time is not taken into consideration and the thread simply waits until notified.</li><li>The thread T is then removed from the wait set for this object and re-enabled for thread scheduling. It then competes in the usual manner with other threads for the right to synchronize on the object; once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the wait method was invoked. Thread T then returns from the invocation of the wait method. Thus, on return from the wait method, the synchronization state of the object and of thread T is exactly as it was when the wait method was invoked.</li></ul><p> If the current thread is interrupted by any thread before or while it is waiting, then an <strong>InterruptedException</strong> is thrown. This exception is not thrown until the lock status of this object has been restored as described above.</p><p><font color="tomato" size="+1">Note that the wait method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.<br>This method should only be called by a thread that is the owner of this object’s monitor.</font></p><p><strong><font color="#06bcf9">For example:</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// locks should be final objects so the object we are synchronizing on never changes</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// ensure that the thread has a mutex lock on some key code</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// i need to wait for other threads to finish with some resource</span></span><br><span class="line"><span class="comment">// this releases the lock and waits on the associated monitor</span></span><br><span class="line">lock.wait();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// i need to signal another thread that some state has changed and they can awake and continue to run </span></span><br><span class="line">lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font size=&quot;+1&quot;&gt;&lt;code&gt;wait()&lt;/code&gt; and &lt;code&gt;notify()&lt;/code&gt; method is in java.lang.Object Class&lt;/font&gt;&lt;br&gt;
&lt;strong&gt;&lt;font color=&quot;#06bcf9&quot;&gt;Why they are in java.lang.Object Class rather than in java.lang.Thread Class?&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table bgcolor=&quot;#ccf2ff&quot; &quot;&gt;
	&lt;td&gt;
	&amp;emsp;The threads are the things accessing the data structure. The locks are on the data structure object in order to keep the threads from accessing the data structure in an unsafe way.&lt;br&gt;
	&amp;emsp;In Java, we use lock objects as synchronization, mutex, and communication points between threads. We &lt;span style=&quot;font-weight: bold;&quot;&gt;synchronize on a lock object&lt;/span&gt; to get mutex access to an important code block and to synchronize memory. We &lt;span style=&quot;font-weight: bold;&quot;&gt;wait on an object&lt;/span&gt; if we are waiting for some condition to change – some resource to become available. We &lt;span style=&quot;font-weight: bold;&quot;&gt;notify on an object&lt;/span&gt; if we want to awaken sleeping threads.
	&lt;/td&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="http://yoursite.com/tags/Java-Basic/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Find Right Interval</title>
    <link href="http://yoursite.com/2019/04/16/leetcodeQ436/"/>
    <id>http://yoursite.com/2019/04/16/leetcodeQ436/</id>
    <published>2019-04-16T18:03:52.000Z</published>
    <updated>2019-04-16T18:24:12.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-436-find-right-interval"><a class="markdownIt-Anchor" href="#leetcode-q-436-find-right-interval"></a> LeetCode Q 436 - Find Right Interval</h1><p>Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.<br>For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Comparator&lt;<span class="keyword">int</span>[]&gt; comparator = <span class="keyword">new</span> Comparatro&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] != b[<span class="number">1</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>]; <span class="comment">// order the pos in ascending order</span></span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">2</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">// start point comes first</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findRightInterval(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length];</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; points = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// we store the left point and right point of the interval seperately, and use an array to wrap it.</span></span><br><span class="line"><span class="comment">// int[0]: index; int[1]: left / right pos; int[2]: an indecator, 1 - left point, -1 - right point.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">points.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, intervals[i][<span class="number">0</span>], <span class="number">1</span>&#125;); <span class="comment">// left point</span></span><br><span class="line">points.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, intervals[i][<span class="number">0</span>], <span class="number">1</span>&#125;); <span class="comment">// right point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(points, comparator);</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; pq = PriorityQueue&lt;&gt;(comparator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = points.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span>[] point = points.get(i);</span><br><span class="line"><span class="keyword">if</span> (point[<span class="number">2</span>] == <span class="number">1</span>) &#123;<span class="comment">// it's a left point</span></span><br><span class="line">pq.offer(point);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pq.size() == <span class="number">0</span>) <span class="comment">// no right point</span></span><br><span class="line">res[point[<span class="number">0</span>]] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// find the smallest right point</span></span><br><span class="line">res[point[<span class="number">0</span>]] = pq.peek()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-436-find-right-interval&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-436-find-right-interval&quot;&gt;&lt;/a&gt; LeetCode Q 436 - Find Right Interval&lt;/h1&gt;
&lt;p&gt;Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i.&lt;br&gt;
For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sweep Line" scheme="http://yoursite.com/tags/Sweep-Line/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>The Skyline Problem</title>
    <link href="http://yoursite.com/2019/04/16/leetcodeQ218/"/>
    <id>http://yoursite.com/2019/04/16/leetcodeQ218/</id>
    <published>2019-04-16T17:31:46.000Z</published>
    <updated>2019-04-16T18:09:35.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-218-the-skyline-problem"><a class="markdownIt-Anchor" href="#leetcode-q-218-the-skyline-problem"></a> LeetCode Q 218 - The Skyline Problem</h1><p>A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><ul><li>When you reach a start point, the height of current building immediately takes effect which means it could possibly affect the contour or shadow others when mixed with other following buildings;</li><li>When you reach a end point, the height of current building will stop its influences;</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getSkyline(<span class="keyword">int</span>[][] buildings) &#123;</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; heights = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// we store the left and right heights seperately!</span></span><br><span class="line"><span class="comment">// in the heights, the int[] has size 2. </span></span><br><span class="line"><span class="comment">// int[0]: l / r position; int[1]: height</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] building: buildings) &#123;</span><br><span class="line">heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;building[<span class="number">0</span>], -building[<span class="number">2</span>]&#125;); <span class="comment">// neg value indicates it's left point;</span></span><br><span class="line">heights.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;building[<span class="number">1</span>], building[<span class="number">2</span>]&#125;); <span class="comment">// pos value indicates it's right point;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort the list in ascending order</span></span><br><span class="line"><span class="comment">// for example [2, 9, 10], [2, 9, 15], we want [2, -15], [2, -10], [9, 10], [9, 15];</span></span><br><span class="line">Collections.sort(heights, (a, b) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] != b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pq is used to store the height value, we want the larger one comes first.</span></span><br><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (b - a));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> prev = <span class="number">0</span>; pq.offer(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] arr: heights) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>] &lt; <span class="number">0</span>) <span class="comment">// indicates a left point, we offer the height value into the queue</span></span><br><span class="line">pq.offer(-arr[<span class="number">1</span>]); <span class="comment">// since we want it to impact others</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="number">1</span>] &gt; <span class="number">0</span>) <span class="comment">// indicates a right point, remove the height value from the queue</span></span><br><span class="line">pq.remove(arr[<span class="number">1</span>]); <span class="comment">// since we want that height value to stop its influence</span></span><br><span class="line"><span class="keyword">int</span> curr = pq.peek();</span><br><span class="line"><span class="keyword">if</span> (curr != prev) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;arr[<span class="number">0</span>], curr&#125;);</span><br><span class="line">prev = curr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-218-the-skyline-problem&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-218-the-skyline-problem&quot;&gt;&lt;/a&gt; LeetCode Q 218 - The Skyline Problem&lt;/h1&gt;
&lt;p&gt;A city’s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sweep Line" scheme="http://yoursite.com/tags/Sweep-Line/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>Is Subsequence</title>
    <link href="http://yoursite.com/2019/04/16/leetcodeQ392/"/>
    <id>http://yoursite.com/2019/04/16/leetcodeQ392/</id>
    <published>2019-04-16T17:10:15.000Z</published>
    <updated>2019-04-16T17:49:53.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-392-is-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-392-is-subsequence"></a> LeetCode Q 392 - Is Subsequence</h1><p>Given a string s and a string t, check if s is subsequence of t.<br>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length is about  500,000) string, and s is a short string (&lt;=100).<br><strong>Follow up:</strong><br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="1-solution-1"><a class="markdownIt-Anchor" href="#1-solution-1"></a> 1. Solution 1</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length() &gt; t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; t.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) i++;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i == s.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length() &gt; t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = t.indexOf(s.charAt(i));</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">t = t.substring(index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-solution-of-follow-up-question"><a class="markdownIt-Anchor" href="#2-solution-of-follow-up-question"></a> 2. Solution of Follow Up Question</h3><table bgcolor="#ccf2ff" "><td>&emsp;If we check each s in this way, then it would be O(kn) time where k is the number of s and n is the length of t. This is inefficient. <br> &emsp;Since there is a lot of s, it would be reasonable to preprocess t to generate something that is easy to search for if a character of s is in t. Sounds like a HashMap, which is super suitable for search for existing stuff. </td></table><ol><li><p>Build a map, key is the char in String t, value is a list contianing the index of the char in t.</p></li><li><p>Use binary search to find if each char in String s exists in t.</p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">map.putIfAbsent(t.charAt(i), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">map.get(t.charAt(i)).add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) &#123;</span><br><span class="line">prev = binarySearch(map, ch, prev);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">prev++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Map&lt;Character, List&lt;Integer&gt;&gt; map, <span class="keyword">char</span> ch, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(ch)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">List&lt;Integer&gt; list = map.get(ch);</span><br><span class="line"><span class="keyword">int</span> lo = <span class="number">0</span>, hi = list.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (list.get(mid) &lt; index)</span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lo == list.size() ? -<span class="number">1</span> : list.get(lo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-392-is-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-392-is-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 392 - Is Subsequence&lt;/h1&gt;
&lt;p&gt;Given a string s and a string t, check if s is subsequence of t.&lt;br&gt;
You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length is about  500,000) string, and s is a short string (&amp;lt;=100).&lt;br&gt;
&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;br&gt;
If there are lots of incoming S, say S1, S2, … , Sk where k &amp;gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Kth Smallest Element in a Sorted Matrix</title>
    <link href="http://yoursite.com/2019/04/16/leetcodeQ378/"/>
    <id>http://yoursite.com/2019/04/16/leetcodeQ378/</id>
    <published>2019-04-16T16:13:03.000Z</published>
    <updated>2019-04-16T17:09:30.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-378-kth-smallest-element-in-a-sorted-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-378-kth-smallest-element-in-a-sorted-matrix"></a> LeetCode Q 378 - Kth Smallest Element in a Sorted Matrix</h1><p>Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.<br><strong>Note</strong> that it is the kth smallest element in the sorted order, not the kth distinct element.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-heap"><a class="markdownIt-Anchor" href="#solution-1-heap"></a> Solution 1: Heap</h3><ol><li>we offer the numbers in the first row to the que.</li><li>we do the following k - 1 times: Poll a number and offer the number below it to the que if it has.</li><li>the value of the first item in the queue is the answer</li></ol><p><strong><font color="#06bcf9">Time Complexity: O(klogn)</font></strong><br><strong><font color="#06bcf9">Space Complexity: O(n)</font></strong><br><strong>k</strong>: how many times we do the loop.   <strong>n</strong>: matrix row no.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// int[] arr = &#123;val, row, col&#125;;</span></span><br><span class="line">Queue&lt;\<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++) </span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[<span class="number">0</span>]\[i], <span class="number">0</span>, i&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span> (k != <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>[] temp = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (temp[<span class="number">1</span>] + <span class="number">1</span> &lt; matrix.length)</span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;matrix[temp[<span class="number">1</span>] + <span class="number">1</span>][temp[<span class="number">2</span>]], temp[<span class="number">1</span>] + <span class="number">1</span>, temp[<span class="number">2</span>]&#125;);</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> pq.peek()[<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-binary-search"><a class="markdownIt-Anchor" href="#solution-2-binary-search"></a> Solution 2: Binary Search</h3><ol><li>choose matrix[0][0] as left and matrix[n-1][n-1] as right, and get the mid.</li><li>count the number of numbers less or equal to mid.</li></ol><ul><li><code>if (number &lt; k)</code>: this mid is smaller than the target, so we let <code>left = mid + 1</code>;</li><li><code>if (number &gt; k)</code>: this mid is larget than the target, so we let <code>right = mid - 1</code>;</li><li><strong><code>if (number == k)</code></strong>: there exists two cases. 1) this mid may be the target 2) this mid is not in the matrix and larger than the target<br><strong>Then we keep shrinking the range, let <code>right = mid - 1</code>, this guarantees left is the kthSmallest</strong></li></ul><p><strong><font color="#06bcf9">Time Complexity: O(logRange*nlogn)</font></strong><br>Every time we call the count method, it costs <strong>O(nlogn)</strong> time.<br>The maximum range is Integer.MAX_VALUE - Integer.MIN_VALUE = 2^23 - 1. So logRange is no more than 32, which can be regarded as a constant.<br>So the <strong>time complexity if O(nlogn)</strong>.<br><strong><font color="#06bcf9">Space Complexity: O(1)</font></strong><br><strong>k</strong>: how many times we do the loop.   <strong>n</strong>: matrix row no.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = matrix.length, left = matrix[<span class="number">0</span>]\[<span class="number">0</span>], right = matrix[n-<span class="number">1</span>]\[n-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = countLessEqual(matrix, mid, n);</span><br><span class="line"><span class="keyword">if</span> (count &lt; k)</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// mid &gt;= k</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLessEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] numbers: matris) &#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (numbers[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">res += left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-3-optimized-solution-based-on-solution-2"><a class="markdownIt-Anchor" href="#solution-3-optimized-solution-based-on-solution-2"></a> Solution 3: Optimized Solution based on Solution 2</h3><p>We <strong>optimize</strong> the countLessEqual Method. This method is similar to <a href="/2019/04/14/leetcodeQ240/" title="Search a 2D Matrix II">Search a 2D Matrix II</a>.</p><p><strong><font color="#06bcf9">Time Complexity: O(n)</font></strong><br><strong><font color="#06bcf9">Space Complexity: O(1)</font></strong><br><strong>k</strong>: how many times we do the loop.   <strong>n</strong>: matrix row no.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = matrix.length, left = matrix[<span class="number">0</span>]\[<span class="number">0</span>], right = matrix[n-<span class="number">1</span>]\[n-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = countLessEqual(matrix, mid, n);</span><br><span class="line"><span class="keyword">if</span> (count &lt; k)</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// mid &gt;= k</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLessEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> row = <span class="number">0</span>, col = n - <span class="number">1</span>;</span><br><span class="line">whiel (left &lt; n &amp;&amp; col &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[row]\[col] &lt;= target) &#123;</span><br><span class="line">res += col + <span class="number">1</span>; row++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">col--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#06bcf9">Comparison of time complexities of Solution 1 and Solution3:</font></strong></p><table bgcolor="#ccf2ff" "><tr style="font-weight: bold;"><th>k</th><th>O(1)</th><th>O(n)</th><th>O(n^2)</th></tr><tr><td style="font-weight: bold;">Solution 1:</td><td>logn</td><td>nlogn</td><td>n^2*logn</td></tr><tr><td style="font-weight: bold;">Solution 3:</td><td>n</td><td>n</td><td>n</td></tr></table><p><strong><font color="tomato">When k is constant, Solution 1 is better. Otherwise Solution 2 is better.</font></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-378-kth-smallest-element-in-a-sorted-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-378-kth-smallest-element-in-a-sorted-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 378 - Kth Smallest Element in a Sorted Matrix&lt;/h1&gt;
&lt;p&gt;Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt; that it is the kth smallest element in the sorted order, not the kth distinct element.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>Guess Number Higher or Lower</title>
    <link href="http://yoursite.com/2019/04/16/leetcodeQ374/"/>
    <id>http://yoursite.com/2019/04/16/leetcodeQ374/</id>
    <published>2019-04-16T16:01:31.000Z</published>
    <updated>2019-04-16T16:12:23.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-374-guess-number-higher-or-lower"><a class="markdownIt-Anchor" href="#leetcode-q-374-guess-number-higher-or-lower"></a> LeetCode Q 374 - Guess Number Higher or Lower</h1><p>We are playing the Guess Game. The game is as follows:<br>I pick a number from 1 to n. You have to guess which number I picked.<br>Every time you guess wrong, I’ll tell you whether the number is higher or lower.<br>You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):<br><code>-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it!</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span></span><br><span class="line"><span class="comment">@param num, your guess</span></span><br><span class="line"><span class="comment">@return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="comment">int guess(int num); \*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (guess(mid) == <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (guess(mid) == -<span class="number">1</span>) right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-374-guess-number-higher-or-lower&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-374-guess-number-higher-or-lower&quot;&gt;&lt;/a&gt; LeetCode Q 374 - Guess Number Higher or Lower&lt;/h1&gt;
&lt;p&gt;We are playing the Guess Game. The game is as follows:&lt;br&gt;
I pick a number from 1 to n. You have to guess which number I picked.&lt;br&gt;
Every time you guess wrong, I’ll tell you whether the number is higher or lower.&lt;br&gt;
You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):&lt;br&gt;
&lt;code&gt;-1 : My number is lower 1 : My number is higher 0 : Congrats! You got it!&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Length of Repeated Subarray</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ718/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ718/</id>
    <published>2019-04-15T20:40:57.000Z</published>
    <updated>2019-04-15T20:56:55.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-718-maximum-length-of-repeated-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-718-maximum-length-of-repeated-subarray"></a> LeetCode Q 718 - Maximum Length of Repeated Subarray</h1><p>Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.<br><strong>Note:</strong></p><ol><li>&lt;= len(A), len(B) &lt;= 1000</li><li>&lt;= A[i], B[i] &lt; 100</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Since a common subarray of A and B must start at some A[i] and B[j], let <code>dp[i][j]</code> be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know <code>dp[i][j] = dp[i-1][j-1] + 1</code>. Also, the answer is <code>maxLen(dp[i][j]</code>) over all i, j.</p><p><strong>Time Complexity:</strong> O(M * N);</p><p><strong>Space Complexity:</strong> O(M * N);</p><p><strong>M, N</strong>: length of A, B</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][B.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; i &lt; dp[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) </span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">res = Math.max(res, dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="an-optimized-solution"><a class="markdownIt-Anchor" href="#an-optimized-solution"></a> An Optimized Solution</h3><p>We can <strong>optimize the space complexity.</strong><br><code>dp[i][j] = dp[i-1][j-1] + 1</code> --&gt; <code>maxLen[i][j]</code> only depends on <code>maxLen[i-1][j-1]</code>, so you only need to keep <code>maxLen[i-1][j-1]</code> which is one element.<br>Therefore, we use maxLenTemp to keep <code>maxLen[i-1][j-1]</code> and traverse the matrix diagonally.</p><p><strong>Time Complexity:</strong> O(M * N);</p><p><strong>Space Complexity:</strong> O(1);</p><p><strong>M, N</strong>: length of A, B</p><p><strong>Code: Optimzed Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxLenTemp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>, n = i; m &lt; A.length &amp;&amp; n &lt; B.length; m++, n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[m] == B[n]) &#123;</span><br><span class="line">maxLenTemp++;</span><br><span class="line">res = Math.max(res, maxLenTemp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLenTemp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> maxLenTemp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = i, n = <span class="number">0</span>; m &lt; A.length &amp;&amp; n &lt; B.length; m++, n++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[m] == B[n]) &#123;</span><br><span class="line">maxLenTemp++;</span><br><span class="line">res = Math.max(res, maxLenTemp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">maxLenTemp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-718-maximum-length-of-repeated-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-718-maximum-length-of-repeated-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 718 - Maximum Length of Repeated Subarray&lt;/h1&gt;
&lt;p&gt;Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;lt;= len(A), len(B) &amp;lt;= 1000&lt;/li&gt;
&lt;li&gt;&amp;lt;= A[i], B[i] &amp;lt; 100&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Linked List Cycle II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ142/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ142/</id>
    <published>2019-04-15T19:52:15.000Z</published>
    <updated>2019-04-15T20:09:17.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-142-linked-list-cycle-ii"><a class="markdownIt-Anchor" href="#leetcode-q-142-linked-list-cycle-ii"></a> LeetCode Q 142 - Linked List Cycle II</h1><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p><p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">ListNode slow = head, fast = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line"><span class="keyword">if</span> (slow == fast)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (head != slow) &#123;</span><br><span class="line">    head = head.next;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-142-linked-list-cycle-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-142-linked-list-cycle-ii&quot;&gt;&lt;/a&gt; LeetCode Q 142 - Linked List Cycle II&lt;/h1&gt;
&lt;p&gt;Given a linked list, return the node where the cycle begins. If there is no cycle, return null.&lt;/p&gt;
&lt;p&gt;To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Do not modify the linked list.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Find the Duplicate Number</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ287/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ287/</id>
    <published>2019-04-15T19:34:50.000Z</published>
    <updated>2019-04-16T16:17:25.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-287-find-the-duplicate-number"><a class="markdownIt-Anchor" href="#leetcode-q-287-find-the-duplicate-number"></a> LeetCode Q 287 - Find the Duplicate Number</h1><p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p><strong>Note</strong>:<br>You <strong>must not</strong> modify the array (assume the array is read only).<br>You must use only constant, <strong>O(1) extra space</strong>.<br>Your runtime complexity should be less than O(n^2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1"><a class="markdownIt-Anchor" href="#method-1"></a> Method 1:</h3><p>We traverse the array, we regard each number in the array as the position, then we mark the number in that position to be negative. Then if the number in that position has already been nagetive, that means we have already visited that position. Then we find the duplicates.</p><p>For example,<br>array: [1, 3, 4, 2, 2]</p><ul><li>visit 1st number (i.e. 1), change the number in position 1 to be netaetive, then the array becomes [-1, 3, 4, 2, 2]</li><li>visit 2nd number (i.e. 3), change the number in position 3 to be netaetive, then the array becomes [-1, 3, -4, 2, 2]</li><li>visit 3rd number (i.e. 4), change the number in position 4 to be netaetive, then the array becomes [-1, 3, -4, -2, 2]</li><li>visit 4th number (i.e. 2), change the number in position 2 to be netaetive, then the array becomes [-1, -3, -4, -2, 2]</li><li>visit 5th number (i.e. 2), we find the number in position 2 is negative, then 2 is the duplicates we want to find.</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[Math.abs(nums[i]) - <span class="number">1</span>] &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> Math.abs(nums[i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">nums[Math.abs(nums[i]) - <span class="number">1</span>] \*= -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">num = Math.abs(num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2"><a class="markdownIt-Anchor" href="#method-2"></a> Method 2:</h3><p>This solution is similar to find the solution of the node where the cycle begins. This question can be found in <a href="/2019/04/15/leetcodeQ142/" title="Linked List Cycle II">Linked List Cycle II</a></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>], fast = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">slow = nums[slow];</span><br><span class="line">fast = nums[nums[fast]];</span><br><span class="line">&#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pointer1 = nums[<span class="number">0</span>], pointer2 = slow;</span><br><span class="line"><span class="keyword">while</span> (pointer1 != pointer2) &#123;</span><br><span class="line">pointer1 = nums[pointer1];</span><br><span class="line">pointer2 = nums[pointer2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pointer1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-3-binary-search"><a class="markdownIt-Anchor" href="#method-3-binary-search"></a> Method 3: Binary Search</h3><p>At first the search space is numbers between 1 to n. Each time I select a number mid (which is the one in the middle) and count all the numbers equal to or less than mid. Then if the count is more than mid, the search space will be [1 mid] otherwise [mid+1 n]. I do this until search space is only one number.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= mid) count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count &lt;= mid) </span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">right = mid; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-287-find-the-duplicate-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-287-find-the-duplicate-number&quot;&gt;&lt;/a&gt; LeetCode Q 287 - Find the Duplicate Number&lt;/h1&gt;
&lt;p&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;br&gt;
You &lt;strong&gt;must not&lt;/strong&gt; modify the array (assume the array is read only).&lt;br&gt;
You must use only constant, &lt;strong&gt;O(1) extra space&lt;/strong&gt;.&lt;br&gt;
Your runtime complexity should be less than O(n^2).&lt;br&gt;
There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>First Bad Version</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ278/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ278/</id>
    <published>2019-04-15T19:27:50.000Z</published>
    <updated>2019-04-15T19:33:43.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-278-first-bad-version"><a class="markdownIt-Anchor" href="#leetcode-q-278-first-bad-version"></a> LeetCode Q 278 - First Bad Version</h1><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p><p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p><p>You are given an API <code>boolean isBadVersion(version)</code> which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">// `boolean isBadVersion(int version)`; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = n;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (isBadVersion(mid))</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-278-first-bad-version&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-278-first-bad-version&quot;&gt;&lt;/a&gt; LeetCode Q 278 - First Bad Version&lt;/h1&gt;
&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;
&lt;p&gt;Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;
&lt;p&gt;You are given an API &lt;code&gt;boolean isBadVersion(version)&lt;/code&gt; which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>H-Index II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ275/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ275/</id>
    <published>2019-04-15T19:17:17.000Z</published>
    <updated>2019-04-15T19:27:31.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-275-h-index-ii"><a class="markdownIt-Anchor" href="#leetcode-q-275-h-index-ii"></a> LeetCode Q 275 - H-Index II</h1><p>Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is to search for the first index from the sorted array so that :<br>citations[index] &gt;= length(citations) - index.<br>And return (length - index) as the result.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = citations.length - <span class="number">1</span>, len = citations.length;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;  <span class="comment">//  (left &lt; right) --&gt; [0, 0] won't pass </span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (citations[mid] == len - mid)</span><br><span class="line"><span class="keyword">return</span> len - mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &lt; len - mid)</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len - left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-275-h-index-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-275-h-index-ii&quot;&gt;&lt;/a&gt; LeetCode Q 275 - H-Index II&lt;/h1&gt;
&lt;p&gt;Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Merge k Sorted Lists</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ23/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ23/</id>
    <published>2019-04-15T18:33:17.000Z</published>
    <updated>2019-04-15T19:14:21.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-23-merge-k-sorted-lists"><a class="markdownIt-Anchor" href="#leetcode-q-23-merge-k-sorted-lists"></a> LeetCode Q 23 - Merge k Sorted Lists</h1><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><em><strong>k</strong></em>: number of sorted linked lists;<br><em><strong>N</strong></em>: Total number of nodes in all k linked lists.</p><h3 id="method-1-heap-sort"><a class="markdownIt-Anchor" href="#method-1-heap-sort"></a> Method 1: Heap Sort</h3><p><strong>Time Complexity: O(Nlogk)</strong></p><p>The comparison cost will be reduced to O(log k) for every pop and insertion to priority queue. But finding the node with the smallest value just costs O(1) time.</p><p><strong>Space Complexity: O(N) + O(k)</strong></p><p>O(N): Creating a new linked list costs space, i.e. the result.<br>O(k): Build heap.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// build the heap</span></span><br><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a.val - b.val));</span><br><span class="line"><span class="keyword">for</span> (ListNode node: lists) &#123;</span><br><span class="line"><span class="keyword">if</span> (node != <span class="keyword">null</span>) pq.offer(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), prev = dummy;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">ListNode temp = pq.poll();</span><br><span class="line">prev.next = temp;</span><br><span class="line">prev = temp;</span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) pq.offer(temp.next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-merge-lists-with-divide-and-conquer"><a class="markdownIt-Anchor" href="#method-2-merge-lists-with-divide-and-conquer"></a> Method 2: Merge Lists with Divide And Conquer</h3><p><strong>Time Complexity: O(Nlogk)</strong></p><p>We can merge two sorted linked list in O(n) time, where n is the total number of two lists.<br>Sum up the merge process and we can get O(Nlogk).</p><p><strong>Space Complexity: O(1)</strong><br>No extra space is required.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists == <span class="keyword">null</span> || lists.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">ListNode node1 = merge(lists, left, mid);</span><br><span class="line">ListNode node2 = merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">return</span> mergeHelper(node1, node2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeHelper</span><span class="params">(ListNode node1, ListNode node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) <span class="keyword">return</span> node2;</span><br><span class="line">    <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) <span class="keyword">return</span> node1;</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>), prev = dummy;</span><br><span class="line">    <span class="keyword">while</span> (node1 != <span class="keyword">null</span> &amp;&amp; node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node1.val &lt; node2.val) &#123;</span><br><span class="line">            prev.next = node1;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            node1 = node1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = node2;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">            node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) prev.next = node2;</span><br><span class="line">    <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) prev.next = node1;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-23-merge-k-sorted-lists&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-23-merge-k-sorted-lists&quot;&gt;&lt;/a&gt; LeetCode Q 23 - Merge k Sorted Lists&lt;/h1&gt;
&lt;p&gt;Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Merge Sort" scheme="http://yoursite.com/tags/Merge-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Intersection of Two Arrays II</title>
    <link href="http://yoursite.com/2019/04/15/leetcodeQ350/"/>
    <id>http://yoursite.com/2019/04/15/leetcodeQ350/</id>
    <published>2019-04-15T17:14:04.000Z</published>
    <updated>2019-04-15T18:44:55.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-350-intersection-of-two-arrays-ii"><a class="markdownIt-Anchor" href="#leetcode-q-350-intersection-of-two-arrays-ii"></a> LeetCode Q 350 - Intersection of Two Arrays II</h1><p>Given two arrays, write a function to compute their intersection.<br><strong>Note:</strong></p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><p><strong>Follow up:</strong></p><ul><li>What if the given array is already sorted? How would you optimize your algorithm?</li><li>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?</li><li>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sort-two-pointers"><a class="markdownIt-Anchor" href="#method-1-sort-two-pointers"></a> Method 1: Sort + Two Pointers</h3><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Arrays.sort(nums1); Arrays.sort(nums2);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">            list.add(nums1[i]);</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: list) &#123;</span><br><span class="line">        res[index++] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-hashmap"><a class="markdownIt-Anchor" href="#method-2-hashmap"></a> Method 2: HashMap</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums1) &#123;</span><br><span class="line">        map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: nums2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(num) &amp;&amp; map.get(num) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(num);</span><br><span class="line">            map.put(num, map.get(num) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num: list) </span><br><span class="line">        res[index++] = num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-to-3rd-follow-up-question"><a class="markdownIt-Anchor" href="#solution-to-3rd-follow-up-question"></a> Solution to 3rd follow-up question:</h3><ul><li><p>If only nums2 cannot fit in memory, put all elements of nums1 into a HashMap, read chunks of array that fit into the memory, and record the intersections.</p></li><li><p>If both nums1 and nums2 are so huge that neither fit into the memory, sort them individually (external sort), then read 2 elements from each array at a time in memory, record intersections.</p></li></ul><p>It is a classical question in database perspective. External sort is a trick used to implement <code>JOIN</code>, basically called sort-merge join. A detailed explanation of <strong>External sorting</strong> can be found in <a href="https://en.wikipedia.org/wiki/External_sorting" target="_blank" rel="noopener">wekipedia</a>.</p><ul><li><p><strong>External sorting</strong> is a class of sorting algorithms that can handle massive amounts of data. External sorting is required when the data being sorted do not fit into the main memory of a computing device (usually RAM) and instead they must reside in the slower external memory, usually a hard disk drive. Thus, external sorting algorithms are external memory algorithms and thus applicable in the external memory model of computation.</p></li><li><p>External sorting algorithms generally fall into two types, <strong>distribution sorting</strong>, which resembles quicksort, and <strong>external merge sort</strong>, which resembles merge sort. The latter typically uses a hybrid sort-merge strategy. In the sorting phase, chunks of data small enough to fit in main memory are read, sorted, and written out to a temporary file. In the merge phase, the sorted subfiles are combined into a single larger file.</p></li><li><p>External sorting algorithms can be analyzed in the external memory model. In this model, <strong>a cache or internal memory of size M</strong> and an unbounded external memory are divided into <strong>blocks of size B</strong>, and the running time of an algorithm is determined by the number of memory transfers between internal and external memory. Like their cache-oblivious counterparts, asymptotically optimal external sorting algorithms achieve a running time (in <strong>Big O notation</strong>) of</p></li></ul><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>N</mi><mi>B</mi></mfrac><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mfrac><mi>M</mi><mi>B</mi></mfrac></msub><mfrac><mi>N</mi><mi>B</mi></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{N}{B}O(log_{\frac{M}{B}}\frac{N}{B}) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.734335em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5064649999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p><p>For example, for sorting 900 megabytes of data using only 100 megabytes of RAM:</p><ol><li>Read 100 MB of the data in main memory and sort by some conventional method, like quicksort.</li><li>Write the sorted data to disk.<br>Repeat steps 1 and 2 until all of the data is in sorted 100 MB chunks (there are 900MB / 100MB = 9 chunks), which now need to be merged into one single output file.</li><li>Read the first 10 MB (= 100MB / (9 chunks + 1)) of each sorted chunk into input buffers in main memory and allocate the remaining 10 MB for an output buffer. (In practice, it might provide better performance to make the output buffer larger and the input buffers slightly smaller.)</li><li>Perform a <strong>9-way merge</strong> and store the result in the output buffer. Whenever the output buffer fills, write it to the final sorted file and empty it. Whenever any of the 9 input buffers empties, fill it with the next 10 MB of its associated 100 MB sorted chunk until no more data from the chunk is available. This is the key step that makes external merge sort work externally – because the merge algorithm only makes one pass sequentially through each of the chunks, each chunk does not have to be loaded completely; rather, sequential parts of the chunk can be loaded as needed. We can do the <strong>n-way merge</strong> like <a href="/2019/04/15/leetcodeQ23/" title="Merge k Sorted Lists">Merge k Sorted Lists</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-350-intersection-of-two-arrays-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-350-intersection-of-two-arrays-ii&quot;&gt;&lt;/a&gt; LeetCode Q 350 - Intersection of Two Arrays II&lt;/h1&gt;
&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;/li&gt;
&lt;li&gt;The result can be in any order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if the given array is already sorted? How would you optimize your algorithm?&lt;/li&gt;
&lt;li&gt;What if nums1’s size is small compared to nums2’s size? Which algorithm is better?&lt;/li&gt;
&lt;li&gt;What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
</feed>
