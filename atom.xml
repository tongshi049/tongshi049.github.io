<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TongTong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-16T17:42:05.515Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Increasing Order Search Tree</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ897/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ897/</id>
    <published>2019-07-16T17:33:36.000Z</published>
    <updated>2019-07-16T17:42:05.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-897-increasing-order-search-tree"><a class="markdownIt-Anchor" href="#leetcode-q-897-increasing-order-search-tree"></a> LeetCode Q 897 - Increasing Order Search Tree</h1><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has <strong>no left child and only 1 right child</strong>.</p><p><strong>Note:</strong></p><ul><li>The number of nodes in the given tree will be between 1 and 100.</li><li>Each node will have a unique integer value from 0 to 1000.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><h3 id="soultion-1"><a class="markdownIt-Anchor" href="#soultion-1"></a> Soultion 1:</h3><p><strong>Code:</strong></p><figure class="highlight haxe"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list;</span><br><span class="line"><span class="keyword">public</span> TreeNode increasingBST(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  dfs (root);</span><br><span class="line">  </span><br><span class="line">  TreeNode <span class="keyword">new</span><span class="type">Root</span> = <span class="keyword">new</span> <span class="type">TreeNode</span>(list.<span class="keyword">get</span>(<span class="number">0</span>));</span><br><span class="line">  TreeNode curr = <span class="keyword">new</span><span class="type">Root</span>;</span><br><span class="line">  <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    TreeNode n = <span class="keyword">new</span> <span class="type">TreeNode</span>(list.<span class="keyword">get</span>(i));</span><br><span class="line">    curr.right = n;</span><br><span class="line">    curr = n;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Root</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> void dfs(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  dfs(root.left);</span><br><span class="line">  list.add(root.val);</span><br><span class="line">  dfs(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="soultion-2-more-concise-version"><a class="markdownIt-Anchor" href="#soultion-2-more-concise-version"></a> Soultion 2: More concise version</h3><p><strong>Code:</strong></p><figure class="highlight aspectj"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TreeNode curr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function">TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  </span><br><span class="line">  TreeNode dummy = curr = <span class="keyword">new</span> TreeNode (<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  dfs(root, curr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  dfs(root.left);</span><br><span class="line"></span><br><span class="line">  curr.right = root; </span><br><span class="line">  curr = curr.right;</span><br><span class="line"></span><br><span class="line">  dfs(root.right);</span><br><span class="line"></span><br><span class="line">  root.left = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-897-increasing-order-search-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-897-increasing-order-search-tree&quot;&gt;&lt;/a&gt; LeetCode Q 897 - Increasing Order Search Tree&lt;/h1&gt;
&lt;p&gt;Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has &lt;strong&gt;no left child and only 1 right child&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the given tree will be between 1 and 100.&lt;/li&gt;
&lt;li&gt;Each node will have a unique integer value from 0 to 1000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Complete Binary Tree Inserter</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ919/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ919/</id>
    <published>2019-07-16T17:26:00.000Z</published>
    <updated>2019-07-16T17:32:44.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-919-complete-binary-tree-inserter"><a class="markdownIt-Anchor" href="#leetcode-q-919-complete-binary-tree-inserter"></a> LeetCode Q 919 - Complete Binary Tree Inserter</h1><p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.<br>Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:</p><ul><li><code>CBTInserter(TreeNode root)</code> initializes the data structure on a given tree with head node root;</li><li><code>CBTInserter.insert(int v)</code> will insert a TreeNode into the tree with <code>value node.val = v</code> so that the tree remains complete, and returns the value of the parent of the inserted TreeNode;</li><li><code>CBTInserter.get_root()</code> will return the head node of the tree.</li></ul><p><strong>Example 1:</strong><br><code>Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]</code><br><code>Output: [null,1,[1,2]]</code><br><strong>Example 2:</strong><br><code>Input: inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]</code><br><code>Output: [null,3,4,[1,2,3,4,5,6,7,8]]</code></p><p><strong>Note:</strong></p><ul><li>The initial given tree is complete and contains between 1 and 1000 nodes.</li><li><code>CBTInserter.insert</code> is called at most 10000 times per test case.<br>Every value of a given or inserted node is between 0 and 5000.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><p>First, use <strong>O(n)</strong> time to build a nodesMap, where <em>key</em> is the index and <em>value</em> is the TreeNode.<br>When ever we want to insert a node, we can just use <strong>O(1)</strong> time to lookup that table find its <em>parent</em> and then insert it.</p><p><strong>Code:</strong></p><figure class="highlight pgsql"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="type">Integer</span>, TreeNode&gt; nodesMap;</span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">public</span> CBTInserter(TreeNode root) &#123;</span><br><span class="line">  nodesMap = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line">  buildsMap(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="type">void</span> buildsMap(TreeNode root) &#123;</span><br><span class="line">  Queue&lt;TreeNode&gt; que = <span class="built_in">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  que.offer(root);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">    TreeNode curr = que.poll();</span><br><span class="line">    nodesMap.put(++<span class="keyword">index</span>, curr);</span><br><span class="line">    <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) que.offer(curr.left);</span><br><span class="line">    <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) que.offer(curr.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> <span class="keyword">insert</span>(<span class="type">int</span> v) &#123;</span><br><span class="line">  TreeNode n = <span class="built_in">new</span> TreeNode(v);</span><br><span class="line">  TreeNode p = nodesMap.<span class="keyword">get</span>((++<span class="keyword">index</span>) / <span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) p.left = n;</span><br><span class="line">  <span class="keyword">else</span> p.right = n;</span><br><span class="line">  </span><br><span class="line">  nodesMap.put(<span class="keyword">index</span>, n);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> p.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> TreeNode get_root() &#123;</span><br><span class="line">  <span class="keyword">return</span> nodesMap.<span class="keyword">get</span>(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-919-complete-binary-tree-inserter&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-919-complete-binary-tree-inserter&quot;&gt;&lt;/a&gt; LeetCode Q 919 - Complete Binary Tree Inserter&lt;/h1&gt;
&lt;p&gt;A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.&lt;br&gt;
Write a data structure CBTInserter that is initialized with a complete binary tree and supports the following operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CBTInserter(TreeNode root)&lt;/code&gt; initializes the data structure on a given tree with head node root;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CBTInserter.insert(int v)&lt;/code&gt; will insert a TreeNode into the tree with &lt;code&gt;value node.val = v&lt;/code&gt; so that the tree remains complete, and returns the value of the parent of the inserted TreeNode;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CBTInserter.get_root()&lt;/code&gt; will return the head node of the tree.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1]],[2],[]]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Output: [null,1,[1,2]]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: inputs = [&amp;quot;CBTInserter&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;insert&amp;quot;,&amp;quot;get_root&amp;quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Output: [null,3,4,[1,2,3,4,5,6,7,8]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The initial given tree is complete and contains between 1 and 1000 nodes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CBTInserter.insert&lt;/code&gt; is called at most 10000 times per test case.&lt;br&gt;
Every value of a given or inserted node is between 0 and 5000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Range Sum of BST</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ938/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ938/</id>
    <published>2019-07-16T17:21:36.000Z</published>
    <updated>2019-07-16T17:24:54.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-938-range-sum-of-bst"><a class="markdownIt-Anchor" href="#leetcode-q-938-range-sum-of-bst"></a> LeetCode Q 938 - Range Sum of BST</h1><p>Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).<br>The binary search tree is guaranteed to have unique values.</p><p><strong>Example 1:</strong> <code>Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 ; Output: 32</code><br><strong>Example 2:</strong> <code>Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 ; Output: 23</code></p><p><strong>Note:</strong></p><ul><li>The number of nodes in the tree is at most <code>10000</code>.</li><li>The final answer is guaranteed to be less than <code>2^31</code>.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight axapta"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> rangeSumBST(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">  dfs(root, L, R);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> dfs(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (root.val &gt;= L &amp;&amp; root.val &lt;= R) </span><br><span class="line">      <span class="keyword">sum</span> += root.val;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (L &lt; root.val)</span><br><span class="line">    dfs(root.left, L, R);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (root.val &lt; R)</span><br><span class="line">    dfs(root.right, L, R);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-938-range-sum-of-bst&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-938-range-sum-of-bst&quot;&gt;&lt;/a&gt; LeetCode Q 938 - Range Sum of BST&lt;/h1&gt;
&lt;p&gt;Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).&lt;br&gt;
The binary search tree is guaranteed to have unique values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: root = [10,5,15,3,7,null,18], L = 7, R = 15 ; Output: 32&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10 ; Output: 23&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is at most &lt;code&gt;10000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The final answer is guaranteed to be less than &lt;code&gt;2^31&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor of Deepest Leaves</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ1123/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ1123/</id>
    <published>2019-07-16T16:59:21.000Z</published>
    <updated>2019-07-16T17:20:30.774Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1123-lowest-common-ancestor-of-deepest-leaves"><a class="markdownIt-Anchor" href="#leetcode-q-1123-lowest-common-ancestor-of-deepest-leaves"></a> LeetCode Q 1123 - Lowest Common Ancestor of Deepest Leaves</h1><p>Given a rooted binary tree, return the <strong>lowest common ancestor</strong> of its deepest leaves.</p><p><strong>Example 1:</strong> <code>Input: root = [1,2,3] ; Output: [1,2,3]</code><br>Explanation: The deepest leaves are the nodes with values 2 and 3.<br>The lowest common ancestor of these leaves is the node with value 1. The answer returned is a TreeNode object (not an array) with serialization <code>&quot;[1,2,3]&quot;</code>.<br><strong>Example 2:</strong> <code>Input: root = [1,2,3,4] ; Output: [4]</code><br><strong>Example 3:</strong> <code>Input: root = [1,2,3,4,5] ; Output: [2,4,5]</code></p><p><strong>Constraints:</strong></p><ul><li>The given tree will have between 1 and 1000 nodes.</li><li>Each node of the tree will have a distinct value between 1 and 1000.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight angelscript"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lcaDeepestLeaves(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">return</span> dfs(root, depth(root));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> depth(TreeNode n) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> Math.max(depth(n.left), depth(n.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode dfs(TreeNode root, <span class="built_in">int</span> dep) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span> || dep == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">  TreeNode l = dfs(root.left, dep - <span class="number">1</span>);</span><br><span class="line">  TreeNode r = dfs(root.right, dep - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">null</span>) <span class="keyword">return</span> r;</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="literal">null</span>) <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1123-lowest-common-ancestor-of-deepest-leaves&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1123-lowest-common-ancestor-of-deepest-leaves&quot;&gt;&lt;/a&gt; LeetCode Q 1123 - Lowest Common Ancestor of Deepest Leaves&lt;/h1&gt;
&lt;p&gt;Given a rooted binary tree, return the &lt;strong&gt;lowest common ancestor&lt;/strong&gt; of its deepest leaves.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2,3] ; Output: [1,2,3]&lt;/code&gt;&lt;br&gt;
Explanation: The deepest leaves are the nodes with values 2 and 3.&lt;br&gt;
The lowest common ancestor of these leaves is the node with value 1. The answer returned is a TreeNode object (not an array) with serialization &lt;code&gt;&amp;quot;[1,2,3]&amp;quot;&lt;/code&gt;.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2,3,4] ; Output: [4]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2,3,4,5] ; Output: [2,4,5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The given tree will have between 1 and 1000 nodes.&lt;/li&gt;
&lt;li&gt;Each node of the tree will have a distinct value between 1 and 1000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Lowest Common Ancestor of a Binary Tree</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ236/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ236/</id>
    <published>2019-07-16T16:46:51.000Z</published>
    <updated>2019-07-16T16:57:35.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-236-lowest-common-ancestor-of-a-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-236-lowest-common-ancestor-of-a-binary-tree"></a> LeetCode Q 236 - Lowest Common Ancestor of a Binary Tree</h1><p>Given a binary tree, find the <strong>lowest common ancestor (LCA)</strong> of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: <em>The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</em></p><p><strong>Example 1:</strong> <code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 ; Output: 3</code><br>Explanation: The LCA of nodes 5 and 1 is 3.<br><strong>Example 2:</strong> <code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 ; Output: 5</code><br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.</p><p><strong>Note:</strong></p><ul><li>All of the nodes’ values will be unique.</li><li><code>p</code> and <code>q</code> are different and both values will exist in the binary tree.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Explanation:</strong><br><img src="explain.png" width="40%" height="40%"></p><p><strong>Code:</strong></p><figure class="highlight kotlin"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">null</span>) <span class="keyword">return</span> q;</span><br><span class="line">  <span class="keyword">if</span> (q == <span class="literal">null</span>) <span class="keyword">return</span> p;</span><br><span class="line">  <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode dfs (TreeNode node, TreeNode p, TreeNode q) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">null</span> || node == p || node == q) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">  TreeNode l = dfs(node.left, p, q);</span><br><span class="line">  TreeNode r = dfs(node.right, p, q);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l != <span class="literal">null</span> &amp;&amp; r != <span class="literal">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">null</span> || r == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> l == <span class="literal">null</span> ? r : l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-236-lowest-common-ancestor-of-a-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-236-lowest-common-ancestor-of-a-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 236 - Lowest Common Ancestor of a Binary Tree&lt;/h1&gt;
&lt;p&gt;Given a binary tree, find the &lt;strong&gt;lowest common ancestor (LCA)&lt;/strong&gt; of two given nodes in the tree.&lt;br&gt;
According to the definition of LCA on Wikipedia: &lt;em&gt;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: The LCA of nodes 5 and 1 is 3.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All of the nodes’ values will be unique.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; are different and both values will exist in the binary tree.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Flip Equivalent Binary Trees</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ951/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ951/</id>
    <published>2019-07-16T16:38:24.000Z</published>
    <updated>2019-07-16T16:45:02.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-951-flip-equivalent-binary-trees"><a class="markdownIt-Anchor" href="#leetcode-q-951-flip-equivalent-binary-trees"></a> LeetCode Q 951 - Flip Equivalent Binary Trees</h1><p>For a binary tree <code>T</code>, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.<br>A binary tree <code>X</code> is flip equivalent to a binary tree <code>Y</code> if and only if we can make <code>X</code> equal to <code>Y</code> after some number of flip operations.<br>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes <code>root1</code> and <code>root2</code>.</p><p><strong>Example 1:</strong><br><code>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]</code><br><code>Output: true</code><br>Explanation: We flipped at nodes with values 1, 3, and 5.<br>Flipped Trees Diagram</p><p><strong>Note:</strong></p><ul><li>Each tree will have at most <code>100</code> nodes.</li><li>Each value in each tree will be a unique integer in the range <code>[0, 99]</code>.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight reasonml"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean flip<span class="constructor">Equiv(TreeNode <span class="params">root1</span>, TreeNode <span class="params">root2</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root1<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>root2<span class="operator"> == </span>null) return <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (root1<span class="operator"> == </span>null<span class="operator"> || </span>root2<span class="operator"> == </span>null<span class="operator"> || </span>root1.<span class="keyword">val</span> != root2.<span class="keyword">val</span>) return <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">  return (flip<span class="constructor">Equiv(<span class="params">root1</span>.<span class="params">left</span>, <span class="params">root2</span>.<span class="params">left</span>)</span><span class="operator"> &amp;&amp; </span>flip<span class="constructor">Equiv(<span class="params">root1</span>.<span class="params">right</span>, <span class="params">root2</span>.<span class="params">right</span>)</span>) <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">         (flip<span class="constructor">Equiv(<span class="params">root1</span>.<span class="params">left</span>, <span class="params">root2</span>.<span class="params">right</span>)</span> <span class="operator">&amp;&amp;</span> flip<span class="constructor">Equiv(<span class="params">root1</span>.<span class="params">right</span>, <span class="params">root2</span>.<span class="params">left</span>)</span>); </span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-951-flip-equivalent-binary-trees&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-951-flip-equivalent-binary-trees&quot;&gt;&lt;/a&gt; LeetCode Q 951 - Flip Equivalent Binary Trees&lt;/h1&gt;
&lt;p&gt;For a binary tree &lt;code&gt;T&lt;/code&gt;, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.&lt;br&gt;
A binary tree &lt;code&gt;X&lt;/code&gt; is flip equivalent to a binary tree &lt;code&gt;Y&lt;/code&gt; if and only if we can make &lt;code&gt;X&lt;/code&gt; equal to &lt;code&gt;Y&lt;/code&gt; after some number of flip operations.&lt;br&gt;
Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes &lt;code&gt;root1&lt;/code&gt; and &lt;code&gt;root2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Output: true&lt;/code&gt;&lt;br&gt;
Explanation: We flipped at nodes with values 1, 3, and 5.&lt;br&gt;
Flipped Trees Diagram&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each tree will have at most &lt;code&gt;100&lt;/code&gt; nodes.&lt;/li&gt;
&lt;li&gt;Each value in each tree will be a unique integer in the range &lt;code&gt;[0, 99]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Check Completeness of a Binary Tree</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ958/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ958/</id>
    <published>2019-07-16T16:27:15.000Z</published>
    <updated>2019-07-16T16:37:27.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-958-check-completeness-of-a-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-958-check-completeness-of-a-binary-tree"></a> LeetCode Q 958 - Check Completeness of a Binary Tree</h1><p>Given a binary tree, determine if it is a complete binary tree.<br>Definition of a complete binary tree from Wikipedia:<br><em>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</em></p><p><strong>Example 1:</strong> <code>Input: [1,2,3,4,5,6] ; Output: true</code><br>Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.<br><strong>Example 2:</strong> <code>Input: [1,2,3,4,5,null,7] ; Output: false</code><br>Explanation: The node with value 7 isn’t as far left as possible.</p><p><strong>Note:</strong> The tree will have between 1 and 100 nodes.</p><a id="more"></a><h2 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution: BFS</h2><p>We traverse the tree <em>layer by layer</em>. If a tree is a complete tree, then the first <em><strong>null</strong></em> node we encounter is the <em><strong>end</strong></em> of the tree. If we encounter some <em><strong>not null</strong></em> nodes after this <em><strong>end</strong></em> node, we can confirm this tree is not complete.</p><p><strong>Code:</strong></p><figure class="highlight aspectj"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> isEnd = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">  Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  que.offer(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> curr = que.poll();</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123; </span><br><span class="line">      isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isEnd) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      que.offer(curr.left);</span><br><span class="line">      que.offer(curr.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-958-check-completeness-of-a-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-958-check-completeness-of-a-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 958 - Check Completeness of a Binary Tree&lt;/h1&gt;
&lt;p&gt;Given a binary tree, determine if it is a complete binary tree.&lt;br&gt;
Definition of a complete binary tree from Wikipedia:&lt;br&gt;
&lt;em&gt;In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [1,2,3,4,5,6] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: [1,2,3,4,5,null,7] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: The node with value 7 isn’t as far left as possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The tree will have between 1 and 100 nodes.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Binary Search Tree to Greater Sum Tree</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ1038/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ1038/</id>
    <published>2019-07-16T15:45:22.000Z</published>
    <updated>2019-07-16T16:23:24.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1038-binary-search-tree-to-greater-sum-tree"><a class="markdownIt-Anchor" href="#leetcode-q-1038-binary-search-tree-to-greater-sum-tree"></a> LeetCode Q 1038 - Binary Search Tree to Greater Sum Tree</h1><p>Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to <code>node.val</code>.<br>As a reminder, a binary search tree is a tree that satisfies these constraints:</p><ul><li>The left subtree of a node contains only nodes with keys less than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Example 1:</strong> <code>Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] ; Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</code></p><p><strong>Note:</strong></p><ul><li>The number of nodes in the tree is between 1 and 100.</li><li>Each node will have value between 0 and 100.</li><li>The given tree is a binary search tree.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><p>DFS utilizing property of BST.</p><p><strong>Code:</strong></p><figure class="highlight xquery"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int<span class="built_in"> sum</span> = <span class="number">0</span>;</span><br><span class="line">public TreeNode bstToGst(TreeNode<span class="built_in"> root</span>) &#123;</span><br><span class="line">  dfs<span class="built_in">(root</span>);</span><br><span class="line">  <span class="keyword">return</span><span class="built_in"> root</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs (TreeNode<span class="built_in"> root</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">(root</span> == null) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  dfs<span class="built_in">(root</span>.right);</span><br><span class="line"></span><br><span class="line"> <span class="built_in"> sum</span> +=<span class="built_in"> root</span>.val;</span><br><span class="line"> <span class="built_in"> root</span>.val =<span class="built_in"> sum</span>;</span><br><span class="line"></span><br><span class="line">  dfs<span class="built_in">(root</span>.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1038-binary-search-tree-to-greater-sum-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1038-binary-search-tree-to-greater-sum-tree&quot;&gt;&lt;/a&gt; LeetCode Q 1038 - Binary Search Tree to Greater Sum Tree&lt;/h1&gt;
&lt;p&gt;Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to &lt;code&gt;node.val&lt;/code&gt;.&lt;br&gt;
As a reminder, a binary search tree is a tree that satisfies these constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The left subtree of a node contains only nodes with keys less than the node’s key.&lt;/li&gt;
&lt;li&gt;The right subtree of a node contains only nodes with keys greater than the node’s key.&lt;/li&gt;
&lt;li&gt;Both the left and right subtrees must also be binary search trees.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] ; Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is between 1 and 100.&lt;/li&gt;
&lt;li&gt;Each node will have value between 0 and 100.&lt;/li&gt;
&lt;li&gt;The given tree is a binary search tree.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Sliding Window Maximum</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ239/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ239/</id>
    <published>2019-07-16T15:35:42.000Z</published>
    <updated>2019-07-16T15:44:56.008Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-239-sliding-window-maximum"><a class="markdownIt-Anchor" href="#leetcode-q-239-sliding-window-maximum"></a> LeetCode Q 239 - Sliding Window Maximum</h1><p>Given an array nums, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position. Return the <strong>max sliding window</strong>.</p><p><strong>Example:</strong> <code>Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 ; Output: [3,3,5,5,6,7]</code><br>Explanation:<br>Window position                Max</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br>1 [3  -1  -3] 5  3  6  7       3<br>1  3 [-1  -3  5] 3  6  7       5<br>1  3  -1 [-3  5  3] 6  7       5<br>1  3  -1  -3 [5  3  6] 7       6<br>1  3  -1  -3  5 [3  6  7]      7</p><p><strong>Note:</strong> You may assume <code>k</code> is always valid, <code>1 ≤ k ≤ input array's size</code> for non-empty array.</p><p><strong>Follow up:</strong> Could you solve it in linear time?</p><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution: Sliding Window</h2><p><code>TreeMap&lt;Integer, Integer&gt;</code>: used to count how many times we have meet a number. <em>key</em>: number, <em>value</em>: times.</p><p><strong>Code:</strong></p><figure class="highlight vbscript"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>[] maxSlidingWindow(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nums == <span class="literal">null</span> || k &lt;= <span class="number">0</span>) return <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">right</span> &lt; nums.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">      map.put(nums[<span class="built_in">left</span>], map.<span class="keyword">get</span>(nums[<span class="built_in">left</span>]) - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (map.<span class="keyword">get</span>(nums[<span class="built_in">left</span>]) == <span class="number">0</span>) map.remove(nums[<span class="built_in">left</span>]);</span><br><span class="line">      <span class="built_in">left</span>++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map.put(nums[<span class="built_in">right</span>], map.getOrDefault(nums[<span class="built_in">right</span>], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    arr[<span class="built_in">right</span>++] = map.getLastKey();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = k - <span class="number">1</span>; i &lt; nums.length; i++) </span><br><span class="line">    res[index++] = arr[i];</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-239-sliding-window-maximum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-239-sliding-window-maximum&quot;&gt;&lt;/a&gt; LeetCode Q 239 - Sliding Window Maximum&lt;/h1&gt;
&lt;p&gt;Given an array nums, there is a sliding window of size &lt;code&gt;k&lt;/code&gt; which is moving from the very left of the array to the very right. You can only see the &lt;code&gt;k&lt;/code&gt; numbers in the window. Each time the sliding window moves right by one position. Return the &lt;strong&gt;max sliding window&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; &lt;code&gt;Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 ; Output: [3,3,5,5,6,7]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
Window position                Max&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3&lt;br&gt;
1 [3  -1  -3] 5  3  6  7       3&lt;br&gt;
1  3 [-1  -3  5] 3  6  7       5&lt;br&gt;
1  3  -1 [-3  5  3] 6  7       5&lt;br&gt;
1  3  -1  -3 [5  3  6] 7       6&lt;br&gt;
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; You may assume &lt;code&gt;k&lt;/code&gt; is always valid, &lt;code&gt;1 ≤ k ≤ input array&#39;s size&lt;/code&gt; for non-empty array.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Could you solve it in linear time?&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Game of Life</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ289/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ289/</id>
    <published>2019-07-16T15:12:30.000Z</published>
    <updated>2019-07-16T15:22:49.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-289-game-of-life"><a class="markdownIt-Anchor" href="#leetcode-q-289-game-of-life"></a> LeetCode Q 289 - Game of Life</h1><p>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p><p>Given a board with <code>m by n</code> cells, each cell has an initial state <em>live</em> <code>(1)</code> or <em>dead</em> <code>(0)</code>. Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p><ul><li>Any <em>live</em> cell with <strong>fewer than two live</strong> neighbors <strong>dies</strong>, as if caused by under-population.</li><li>Any <em>live</em> cell with <strong>two or three live</strong> neighbors <strong>lives</strong> on to the next generation.</li><li>Any <em>live</em> cell with <strong>more than three live</strong> neighbors <strong>dies</strong>, as if by over-population…</li><li>Any <em>dead</em> cell with <strong>exactly three live</strong> neighbors becomes a <em>live</em> cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</li></ul><p><strong>Example:</strong><br>Input:<br>[<br>[0,1,0],<br>[0,0,1],<br>[1,1,1],<br>[0,0,0]<br>]<br>Output:<br>[<br>[0,0,0],<br>[1,0,1],<br>[0,1,1],<br>[0,1,0]<br>]</p><p><strong>Follow up:</strong></p><ul><li>Could you solve it <em>in-place</em>? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.</li><li>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight angelscript"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> L2D = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> static <span class="keyword">final</span> <span class="built_in">int</span> D2L = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span>[][] dirs = \&#123;\&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> gameOfLife(<span class="built_in">int</span>[][] board) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> R = board.length, C = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">      <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span>[] dir: dirs) &#123;</span><br><span class="line">        <span class="built_in">int</span> nr = r + dir[<span class="number">0</span>], nc = c + dir[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; C &amp;&amp; (board[nr][nc] == <span class="number">1</span> || board[nr][nc] == L2D))</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (board[r][c] == <span class="number">0</span> &amp;&amp; count == <span class="number">2</span>) board[r][c] = D2L;</span><br><span class="line">      <span class="keyword">if</span> (board[r][c] == <span class="number">1</span> &amp;&amp; (count &lt; <span class="number">2</span> || count &gt; <span class="number">3</span>)) board[r][c] = L2D;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line">      board[r][c] %= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-289-game-of-life&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-289-game-of-life&quot;&gt;&lt;/a&gt; LeetCode Q 289 - Game of Life&lt;/h1&gt;
&lt;p&gt;According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”&lt;/p&gt;
&lt;p&gt;Given a board with &lt;code&gt;m by n&lt;/code&gt; cells, each cell has an initial state &lt;em&gt;live&lt;/em&gt; &lt;code&gt;(1)&lt;/code&gt; or &lt;em&gt;dead&lt;/em&gt; &lt;code&gt;(0)&lt;/code&gt;. Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Any &lt;em&gt;live&lt;/em&gt; cell with &lt;strong&gt;fewer than two live&lt;/strong&gt; neighbors &lt;strong&gt;dies&lt;/strong&gt;, as if caused by under-population.&lt;/li&gt;
&lt;li&gt;Any &lt;em&gt;live&lt;/em&gt; cell with &lt;strong&gt;two or three live&lt;/strong&gt; neighbors &lt;strong&gt;lives&lt;/strong&gt; on to the next generation.&lt;/li&gt;
&lt;li&gt;Any &lt;em&gt;live&lt;/em&gt; cell with &lt;strong&gt;more than three live&lt;/strong&gt; neighbors &lt;strong&gt;dies&lt;/strong&gt;, as if by over-population…&lt;/li&gt;
&lt;li&gt;Any &lt;em&gt;dead&lt;/em&gt; cell with &lt;strong&gt;exactly three live&lt;/strong&gt; neighbors becomes a &lt;em&gt;live&lt;/em&gt; cell, as if by reproduction.&lt;br&gt;
Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;br&gt;
Input:&lt;br&gt;
[&lt;br&gt;
[0,1,0],&lt;br&gt;
[0,0,1],&lt;br&gt;
[1,1,1],&lt;br&gt;
[0,0,0]&lt;br&gt;
]&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[0,0,0],&lt;br&gt;
[1,0,1],&lt;br&gt;
[0,1,1],&lt;br&gt;
[0,1,0]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Could you solve it &lt;em&gt;in-place&lt;/em&gt;? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.&lt;/li&gt;
&lt;li&gt;In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Univalued Binary Tree</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ965/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ965/</id>
    <published>2019-07-16T15:09:19.000Z</published>
    <updated>2019-07-16T15:11:46.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-965-univalued-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-965-univalued-binary-tree"></a> LeetCode Q 965 - Univalued Binary Tree</h1><p>A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued.</p><p><strong>Example 1:</strong> <code>Input: [1,1,1,1,1,null,1] ; Output: true</code><br><strong>Example 2:</strong> <code>Input: [2,2,2,5,2] ; Output: false</code></p><p><strong>Note:</strong></p><ul><li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li><li>Each node’s value will be an integer in the range <code>[0, 99]</code>.</li></ul><a id="more"></a><h2 id="solution-recursion"><a class="markdownIt-Anchor" href="#solution-recursion"></a> Solution: Recursion</h2><p><strong>Code:</strong></p><figure class="highlight kotlin"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> boolean isUnivalTree(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((root.left != <span class="literal">null</span> &amp;&amp; root.left.<span class="keyword">val</span> != root.<span class="keyword">val</span>) || </span><br><span class="line">      (root.right != <span class="literal">null</span> &amp;&amp; root.right.<span class="keyword">val</span> != root.<span class="keyword">val</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> isUnivalTree(root.left) &amp;&amp; isUnivalTree(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-965-univalued-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-965-univalued-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 965 - Univalued Binary Tree&lt;/h1&gt;
&lt;p&gt;A binary tree is univalued if every node in the tree has the same value. Return true if and only if the given tree is univalued.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [1,1,1,1,1,null,1] ; Output: true&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: [2,2,2,5,2] ; Output: false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the given tree will be in the range &lt;code&gt;[1, 100]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each node’s value will be an integer in the range &lt;code&gt;[0, 99]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Cameras</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ968/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ968/</id>
    <published>2019-07-16T14:48:03.000Z</published>
    <updated>2019-07-16T15:06:30.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-968-binary-tree-camerasl"><a class="markdownIt-Anchor" href="#leetcode-q-968-binary-tree-camerasl"></a> LeetCode Q 968 - Binary Tree Camerasl</h1><p>Given a binary tree, we install cameras on the nodes of the tree. Each camera at a node can monitor its <strong>parent</strong>, <strong>itself</strong>, and <strong>its immediate children</strong>.<br>Calculate the <strong>minimum number of cameras</strong> needed to monitor all nodes of the tree.</p><p><strong>Example 1:</strong> <code>Input: [0,0,null,0,0] ; Output: 1</code><br>Explanation: One camera is enough to monitor all nodes if placed as shown.<br><strong>Example 2:</strong> <code>Input: [0,0,null,0,null,0,null,null,0] ; Output: 2</code><br>Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.</p><p><strong>Note:</strong></p><ul><li>The number of nodes in the given tree will be in the range <code>[1, 1000]</code>.</li><li>Every node has value <code>0</code>.</li></ul><a id="more"></a><h2 id="solution-greedy-bottom-up-dfs"><a class="markdownIt-Anchor" href="#solution-greedy-bottom-up-dfs"></a> Solution: Greedy + Bottom-Up DFS</h2><p>We greedily put cameras in the <strong>parent</strong> nodes to enlarging the monitoring range. There are 3 status of a <strong>parent</strong> node.</p><ul><li>If a <strong>parent</strong> has one <strong>un-monitored</strong> child, then we must put a camera in this <strong>parent</strong>.</li><li>If a <strong>parent</strong> has two <strong>monitored but without camera</strong> children, then this parent is <strong>un-monitored</strong>.</li><li>If a <strong>parent</strong> has two <strong>monitored</strong> children and one or more child has a <strong>camera</strong>, then this parent is <strong>monitored without camera</strong>.</li></ul><p><strong>Code:</strong></p><figure class="highlight angelscript"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> NOT_MONITORED = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> MONITORED_NOCAM = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> MONITORED_WITHCAM = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> minCameraCover(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">return</span> (dfs(root) == NOT_MONITORED ? <span class="number">1</span> : <span class="number">0</span>) + res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> dfs(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> MONITORED_NOCAM;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> l = dfs(root.left);</span><br><span class="line">  <span class="built_in">int</span> r = dfs(root.right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == NOT_MONITORED || r == NOT_MONITORED) &#123;</span><br><span class="line">    res++; <span class="keyword">return</span> MONITORED_WITHCAM;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l == MONITORED_NOCAM || r == MONITORED_NOCAM ) &#123;</span><br><span class="line">    <span class="keyword">return</span> NOT_MONITORED;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MONITORED_NOCAM;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-968-binary-tree-camerasl&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-968-binary-tree-camerasl&quot;&gt;&lt;/a&gt; LeetCode Q 968 - Binary Tree Camerasl&lt;/h1&gt;
&lt;p&gt;Given a binary tree, we install cameras on the nodes of the tree. Each camera at a node can monitor its &lt;strong&gt;parent&lt;/strong&gt;, &lt;strong&gt;itself&lt;/strong&gt;, and &lt;strong&gt;its immediate children&lt;/strong&gt;.&lt;br&gt;
Calculate the &lt;strong&gt;minimum number of cameras&lt;/strong&gt; needed to monitor all nodes of the tree.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [0,0,null,0,0] ; Output: 1&lt;/code&gt;&lt;br&gt;
Explanation: One camera is enough to monitor all nodes if placed as shown.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: [0,0,null,0,null,0,null,null,0] ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the given tree will be in the range &lt;code&gt;[1, 1000]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Every node has value &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
  </entry>
  
  <entry>
    <title>Flip Binary Tree To Match Preorder Traversal</title>
    <link href="http://yoursite.com/2019/07/16/leetcodeQ971/"/>
    <id>http://yoursite.com/2019/07/16/leetcodeQ971/</id>
    <published>2019-07-16T14:25:28.000Z</published>
    <updated>2019-07-16T14:49:07.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-971-flip-binary-tree-to-match-preorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-971-flip-binary-tree-to-match-preorder-traversal"></a> LeetCode Q 971 - Flip Binary Tree To Match Preorder Traversal</h1><p>Given a binary tree with <code>N</code> nodes, each node has a different value from <code>{1, ..., N}</code>.<br>A node in this binary tree can be flipped by swapping the left child and the right child of that node.<br>Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.<br>Our goal is to <strong>flip the least number of nodes</strong> in the tree so that the voyage of the tree matches the voyage we are given.<br>If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.<br>If we <strong>cannot do so</strong>, then return the list <code>[-1]</code>.</p><p><strong>Example 1:</strong> <code>Input: root = [1,2], voyage = [2,1] ; Output: [-1]</code><br><strong>Example 2:</strong> <code>Input: root = [1,2,3], voyage = [1,3,2] ; Output: [1]</code><br><strong>Example 3:</strong> <code>Input: root = [1,2,3], voyage = [1,2,3] ; Output: []</code></p><p><strong>Note:</strong> <code>1 &lt;= N &lt;= 100</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight pgsql"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="type">Integer</span>&gt; res;</span><br><span class="line"><span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">public</span> List&lt;<span class="type">Integer</span>&gt; flipMatchVoyage(TreeNode root, <span class="type">int</span>[] voyage) &#123;</span><br><span class="line">  res = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">return</span> dfs(root) ? res : Arrays.asList(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private <span class="type">boolean</span> dfs(TreeNode root, <span class="type">int</span>[] voyage) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (voyage[<span class="keyword">index</span>] != root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">index</span>++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.val != voyage[<span class="keyword">index</span>]) &#123;</span><br><span class="line">    res.<span class="keyword">add</span>(root); </span><br><span class="line">    <span class="keyword">return</span> dfs(root.right, voyage) &amp;&amp; dfs(root.left, voyage); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dfs(root.left, voyage) &amp;&amp; dfs(root.right, voyage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-971-flip-binary-tree-to-match-preorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-971-flip-binary-tree-to-match-preorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 971 - Flip Binary Tree To Match Preorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree with &lt;code&gt;N&lt;/code&gt; nodes, each node has a different value from &lt;code&gt;{1, ..., N}&lt;/code&gt;.&lt;br&gt;
A node in this binary tree can be flipped by swapping the left child and the right child of that node.&lt;br&gt;
Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.&lt;br&gt;
Our goal is to &lt;strong&gt;flip the least number of nodes&lt;/strong&gt; in the tree so that the voyage of the tree matches the voyage we are given.&lt;br&gt;
If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.&lt;br&gt;
If we &lt;strong&gt;cannot do so&lt;/strong&gt;, then return the list &lt;code&gt;[-1]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2], voyage = [2,1] ; Output: [-1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2,3], voyage = [1,3,2] ; Output: [1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt; &lt;code&gt;Input: root = [1,2,3], voyage = [1,2,3] ; Output: []&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; &lt;code&gt;1 &amp;lt;= N &amp;lt;= 100&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Time Difference</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ539/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ539/</id>
    <published>2019-07-16T01:56:51.000Z</published>
    <updated>2019-07-16T14:25:44.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-539-minimum-time-difference"><a class="markdownIt-Anchor" href="#leetcode-q-539-minimum-time-difference"></a> LeetCode Q 539 - Minimum Time Difference</h1><p>Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.</p><p><strong>Example 1:</strong> <code>Input: [&quot;23:59&quot;,&quot;00:00&quot;] ; Output: 1</code><br><strong>Note:</strong></p><ul><li>The number of time points in the given list is at least 2 and won’t exceed 20000.</li><li>The input time is legal and ranges from 00:00 to 23:59.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><p>First sort the list. The minimum time difference can only happen between <strong>two adjacent</strong> times or between the <strong>first</strong> and <strong>last</strong> time.</p><p><strong>Code:</strong></p><figure class="highlight reasonml"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">int</span> find<span class="constructor">MinDifference(List&lt;String&gt; <span class="params">timePoints</span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="module-access"><span class="module"><span class="identifier">Collections</span>.</span></span>sort(timePoints);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span> l = <span class="number">0</span>, r = timePoints.size<span class="literal">()</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int</span> res = change2<span class="constructor">Mins(<span class="params">timePoints</span>.<span class="params">get</span>(<span class="params">l</span>)</span>) + <span class="number">24</span><span class="operator"> * </span><span class="number">60</span> - change2<span class="constructor">Mins(<span class="params">timePoints</span>.<span class="params">get</span>(<span class="params">r</span>)</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">int</span> lmins1 = change2<span class="constructor">Mins(<span class="params">timePoints</span>.<span class="params">get</span>(<span class="params">l</span>)</span>);</span><br><span class="line">    <span class="built_in">int</span> lmins2 = change2<span class="constructor">Mins(<span class="params">timePoints</span>.<span class="params">get</span>(<span class="params">l</span> + 1)</span>);</span><br><span class="line">    <span class="keyword">if</span> (lmins2 - lmins1 &lt; res) res = lmins2 - lmins1;</span><br><span class="line">    l++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> change2<span class="constructor">Mins(String <span class="params">time</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">int</span> mins = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">time</span>.<span class="params">substring</span>(3, 5)</span>);</span><br><span class="line">  <span class="built_in">int</span> hours = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>parse<span class="constructor">Int(<span class="params">time</span>.<span class="params">substring</span>(0, 2)</span>);</span><br><span class="line">  return hours<span class="operator"> * </span><span class="number">60</span> + mins;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-539-minimum-time-difference&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-539-minimum-time-difference&quot;&gt;&lt;/a&gt; LeetCode Q 539 - Minimum Time Difference&lt;/h1&gt;
&lt;p&gt;Given a list of 24-hour clock time points in “Hour:Minutes” format, find the minimum minutes difference between any two time points in the list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [&amp;quot;23:59&amp;quot;,&amp;quot;00:00&amp;quot;] ; Output: 1&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of time points in the given list is at least 2 and won’t exceed 20000.&lt;/li&gt;
&lt;li&gt;The input time is legal and ranges from 00:00 to 23:59.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Smallest String Starting From Leaf</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ988/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ988/</id>
    <published>2019-07-16T01:45:45.000Z</published>
    <updated>2019-07-16T01:56:20.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-988-smallest-string-starting-from-leaf"><a class="markdownIt-Anchor" href="#leetcode-q-988-smallest-string-starting-from-leaf"></a> LeetCode Q 988 - Smallest String Starting From Leaf</h1><p>Given the root of a binary tree, each node has a value from <code>0</code> to <code>25</code> representing the letters <code>'a'</code> to <code>'z'</code>: a value of <code>0</code> represents <code>'a'</code>, a value of <code>1</code> represents <code>'b'</code>, and so on.<br>Find the <strong>lexicographically smallest string</strong> that starts at a leaf of this tree and ends at the root.<br>(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, <code>&quot;ab&quot;</code> is lexicographically smaller than <code>&quot;aba&quot;</code>.  A leaf of a node is a node that has no children.)</p><p><strong>Example 1:</strong> <code>Input: [0,1,2,3,4,3,4] ; Output: &quot;dba&quot;</code><br><strong>Example 2:</strong> <code>Input: [25,1,3,1,3,0,2] ; Output: &quot;adz&quot;</code><br><strong>Example 3:</strong> <code>Input: [2,2,1,null,1,0,null,0] ; Output: &quot;abc&quot;</code></p><p><strong>Note:</strong></p><ul><li>The number of nodes in the given tree will be between 1 and 8500.</li><li>Each node in the tree will have a value between 0 and 25.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight kotlin"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String smallestFromLeaf(TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">return</span> dfs(root, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String dfs(TreeNode root, String suffix) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> suffix;</span><br><span class="line"></span><br><span class="line">  suffix = (char)(<span class="string">'a'</span> + root.<span class="keyword">val</span>) + suffix;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> suffix;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> dfs(root.right, suffix);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> dfs(root.left, suffix);</span><br><span class="line"></span><br><span class="line">  String l = dfs(root.left, suffix);</span><br><span class="line">  String r = dfs(root.right, suffix);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> l.compareTo(r) &lt;= <span class="number">0</span> ? l : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-988-smallest-string-starting-from-leaf&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-988-smallest-string-starting-from-leaf&quot;&gt;&lt;/a&gt; LeetCode Q 988 - Smallest String Starting From Leaf&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, each node has a value from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;25&lt;/code&gt; representing the letters &lt;code&gt;&#39;a&#39;&lt;/code&gt; to &lt;code&gt;&#39;z&#39;&lt;/code&gt;: a value of &lt;code&gt;0&lt;/code&gt; represents &lt;code&gt;&#39;a&#39;&lt;/code&gt;, a value of &lt;code&gt;1&lt;/code&gt; represents &lt;code&gt;&#39;b&#39;&lt;/code&gt;, and so on.&lt;br&gt;
Find the &lt;strong&gt;lexicographically smallest string&lt;/strong&gt; that starts at a leaf of this tree and ends at the root.&lt;br&gt;
(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; is lexicographically smaller than &lt;code&gt;&amp;quot;aba&amp;quot;&lt;/code&gt;.  A leaf of a node is a node that has no children.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [0,1,2,3,4,3,4] ; Output: &amp;quot;dba&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: [25,1,3,1,3,0,2] ; Output: &amp;quot;adz&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt; &lt;code&gt;Input: [2,2,1,null,1,0,null,0] ; Output: &amp;quot;abc&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the given tree will be between 1 and 8500.&lt;/li&gt;
&lt;li&gt;Each node in the tree will have a value between 0 and 25.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Distribute Coins in Binary Tree</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ979/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ979/</id>
    <published>2019-07-16T01:11:57.000Z</published>
    <updated>2019-07-16T01:37:30.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-979-distribute-coins-in-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-979-distribute-coins-in-binary-tree"></a> LeetCode Q 979 - Distribute Coins in Binary Tree</h1><p>Given the root of a binary tree with <code>N</code> nodes, each node in the tree has <code>node.val</code> coins, and there are <code>N</code> coins total.<br>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)<br>Return the number of moves required to make every node have exactly one coin.</p><p><strong>Example 1:</strong> <code>Input: [3,0,0] ; Output: 2</code><br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.<br><strong>Example 2:</strong> <code>Input: [0,3,0] ; Output: 3</code><br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.<br><strong>Example 3:</strong> <code>Input: [1,0,2] ; Output: 2</code><br><strong>Example 4:</strong> <code>Input: [1,0,0,null,3] ; Output: 4</code></p><p><strong>Note:</strong></p><ul><li><code>1&lt;= N &lt;= 100</code></li><li><code>0 &lt;= node.val &lt;= N</code></li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p>Traverse the child leaves first and balance the coins. For example, if a leaf has 3 coins, then we need to make <code>4 - 1 = 3</code> moves in this node. If a node has 0 coins, then we need to make <code>Math.abs(0 - 1) = 1</code> moves in this node. See this image.<br><img src="explain.png" width="70%" height="70%"></p><p><strong>Code:</strong></p><figure class="highlight vbscript"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> distributeCoins(TreeNode root) &#123;</span><br><span class="line">  dfs(root);</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> dfs (TreeNode root) &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">left</span> = dfs(root.<span class="built_in">left</span>);</span><br><span class="line">  <span class="built_in">int</span> <span class="built_in">right</span> = dfs(root.<span class="built_in">right</span>);</span><br><span class="line"></span><br><span class="line">  sum += Math.<span class="built_in">abs</span>(<span class="built_in">left</span>) + Math.<span class="built_in">abs</span>(<span class="built_in">right</span>);</span><br><span class="line"></span><br><span class="line">  return <span class="built_in">left</span> + <span class="built_in">right</span> + root.val - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-979-distribute-coins-in-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-979-distribute-coins-in-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 979 - Distribute Coins in Binary Tree&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree with &lt;code&gt;N&lt;/code&gt; nodes, each node in the tree has &lt;code&gt;node.val&lt;/code&gt; coins, and there are &lt;code&gt;N&lt;/code&gt; coins total.&lt;br&gt;
In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)&lt;br&gt;
Return the number of moves required to make every node have exactly one coin.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [3,0,0] ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: [0,3,0] ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.&lt;br&gt;
&lt;strong&gt;Example 3:&lt;/strong&gt; &lt;code&gt;Input: [1,0,2] ; Output: 2&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 4:&lt;/strong&gt; &lt;code&gt;Input: [1,0,0,null,3] ; Output: 4&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&amp;lt;= N &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= node.val &amp;lt;= N&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Nesting Depth of Two Valid Parentheses Strings</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ1111/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ1111/</id>
    <published>2019-07-16T01:04:08.000Z</published>
    <updated>2019-07-16T01:10:31.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1111-maximum-nesting-depth-of-two-valid-parentheses-strings"><a class="markdownIt-Anchor" href="#leetcode-q-1111-maximum-nesting-depth-of-two-valid-parentheses-strings"></a> LeetCode Q 1111 - Maximum Nesting Depth of Two Valid Parentheses Strings</h1><p>A string is a valid parentheses string (denoted VPS) if and only if it consists of <code>&quot;(&quot;</code> and <code>&quot;)&quot;</code> characters only, and:</p><ul><li>It is the empty string, or</li><li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are VPS’s, or</li><li>It can be written as <code>(A)</code>, where <code>A</code> is a VPS.</li></ul><p>We can similarly define the nesting depth <code>depth(S)</code> of any VPS S as follows:</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>, where <code>A</code> and <code>B</code> are VPS’s</li><li><code>depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>, where <code>A</code> is a VPS.</li></ul><p>For example,  <code>&quot;&quot;</code>, <code>&quot;()()&quot;</code>, and <code>&quot;()(()())&quot;</code> are VPS’s (with nesting depths 0, 1, and 2), and <code>&quot;)(&quot;</code> and <code>&quot;(()&quot;</code> are not VPS’s.<br>Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS’s (and A.length + B.length = seq.length).<br>Now choose any such A and B such that <code>max(depth(A), depth(B))</code> is the <strong>minimum</strong> possible value.<br>Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.</p><p><strong>Example 1:</strong> <code>Input: seq = &quot;(()())&quot; ; Output: [0,1,1,1,1,0]</code><br><strong>Example 2:</strong> <code>Input: seq = &quot;()(())()&quot; ; Output: [0,0,0,1,1,0,1,1]</code></p><p><strong>Constraints:</strong> <code>1 &lt;= seq.size &lt;= 10000</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><p>Intuition: Seperate the adjacent <code>&quot;(&quot;</code>s to different groups.</p><p><strong>Code:</strong></p><figure class="highlight pgsql"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span>[] maxDepthAfterSplit(String seq) &#123;</span><br><span class="line">  <span class="type">int</span>[] res = <span class="built_in">new</span> <span class="type">int</span>[seq.length()]; </span><br><span class="line">  <span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>, depth = <span class="number">1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">char</span> ch: seq.toCharArray()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'('</span>) depth++;</span><br><span class="line">    res[<span class="keyword">index</span>++] = depth % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">')'</span>) depth<span class="comment">--;</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1111-maximum-nesting-depth-of-two-valid-parentheses-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1111-maximum-nesting-depth-of-two-valid-parentheses-strings&quot;&gt;&lt;/a&gt; LeetCode Q 1111 - Maximum Nesting Depth of Two Valid Parentheses Strings&lt;/h1&gt;
&lt;p&gt;A string is a valid parentheses string (denoted VPS) if and only if it consists of &lt;code&gt;&amp;quot;(&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;)&amp;quot;&lt;/code&gt; characters only, and:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is the empty string, or&lt;/li&gt;
&lt;li&gt;It can be written as &lt;code&gt;AB&lt;/code&gt; (&lt;code&gt;A&lt;/code&gt; concatenated with &lt;code&gt;B&lt;/code&gt;), where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are VPS’s, or&lt;/li&gt;
&lt;li&gt;It can be written as &lt;code&gt;(A)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a VPS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can similarly define the nesting depth &lt;code&gt;depth(S)&lt;/code&gt; of any VPS S as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;depth(&amp;quot;&amp;quot;) = 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depth(A + B) = max(depth(A), depth(B))&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are VPS’s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depth(&amp;quot;(&amp;quot; + A + &amp;quot;)&amp;quot;) = 1 + depth(A)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a VPS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example,  &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;()()&amp;quot;&lt;/code&gt;, and &lt;code&gt;&amp;quot;()(()())&amp;quot;&lt;/code&gt; are VPS’s (with nesting depths 0, 1, and 2), and &lt;code&gt;&amp;quot;)(&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;(()&amp;quot;&lt;/code&gt; are not VPS’s.&lt;br&gt;
Given a VPS seq, split it into two disjoint subsequences A and B, such that A and B are VPS’s (and A.length + B.length = seq.length).&lt;br&gt;
Now choose any such A and B such that &lt;code&gt;max(depth(A), depth(B))&lt;/code&gt; is the &lt;strong&gt;minimum&lt;/strong&gt; possible value.&lt;br&gt;
Return an answer array (of length seq.length) that encodes such a choice of A and B:  answer[i] = 0 if seq[i] is part of A, else answer[i] = 1.  Note that even though multiple answers may exist, you may return any of them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: seq = &amp;quot;(()())&amp;quot; ; Output: [0,1,1,1,1,0]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Example 2:&lt;/strong&gt; &lt;code&gt;Input: seq = &amp;quot;()(())()&amp;quot; ; Output: [0,0,0,1,1,0,1,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt; &lt;code&gt;1 &amp;lt;= seq.size &amp;lt;= 10000&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Construct Binary Search Tree from Preorder Traversal</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ1008/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ1008/</id>
    <published>2019-07-16T00:48:54.000Z</published>
    <updated>2019-07-16T01:02:49.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1008-construct-binary-search-tree-from-preorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-1008-construct-binary-search-tree-from-preorder-traversal"></a> LeetCode Q 1008 - Construct Binary Search Tree from Preorder Traversal</h1><p>Return the root node of a binary search tree that matches the given preorder traversal.</p><p><strong>Example 1:</strong> <code>Input: [8,5,1,7,10,12] ; Output: [8,5,10,1,7,null,12]</code></p><p><strong>Note:</strong></p><ul><li>1 &lt;= preorder.length &lt;= 100</li><li>The values of preorder are distinct.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution:</h2><h3 id="solutino-1-dfs"><a class="markdownIt-Anchor" href="#solutino-1-dfs"></a> Solutino 1: DFS</h3><p><strong>Code:</strong></p><figure class="highlight crmsh"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">public TreeNode bstFromPreorder(int[] preorder) &#123;</span><br><span class="line">  return dfs(preorder, Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private TreeNode dfs(int[] preorder, int maxLimit) &#123;</span><br><span class="line">  if (index &gt;= preorder.length || preorder[index] &gt; maxLimit) return null;</span><br><span class="line"></span><br><span class="line">  TreeNode <span class="keyword">node</span> <span class="title">= new</span> TreeNode(preorder[index++]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">node</span>.<span class="title">left</span> = dfs(preorder, <span class="keyword">node</span>.<span class="title">val</span>);</span><br><span class="line">  <span class="keyword">node</span>.<span class="title">right</span> = dfs(preorder, maxLimit);</span><br><span class="line"></span><br><span class="line">  return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="solutino-2-bfs"><a class="markdownIt-Anchor" href="#solutino-2-bfs"></a> Solutino 2: BFS</h3><p><strong>Code:</strong></p><figure class="highlight cpp"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">  TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);    </span><br><span class="line">  Deque&lt;TreeNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="built_in">stack</span>.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.length; i++) &#123;</span><br><span class="line">    TreeNode n = <span class="keyword">new</span> TreeNode(preorder[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>.isEmpty() &amp;&amp; <span class="built_in">stack</span>.peek().val &gt; n.val) &#123;</span><br><span class="line">      <span class="built_in">stack</span>.peek().left = n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TreeNode pre = null;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty() &amp;&amp; <span class="built_in">stack</span>.peek().val &lt; n.val) &#123;</span><br><span class="line">      pre = <span class="built_in">stack</span>.pop();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pre.right = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>.push(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1008-construct-binary-search-tree-from-preorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1008-construct-binary-search-tree-from-preorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 1008 - Construct Binary Search Tree from Preorder Traversal&lt;/h1&gt;
&lt;p&gt;Return the root node of a binary search tree that matches the given preorder traversal.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [8,5,1,7,10,12] ; Output: [8,5,10,1,7,null,12]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= preorder.length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;The values of preorder are distinct.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
  </entry>
  
  <entry>
    <title>Sum of Root To Leaf Binary Numbers</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ1022/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ1022/</id>
    <published>2019-07-16T00:27:07.000Z</published>
    <updated>2019-07-16T00:38:18.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1022-sum-of-root-to-leaf-binary-numbers"><a class="markdownIt-Anchor" href="#leetcode-q-1022-sum-of-root-to-leaf-binary-numbers"></a> LeetCode Q 1022 - Sum of Root To Leaf Binary Numbers</h1><p>Given a binary tree, each node has value <code>0</code> or <code>1</code>.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.<br>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.<br>Return the sum of these numbers.</p><p><strong>Example 1:</strong> <code>Input: [1,0,1,0,1,0,1] ; Output: 22</code><br>Explanation: <code>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</code></p><p><strong>Note:</strong></p><ul><li>The number of nodes in the tree is between <code>1</code> and <code>1000</code>.</li><li><code>node.val</code> is <code>0</code> or <code>1</code>.</li><li>The answer will not exceed <code>2^31 - 1</code>.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight xquery"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private int<span class="built_in"> sum</span> = <span class="number">0</span>;</span><br><span class="line">public int sumRootToLeaf(TreeNode<span class="built_in"> root</span>) &#123;</span><br><span class="line">  dfs<span class="built_in">(root</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span><span class="built_in"> sum</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs (TreeNode<span class="built_in"> root</span>, int<span class="built_in"> number</span>) &#123;</span><br><span class="line">  </span><br><span class="line"> <span class="built_in"> number</span> =<span class="built_in"> number</span> * <span class="number">2</span> +<span class="built_in"> root</span>.val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">(root</span>.left == null &amp;&amp;<span class="built_in"> root</span>.right == null) &#123;</span><br><span class="line">   <span class="built_in"> sum</span> +=<span class="built_in"> number</span>; <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">(root</span>.left != null) dfs<span class="built_in">(root</span>.left,<span class="built_in"> number</span>); // avoid null pointer exception <span class="keyword">in</span> the <span class="number">1</span>st line <span class="keyword">of</span> this code block</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">(root</span>.right != null) dfs<span class="built_in">(root</span>.right,<span class="built_in"> number</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1022-sum-of-root-to-leaf-binary-numbers&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1022-sum-of-root-to-leaf-binary-numbers&quot;&gt;&lt;/a&gt; LeetCode Q 1022 - Sum of Root To Leaf Binary Numbers&lt;/h1&gt;
&lt;p&gt;Given a binary tree, each node has value &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is &lt;code&gt;0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1&lt;/code&gt;, then this could represent &lt;code&gt;01101&lt;/code&gt; in binary, which is &lt;code&gt;13&lt;/code&gt;.&lt;br&gt;
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.&lt;br&gt;
Return the sum of these numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [1,0,1,0,1,0,1] ; Output: 22&lt;/code&gt;&lt;br&gt;
Explanation: &lt;code&gt;(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;1000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node.val&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The answer will not exceed &lt;code&gt;2^31 - 1&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Difference Between Node and Ancestor</title>
    <link href="http://yoursite.com/2019/07/15/leetcodeQ1026/"/>
    <id>http://yoursite.com/2019/07/15/leetcodeQ1026/</id>
    <published>2019-07-16T00:21:03.000Z</published>
    <updated>2019-07-16T00:28:19.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1026-maximum-difference-between-node-and-ancestor"><a class="markdownIt-Anchor" href="#leetcode-q-1026-maximum-difference-between-node-and-ancestor"></a> LeetCode Q 1026 - Maximum Difference Between Node and Ancestor</h1><p>Given the root of a binary tree, find the maximum value <code>V</code> for which there exists different nodes <code>A</code> and <code>B</code> where <code>V = |A.val - B.val|</code> and <code>A</code> is an ancestor of <code>B</code>.</p><p>(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)</p><p><strong>Example 1:</strong> <code>Input: [8,3,10,1,6,null,14,null,null,4,7,13] ; Output: 7</code><br>Explanation: We have various ancestor-node differences, some of which are given below :<br>|8 - 3| = 5<br>|3 - 7| = 4<br>|8 - 1| = 7<br>|10 - 13| = 3<br>Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</p><p><strong>Note:</strong></p><ul><li>The number of nodes in the tree is between 2 and 5000.</li><li>Each node will have value between 0 and 100000.</li></ul><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution: DFS</h2><p><strong>Code:</strong></p><figure class="highlight xquery"><figcaption><span>lang: java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxAncestorDiff(TreeNode<span class="built_in"> root</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dfs<span class="built_in">(root</span>,<span class="built_in"> root</span>.val,<span class="built_in"> root</span>.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int dfs(TreeNode<span class="built_in"> root</span>, int<span class="built_in"> min</span>, int<span class="built_in"> max</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">(root</span> == null) <span class="keyword">return</span><span class="built_in"> max</span> -<span class="built_in"> min</span>;</span><br><span class="line"></span><br><span class="line"> <span class="built_in"> max</span> = Math<span class="built_in">.max</span><span class="built_in">(max</span>,<span class="built_in"> root</span>.val);</span><br><span class="line"> <span class="built_in"> min</span> - Math<span class="built_in">.min</span><span class="built_in">(min</span>,<span class="built_in"> root</span>.val);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Math<span class="built_in">.max</span>(dfs<span class="built_in">(root</span>.left,<span class="built_in"> min</span>,<span class="built_in"> max</span>), dfs<span class="built_in">(root</span>.right,<span class="built_in"> min</span>,<span class="built_in"> max</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1026-maximum-difference-between-node-and-ancestor&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1026-maximum-difference-between-node-and-ancestor&quot;&gt;&lt;/a&gt; LeetCode Q 1026 - Maximum Difference Between Node and Ancestor&lt;/h1&gt;
&lt;p&gt;Given the root of a binary tree, find the maximum value &lt;code&gt;V&lt;/code&gt; for which there exists different nodes &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; where &lt;code&gt;V = |A.val - B.val|&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an ancestor of &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt; &lt;code&gt;Input: [8,3,10,1,6,null,14,null,null,4,7,13] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: We have various ancestor-node differences, some of which are given below :&lt;br&gt;
|8 - 3| = 5&lt;br&gt;
|3 - 7| = 4&lt;br&gt;
|8 - 1| = 7&lt;br&gt;
|10 - 13| = 3&lt;br&gt;
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes in the tree is between 2 and 5000.&lt;/li&gt;
&lt;li&gt;Each node will have value between 0 and 100000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
</feed>
