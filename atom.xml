<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T17:35:26.020Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Design Twitter</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ355/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ355/</id>
    <published>2019-04-21T17:11:41.000Z</published>
    <updated>2019-04-21T17:35:26.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-355-design-twitter"><a class="markdownIt-Anchor" href="#leetcode-q-355-design-twitter"></a> LeetCode Q 355 - Design Twitter</h1><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p><ol><li><strong>postTweet(userId, tweetId)</strong>: Compose a new tweet.</li><li><strong>getNewsFeed(userId)</strong>: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li><li><strong>follow(followerId, followeeId)</strong>: Follower follows a followee.</li><li><strong>unfollow(followerId, followeeId)</strong>: Follower unfollows a followee.<br>Example:<br><code>Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5); // User 1's news feed should return a list with 1 tweet id -&gt; [5]. twitter.getNewsFeed(1); // User 1 follows user 2. twitter.follow(1, 2); // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6); // User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1); // User 1 unfollows user 2. twitter.unfollow(1, 2); // User 1's news feed should return a list with 1 tweet id -&gt; [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);</code></li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-hashtable"><a class="markdownIt-Anchor" href="#method-1-hashtable"></a> Method 1: HashTable</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> timeStamp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Tweet&gt; tweetMap;</span><br><span class="line"><span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; userMap;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tweet</span> </span>&#123;   <span class="comment">// increase an time field to the Tweet class</span></span><br><span class="line"><span class="keyword">int</span> tweetId; <span class="comment">// enable the sorting by time function</span></span><br><span class="line"><span class="keyword">int</span> time;</span><br><span class="line">Tweet next;  <span class="comment">// in the tweetMap, we only store the most recent tweet and use next attribute to find its next recent tweet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Tweet</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetId = id; <span class="keyword">this</span>.time = time; <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize your data structure here.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tweetMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">this</span>.userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compose a new tweet. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> twitId)</span> </span>&#123;</span><br><span class="line">Tweet curr = <span class="keyword">new</span> Tweet(twitId, ++timeStamp);</span><br><span class="line">curr.next = tweetMap.getOrDefault(userId, <span class="keyword">null</span>);</span><br><span class="line">tweetMap.put(userId, curr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(userId); <span class="comment">// add the user itself</span></span><br><span class="line"><span class="keyword">if</span> (userMap.containsKey(userId)) set.addAll(userMap.get(userId));</span><br><span class="line"></span><br><span class="line">Queue&lt;Tweet&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (b.time - a.time));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: set) &#123;</span><br><span class="line"><span class="keyword">if</span> (tweetMap.get(num) != <span class="keyword">null</span>) pq.offer(tweetMap.get(num));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">Tweet t = pq.poll();</span><br><span class="line"><span class="keyword">if</span> (t.next != <span class="keyword">null</span>) pq.offer(t.next);</span><br><span class="line">count++;</span><br><span class="line">res.add(t.tweetId);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower follows a followee. If the operation is invalid, it should be a no-op.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">userMap.putIfAbsent(followerId, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">userMap.get(followerId).add(followeeId);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// Follower unfollows a followee. If the operation is invalid, it should be a no-op. </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (userMap.get(followerId) == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">userMap.get(followerId).remove(followeeId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-ood-todo"><a class="markdownIt-Anchor" href="#method-2-ood-todo"></a> Method 2: OOD (TODO)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-355-design-twitter&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-355-design-twitter&quot;&gt;&lt;/a&gt; LeetCode Q 355 - Design Twitter&lt;/h1&gt;
&lt;p&gt;Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;postTweet(userId, tweetId)&lt;/strong&gt;: Compose a new tweet.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getNewsFeed(userId)&lt;/strong&gt;: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;follow(followerId, followeeId)&lt;/strong&gt;: Follower follows a followee.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unfollow(followerId, followeeId)&lt;/strong&gt;: Follower unfollows a followee.&lt;br&gt;
Example:&lt;br&gt;
&lt;code&gt;Twitter twitter = new Twitter(); // User 1 posts a new tweet (id = 5). twitter.postTweet(1, 5); // User 1&#39;s news feed should return a list with 1 tweet id -&amp;gt; [5]. twitter.getNewsFeed(1); // User 1 follows user 2. twitter.follow(1, 2); // User 2 posts a new tweet (id = 6). twitter.postTweet(2, 6); // User 1&#39;s news feed should return a list with 2 tweet ids -&amp;gt; [6, 5]. // Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.getNewsFeed(1); // User 1 unfollows user 2. twitter.unfollow(1, 2); // User 1&#39;s news feed should return a list with 1 tweet id -&amp;gt; [5], // since user 1 is no longer following user 2. twitter.getNewsFeed(1);&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="OOD" scheme="http://yoursite.com/tags/OOD/"/>
    
  </entry>
  
  <entry>
    <title>Find All Anagrams in a String</title>
    <link href="http://yoursite.com/2019/04/21/leetcodeQ438/"/>
    <id>http://yoursite.com/2019/04/21/leetcodeQ438/</id>
    <published>2019-04-21T16:51:16.000Z</published>
    <updated>2019-04-21T17:11:15.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-438-find-all-anagrams-in-a-string"><a class="markdownIt-Anchor" href="#leetcode-q-438-find-all-anagrams-in-a-string"></a> LeetCode Q 438 - Find All Anagrams in a String</h1><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.<br>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.<br>The order of output does not matter.</p><p>Example 1:<br><code>Input: s: &quot;cbaebabacd&quot; p: &quot;abc&quot; ; Output: [0, 6] Explanation: The substring with start index = 0 is &quot;cba&quot;, which is an anagram of &quot;abc&quot;. The substring with start index = 6 is &quot;bac&quot;, which is an anagram of &quot;abc&quot;.</code><br>Example 2:<br><code>Input: s: &quot;abab&quot; p: &quot;ab&quot; ; Output: [0, 1, 2] Explanation: The substring with start index = 0 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;. The substring with start index = 1 is &quot;ba&quot;, which is an anagram of &quot;ab&quot;. The substring with start index = 2 is &quot;ab&quot;, which is an anagram of &quot;ab&quot;.</code></p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/20/lintcodeQ386/" title="Longest Substring with At Most K Distinct Characters">Longest Substring with At Most K Distinct Characters</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="method-1-sliding-window"><a class="markdownIt-Anchor" href="#method-1-sliding-window"></a> Method 1: Sliding Window</h3><p><strong>Time Complexity: O(n), n is the length of String s.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch - <span class="string">'a'</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r) - <span class="string">'a'</span>] &gt; <span class="number">0</span>) sum++;</span><br><span class="line">count[s.charAt(r++) - <span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">if</span> (sum == p.length()) res.add(l);</span><br><span class="line"><span class="keyword">if</span> (r - l == p.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] &gt;= <span class="number">0</span>) sum--;</span><br><span class="line">count[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-naive-method"><a class="markdownIt-Anchor" href="#method-2-naive-method"></a> Method 2: Naive Method</h3><p><strong>Time Complexity: O(m * n), n is the length of String s, m is the length of String p.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - p.length(); i++) &#123;</span><br><span class="line">String str = s.substring(i, i + p.length());</span><br><span class="line"><span class="keyword">if</span> (isAnagram(str, p)) res.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: p.toCharArray()) count[ch-<span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) count[ch-<span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++) </span><br><span class="line"><span class="keyword">if</span> (count[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-438-find-all-anagrams-in-a-string&quot;&gt;&lt;/a&gt; LeetCode Q 438 - Find All Anagrams in a String&lt;/h1&gt;
&lt;p&gt;Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.&lt;br&gt;
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.&lt;br&gt;
The order of output does not matter.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; ; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;. The substring with start index = 6 is &amp;quot;bac&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot; ; Output: [0, 1, 2] Explanation: The substring with start index = 0 is &amp;quot;ab&amp;quot;, which is an anagram of &amp;quot;ab&amp;quot;. The substring with start index = 1 is &amp;quot;ba&amp;quot;, which is an anagram of &amp;quot;ab&amp;quot;. The substring with start index = 2 is &amp;quot;ab&amp;quot;, which is an anagram of &amp;quot;ab&amp;quot;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/20/lintcodeQ386/&quot; title=&quot;Longest Substring with At Most K Distinct Characters&quot;&gt;Longest Substring with At Most K Distinct Characters&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Substring with At Most K Distinct Characters</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ386/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ386/</id>
    <published>2019-04-20T23:53:12.000Z</published>
    <updated>2019-04-21T16:58:33.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"><a class="markdownIt-Anchor" href="#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters"></a> LeetCode Q 386 - Longest Substring with At Most K Distinct Characters</h1><p>Given a string S, find the length of the longest substring T that contains at most k distinct characters.</p><p>Example 1:<br><code>Input: S = &quot;eceba&quot; and k = 3 ; Output: 4 ; Explanation: T = &quot;eceb&quot;</code><br>Example 2:<br><code>Input: S = &quot;WORLD&quot; and k = 4 ; Output: 4 ; Explanation: T = &quot;WORL&quot; or &quot;ORLD&quot;</code><br><strong>Challenge</strong> : O(n) time</p><p>Similar Question: <a href="/2019/04/17/leetcodeQ3/" title="Longest Substring Without Repeating Characters">Longest Substring Without Repeating Characters</a>, <a href="/2019/04/19/leetcodeQ76/" title="Minimum Window Substring">Minimum Window Substring</a>, <a href="/2019/04/21/leetcodeQ438/" title="Find All Anagrams in a String">Find All Anagrams in a String</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Sliding Window: Time Complexity: O(n)</strong></p><h3 id="method-1-use-an-array"><a class="markdownIt-Anchor" href="#method-1-use-an-array"></a> Method 1: Use an array</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (s.length() &lt;= k) <span class="keyword">return</span> s.length();</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, maxLen = <span class="number">0</span>;;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">count[s.charAt(r)]++;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(r)] == <span class="number">1</span>) sum++;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; k) &#123;</span><br><span class="line">count[s.charAt(l)]--;</span><br><span class="line"><span class="keyword">if</span> (count[s.charAt(l)] == <span class="number">0</span>) sum--;</span><br><span class="line">l++;</span><br><span class="line">&#125; </span><br><span class="line">maxLen = Math.max(maxLen, r - l + <span class="number">1</span>);</span><br><span class="line">r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="method-2-use-an-hashmap"><a class="markdownIt-Anchor" href="#method-2-use-an-hashmap"></a> Method 2: Use an hashmap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstringKDistinct</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//store char and number of occurance. </span></span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>; end &lt; s.length(); end++) &#123;</span><br><span class="line"><span class="keyword">char</span> curr = s.charAt(end);</span><br><span class="line"><span class="keyword">if</span> (map.get(curr) == <span class="keyword">null</span>) map.put(curr, <span class="number">0</span>);</span><br><span class="line">map.put(curr, map.get(curr) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(curr)==<span class="number">1</span>) counter++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check size of k in current window</span></span><br><span class="line"><span class="keyword">while</span>(counter &gt; k) &#123;</span><br><span class="line"><span class="keyword">char</span> first = s.charAt(start);</span><br><span class="line">map.put(first, map.get(first)-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(map.get(first) == <span class="number">0</span>) counter--;</span><br><span class="line">start++;</span><br><span class="line">&#125;</span><br><span class="line">len = Math.max(len, end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-386-longest-substring-with-at-most-k-distinct-characters&quot;&gt;&lt;/a&gt; LeetCode Q 386 - Longest Substring with At Most K Distinct Characters&lt;/h1&gt;
&lt;p&gt;Given a string S, find the length of the longest substring T that contains at most k distinct characters.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;eceba&amp;quot; and k = 3 ; Output: 4 ; Explanation: T = &amp;quot;eceb&amp;quot;&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;WORLD&amp;quot; and k = 4 ; Output: 4 ; Explanation: T = &amp;quot;WORL&amp;quot; or &amp;quot;ORLD&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Challenge&lt;/strong&gt; : O(n) time&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/17/leetcodeQ3/&quot; title=&quot;Longest Substring Without Repeating Characters&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ76/&quot; title=&quot;Minimum Window Substring&quot;&gt;Minimum Window Substring&lt;/a&gt;, &lt;a href=&quot;/2019/04/21/leetcodeQ438/&quot; title=&quot;Find All Anagrams in a String&quot;&gt;Find All Anagrams in a String&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ347/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ347/</id>
    <published>2019-04-20T16:41:21.000Z</published>
    <updated>2019-04-20T17:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-347-top-k-frequent-elements"><a class="markdownIt-Anchor" href="#leetcode-q-347-top-k-frequent-elements"></a> LeetCode Q 347 - Top K Frequent Elements</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>Example 1:<br><code>Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]</code><br>Example 2:<br><code>Input: nums = [1], k = 1 ; Output: [1]</code><br><strong>Note</strong>: You may assume k is always valid, <strong>1 ≤ k ≤ number of unique elements</strong>. Your algorithm’s time complexity must be better than <strong>O(n log n)</strong>, where n is the array’s size.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Heap Sort: time O(NlogN)</strong><br><strong>Bucket Sort: tiem O(N)</strong></p><h3 id="solution-1-heap-sort"><a class="markdownIt-Anchor" href="#solution-1-heap-sort"></a> Solution 1: Heap Sort</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (map.get(a) - map.get(b)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line">pq.offer(num);</span><br><span class="line"><span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: pq)</span><br><span class="line">res.add(<span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bucket-sort-counting-sort"><a class="markdownIt-Anchor" href="#solution-2-bucket-sort-counting-sort"></a> Solution 2: Bucket Sort (Counting sort)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// first traverse: calculate frequencies, recode in the map</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// build buckets</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(num);</span><br><span class="line"><span class="keyword">if</span> (lists[freq] == <span class="keyword">null</span>) lists[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists[freq].add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse each bucket </span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lists.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; k != <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">res.addAll(lists[i]);</span><br><span class="line">k -= lists[i].size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;/a&gt; LeetCode Q 347 - Top K Frequent Elements&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [1], k = 1 ; Output: [1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt;: You may assume k is always valid, &lt;strong&gt;1 ≤ k ≤ number of unique elements&lt;/strong&gt;. Your algorithm’s time complexity must be better than &lt;strong&gt;O(n log n)&lt;/strong&gt;, where n is the array’s size.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Pairs</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ336/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ336/</id>
    <published>2019-04-20T16:23:37.000Z</published>
    <updated>2019-04-20T16:40:06.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-336-palindrome-pairs"><a class="markdownIt-Anchor" href="#leetcode-q-336-palindrome-pairs"></a> LeetCode Q 336 - Palindrome Pairs</h1><p>Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.</p><p>Example 1:<br><code>Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</code><br>Example 2:<br><code>Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is we first store each string and its index in the map.<br>Then, for each string, we divide it into two substrings(<strong>str1 and str2</strong>), and check all the substring pairs.</p><ol><li>if <code>str1</code> is Palindrome, then we reverse <code>str2</code>, and check if the map containsKey <code>reversedStr2</code>. If it contains, then we can concate String <code>reversedStr2</code> and <code>str1</code> to get the palindrome string. <strong>Note:</strong> the <code>reversedStr2</code> should be on the left and <code>str1</code> on the right.</li><li>if <code>str2</code> is Palindrome, then we reverse <code>str1</code>, and check if the map containsKey <code>reversedStr1</code>. If it contains, then we can concate String <code>str2</code> and <code>reversedStr1</code> to get the palindrome string. <strong>Note:</strong> the <code>str2</code> should be on the left and <code>reversedStr1</code> on the right.</li></ol><p><strong>Caution</strong>: MUST CHECK whether str.length() is equal to 0 in either if statement, because we need to make sure we do not add duplicate pairs (if str1.length() == 0, both of str1 and str2 will from input array).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)</span><br><span class="line">map.put(words[i], i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">String word = words[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word.length(); j++) &#123;</span><br><span class="line">String str1 = word.substring(<span class="number">0</span>, j);</span><br><span class="line">String str2 = word.substring(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str1)) &#123;</span><br><span class="line">String reversedStr2 = <span class="keyword">new</span> StringBuilder(str2).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr2) &amp;&amp; map.get(reversedStr2) != i &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">res.add(Arrays.asList(map.get(reversedStr2), str1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str2)) &#123;</span><br><span class="line">String reversedStr1 = <span class="keyword">new</span> StringBuilder(str1).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr1) &amp;&amp; map.get(reversedStr1) != i)</span><br><span class="line">res.add(Arrays.asList(i,map.get(reversedStr1)));   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i++) != str.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-336-palindrome-pairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-336-palindrome-pairs&quot;&gt;&lt;/a&gt; LeetCode Q 336 - Palindrome Pairs&lt;/h1&gt;
&lt;p&gt;Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&amp;quot;dcbaabcd&amp;quot;,&amp;quot;abcddcba&amp;quot;,&amp;quot;slls&amp;quot;,&amp;quot;llssssll&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&amp;quot;battab&amp;quot;,&amp;quot;tabbat&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>H-Index</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ274-1/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ274-1/</id>
    <published>2019-04-20T16:19:42.000Z</published>
    <updated>2019-04-20T16:25:17.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-274-h-index"><a class="markdownIt-Anchor" href="#leetcode-q-274-h-index"></a> LeetCode Q 274 - H-Index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><p>Similar question: <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Comparing with <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a>, the given citations is unsorted. We can still use <strong>binary search</strong> to solve this question as we did in leetcodeQ275. Then the <strong>time complexity</strong> is <strong>O(NlogN)</strong>. But we can optimize the solution using <strong>bucket sort (counting sort)</strong>. The <strong>time complexity</strong> becomes <strong>O(N)</strong>.</p><p>Assume n is the total number of papers, if we have n+1 buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket. The only exception is that for any paper with larger number of reference than n, we put in the n-th bucket.</p><p>Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result.</p><p>Some tricky cases: [5,5] -&gt; 2 [0,0] -&gt; 0</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = citations.length;</span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> citation: citations) &#123;</span><br><span class="line"><span class="keyword">if</span> (citation &gt;= len) buckets[len]++;</span><br><span class="line"><span class="keyword">else</span> buckets[citation]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">count += buckets[i];</span><br><span class="line"><span class="keyword">if</span> (count &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-274-h-index&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-274-h-index&quot;&gt;&lt;/a&gt; LeetCode Q 274 - H-Index&lt;/h1&gt;
&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
&lt;p&gt;Similar question: &lt;a href=&quot;/2019/04/15/leetcodeQ275/&quot; title=&quot;H-Index II&quot;&gt;H-Index II&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number II</title>
    <link href="http://yoursite.com/2019/04/20/lintcodtQ776/"/>
    <id>http://yoursite.com/2019/04/20/lintcodtQ776/</id>
    <published>2019-04-20T15:24:13.000Z</published>
    <updated>2019-04-20T15:30:14.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-ii"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-ii"></a> LintCode Q 644 - Strobogrammatic Number II</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Find all strobogrammatic numbers that are of length = n.</p><a href="/2019/04/20/lintcodeQ644/" title="Strobogrammatic Number (Mirror Number)">Strobogrammatic Number (Mirror Number)</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We expanded the target String <strong>from center to two sides</strong> by recursively calling the helper method.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strs = helper(n - <span class="number">2</span>, target);</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line"><span class="keyword">if</span> (n != target) res.add(<span class="string">'0'</span> + str + <span class="string">'0'</span>);</span><br><span class="line">res.add(<span class="string">'1'</span> + str + <span class="string">'1'</span>);</span><br><span class="line">res.add(<span class="string">'6'</span> + str + <span class="string">'9'</span>);</span><br><span class="line">res.add(<span class="string">'8'</span> + str + <span class="string">'8'</span>);</span><br><span class="line">res.add(<span class="string">'9'</span> + str + <span class="string">'6'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number II&lt;/h1&gt;
&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;br&gt;
Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodeQ644/&quot; title=&quot;Strobogrammatic Number (Mirror Number)&quot;&gt;Strobogrammatic Number (Mirror Number)&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number (Mirror Number)</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ644/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ644/</id>
    <published>2019-04-20T15:16:14.000Z</published>
    <updated>2019-04-20T15:25:35.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-mirror-number"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-mirror-number"></a> LintCode Q 644 - Strobogrammatic Number (Mirror Number)</h1><p>GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.</p><p>Write a function to determine if a number is mirror. The number is represented as a string.</p><a href="/2019/04/20/lintcodtQ776/" title="Strobogrammatic Number II">Strobogrammatic Number II</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrobogrammatic</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">'0'</span>, <span class="string">'0'</span>); map.put(<span class="string">'1'</span>, <span class="string">'1'</span>); map.put(<span class="string">'6'</span>, <span class="string">'9'</span>); </span><br><span class="line">map.put(<span class="string">'9'</span>, <span class="string">'6'</span>); map.put(<span class="string">'8'</span>, <span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="keyword">if</span> ( !map.containsKey(num.charAt(i)) || </span><br><span class="line">      map.get(num.charAt(i)) != map.get(num.charAt(j)))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number (Mirror Number)&lt;/h1&gt;
&lt;p&gt;GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.&lt;/p&gt;
&lt;p&gt;Write a function to determine if a number is mirror. The number is represented as a string.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodtQ776/&quot; title=&quot;Strobogrammatic Number II&quot;&gt;Strobogrammatic Number II&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ145/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ145/</id>
    <published>2019-04-19T23:08:55.000Z</published>
    <updated>2019-04-19T23:10:08.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-145-binary-tree-postorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-145-binary-tree-postorder-traversal"></a> LeetCode Q 145 - Binary Tree Postorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(<span class="number">0</span>, curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 145 - Binary Tree Postorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ144/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ144/</id>
    <published>2019-04-19T23:04:45.000Z</published>
    <updated>2019-04-19T23:10:58.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-144-binary-tree-preorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-144-binary-tree-preorder-traversal"></a> LeetCode Q 144 - Binary Tree Preorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 144 - Binary Tree Preorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Inorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ94/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ94/</id>
    <published>2019-04-19T22:55:54.000Z</published>
    <updated>2019-04-19T23:11:24.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-94-binary-tree-inorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-94-binary-tree-inorder-traversal"></a> LeetCode Q 94 - Binary Tree Inorder Traversal</h1><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">TreeNode curr = root;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123; stack.push(curr); curr = curr.left; &#125;</span><br><span class="line">curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line">curr = curr.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 94 - Binary Tree Inorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;inorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Window Substring</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ76/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ76/</id>
    <published>2019-04-19T22:32:48.000Z</published>
    <updated>2019-04-19T22:55:31.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-76-minimum-window-substring"><a class="markdownIt-Anchor" href="#leetcode-q-76-minimum-window-substring"></a> LeetCode Q 76 - Minimum Window Substring</h1><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:<br><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot;</code><br><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-sliding-window-hashtable"><a class="markdownIt-Anchor" href="#solution-sliding-window-hashtable"></a> Solution : Sliding window + HashTable</h3><p><code>arr[]:</code> denotes how many letters are still in the string <strong>T</strong>. e.g. if t = “abc”, then in the array values of ‘a’, ‘b’ and ‘c’ are both 1.<br>So, during our traversal of the string <strong>S</strong>, when we encounter ‘a’, we update the table, changing the value of ‘a’ to be 0. Next time we encounter ‘a’, we change the value of ‘a’ to be -1 …</p><p><code>count:</code> denotes how many chars are still required to get a window in S that containing all letters in T. <code>if (count == 0)</code>, we update minLen.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span> || t.length() &gt; s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: t.toCharArray()) arr[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = t.length(), l = <span class="number">0</span>, r = <span class="number">0</span>, minLen = Integer.MAX_VALUE, head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(r)] &gt; <span class="number">0</span>) count--;</span><br><span class="line">arr[s.charAt(r++)]--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l &lt; minLen) &#123; minLen = r - l; head = l; &#125;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(l)] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">arr[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(head, head + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-76-minimum-window-substring&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-76-minimum-window-substring&quot;&gt;&lt;/a&gt; LeetCode Q 76 - Minimum Window Substring&lt;/h1&gt;
&lt;p&gt;Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If there is no such window in S that covers all characters in T, return the empty string “”.&lt;/li&gt;
&lt;li&gt;If there is such window, you are guaranteed that there will always be only one unique minimum window in S.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ187</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ187/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ187/</id>
    <published>2019-04-19T22:24:42.000Z</published>
    <updated>2019-04-19T22:32:16.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-187-repeated-dna-sequences"><a class="markdownIt-Anchor" href="#leetcode-q-187-repeated-dna-sequences"></a> LeetCode Q 187 - Repeated DNA Sequences</h1><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p><p>Example:<br><code>Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot; Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>TODO: use Rabin–Karp algorithm to optimize the solution.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; repeated = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!seen.add(s.substring(i, i + <span class="number">10</span>))) </span><br><span class="line">repeated.add(s.substring(i, i + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(repeated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;/a&gt; LeetCode Q 187 - Repeated DNA Sequences&lt;/h1&gt;
&lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;
&lt;p&gt;Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ202</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ202/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ202/</id>
    <published>2019-04-19T22:22:40.000Z</published>
    <updated>2019-04-19T22:22:40.834Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcodeQ204</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ204/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ204/</id>
    <published>2019-04-19T22:15:51.000Z</published>
    <updated>2019-04-19T22:15:51.146Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sentence Similarity</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ856/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ856/</id>
    <published>2019-04-19T21:57:35.000Z</published>
    <updated>2019-04-19T22:12:04.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-856-sentence-similarity"><a class="markdownIt-Anchor" href="#lintcode-q-856-sentence-similarity"></a> LintCode Q 856 -  Sentence Similarity</h1><p>Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.</p><p>For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].</p><p><strong>Note</strong> that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are <strong>not</strong> necessarily similar.</p><p>However, <strong>similarity is symmetric</strong>. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.</p><p>Also, a word is always <strong>similar with itself</strong>. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.</p><p>Finally, <strong>sentences can only be similar if they have the same number of words</strong>. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ205/" title="Isomorphic Strings">Isomorphic Strings</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-hashmap"><a class="markdownIt-Anchor" href="#solution-hashmap"></a> Solution : HashMap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSentenceSimilarity</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (words1.length != words2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the mapping, one word may mapping to many words</span></span><br><span class="line">Map&lt;String, HashSet&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// using Set&lt;String&gt; is wrong</span></span><br><span class="line">Set&lt;String&gt; set;</span><br><span class="line"><span class="keyword">for</span> (List&lt;String&gt; pair: pairs) &#123;</span><br><span class="line">set = map.getOrDefault(pair.get(<span class="number">0</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">set.add(pair.get(<span class="number">1</span>));</span><br><span class="line">map.put(part.get(<span class="number">0</span>), set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (words1[i].equals(words2[i]))  <span class="comment">// a word is similar to itself</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> ( (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &amp;&amp; </span><br><span class="line">     (map.get(words2[i]) == <span class="keyword">null</span> || !map.get(words2[i]).contains(words1[i])) )</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-856-sentence-similarity&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-856-sentence-similarity&quot;&gt;&lt;/a&gt; LintCode Q 856 -  Sentence Similarity&lt;/h1&gt;
&lt;p&gt;Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.&lt;/p&gt;
&lt;p&gt;For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are &lt;strong&gt;not&lt;/strong&gt; necessarily similar.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;similarity is symmetric&lt;/strong&gt;. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.&lt;/p&gt;
&lt;p&gt;Also, a word is always &lt;strong&gt;similar with itself&lt;/strong&gt;. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.&lt;/p&gt;
&lt;p&gt;Finally, &lt;strong&gt;sentences can only be similar if they have the same number of words&lt;/strong&gt;. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ205/&quot; title=&quot;Isomorphic Strings&quot;&gt;Isomorphic Strings&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Isomorphic Strings</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ205/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ205/</id>
    <published>2019-04-19T21:09:39.000Z</published>
    <updated>2019-04-19T21:57:19.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-205-isomorphic-strings"><a class="markdownIt-Anchor" href="#leetcode-q-205-isomorphic-strings"></a> LeetCode Q 205 -  Isomorphic Strings</h1><p>Given two strings s and t, determine if they are isomorphic.</p><p>Two strings are isomorphic if the characters in s can be replaced to get t.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p><p>Similar Questions: <a href="/2019/04/19/lintcodeQ856/" title="Sentence Similarity">Sentence Similarity</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-hashmap"><a class="markdownIt-Anchor" href="#solution-1-hashmap"></a> Solution 1: HashMap</h3><p><code>key is the char, value is the corresponding char.</code><br><strong>One tricky is:</strong>  <code>if (map.containsValue(chs)) return false;</code><br>that is <strong>if we map ‘a’ to ‘b’, we cannot map ‘c’ to ‘b’ again.</strong><br>The mapping should be <strong>one-to-one</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> chs = s.charAt(i)), cht = t.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.get(chs) == cht) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsValue(chs)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">map.put(chs, cht);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-use-two-arrays"><a class="markdownIt-Anchor" href="#solution-2-use-two-arrays"></a> Solution 2: Use two arrays</h3><p>Instead of using a map, we can use two arrays. First, we traverse strings s and t. At index i, we check<code>if (S[chs - 'a']) != T[cht - 'a']</code>. There are 3 cases.</p><ol><li>we never encountered <code>chs</code> and <code>cht</code> before, then their values should both be 0, then we cannot go in the <code>if</code> condition;</li><li>we encountered <code>chs</code> and <code>cht</code> before, then if their values is the same, then the chars <strong>mapping</strong> remains same as before, then we then we cannot go in the <code>if</code> condition;</li><li>if their values is not same, meaning previously we don’t <strong>mapping chs</strong> to <code>cht</code>, that is the current <strong>mapping</strong> is different with previous <strong>mapping</strong>, then return false;</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[] S = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>], T = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> chs = s.charAt(i), cht = t.charAt(j);</span><br><span class="line"><span class="keyword">if</span> (S[chs - <span class="string">'a'</span>] != T[cht - <span class="string">'a'</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">S[chs - <span class="string">'a'</span>] = i + <span class="number">1</span>; T[cht - <span class="string">'a'</span>] = i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-205-isomorphic-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-205-isomorphic-strings&quot;&gt;&lt;/a&gt; LeetCode Q 205 -  Isomorphic Strings&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/lintcodeQ856/&quot; title=&quot;Sentence Similarity&quot;&gt;Sentence Similarity&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Generalized Abbreviation</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ779/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ779/</id>
    <published>2019-04-19T20:51:08.000Z</published>
    <updated>2019-04-19T21:54:01.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-779-generalized-abbreviation"><a class="markdownIt-Anchor" href="#lintcode-q-779-generalized-abbreviation"></a> LintCode Q 779 -  Generalized Abbreviation</h1><p>Write a function to generate the generalized abbreviations of a word.(order does not matter)</p><p>Example 1:<br><code>Input word = &quot;word&quot;, Output: [&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]</code><br>Example 2:<br><code>Input word = &quot;today&quot; Output: [&quot;1o1a1&quot;,&quot;1o1ay&quot;,&quot;1o2y&quot;,&quot;1o3&quot;,&quot;1od1y&quot;,&quot;1od2&quot;,&quot;1oda1&quot;,&quot;1oday&quot;,&quot;2d1y&quot;,&quot;2d2&quot;,&quot;2da1&quot;,&quot;2day&quot;,&quot;3a1&quot;,&quot;3ay&quot;,&quot;4y&quot;,&quot;5&quot;,&quot;t1d1y&quot;,&quot;t1d2&quot;,&quot;t1da1&quot;,&quot;t1day&quot;,&quot;t2a1&quot;,&quot;t2ay&quot;,&quot;t3y&quot;,&quot;t4&quot;,&quot;to1a1&quot;,&quot;to1ay&quot;,&quot;to2y&quot;,&quot;to3&quot;,&quot;tod1y&quot;,&quot;tod2&quot;,&quot;toda1&quot;,&quot;today&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Use backtracking:</p><p><strong>Our choice:</strong> use a digit or some chars to represent a word.<br><strong>Our constraints:</strong> abbreviation should be valid, what is a valid abbrivation we can check <a href="/2019/04/19/lintcodeQ637/" title="Valid Word Abbreviation">Valid Word Abbreviation</a>.<br><strong>Our goal:</strong> generate abbreviations.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateAbbreviations</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">help(res, word, <span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;String&gt; res, String word, <span class="keyword">int</span> pos, String curr, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case, our constraints</span></span><br><span class="line"><span class="keyword">if</span> (pos == word.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) curr = curr + count;</span><br><span class="line">res.add(curr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// explore, out choice is using a number to represent a letter</span></span><br><span class="line"><span class="comment">// When calling it self, the pos should + 1 and count + 1 and curr string is unchanged.</span></span><br><span class="line">help(res, word, pos + <span class="number">1</span>, curr, count + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// backtrack, we need to update the curr</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) curr = curr + count + word.charAt(pos);</span><br><span class="line"><span class="keyword">else</span> curr = curr + word.charAt(pos);</span><br><span class="line"><span class="comment">// explore, our choice is using the char at that position</span></span><br><span class="line"><span class="comment">// When calling it self, the pos should + 1, the count is now to be 0 and curr string is the updated one.</span></span><br><span class="line">help(res, word, pos + <span class="number">1</span>, curr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-779-generalized-abbreviation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-779-generalized-abbreviation&quot;&gt;&lt;/a&gt; LintCode Q 779 -  Generalized Abbreviation&lt;/h1&gt;
&lt;p&gt;Write a function to generate the generalized abbreviations of a word.(order does not matter)&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input word = &amp;quot;word&amp;quot;, Output: [&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input word = &amp;quot;today&amp;quot; Output: [&amp;quot;1o1a1&amp;quot;,&amp;quot;1o1ay&amp;quot;,&amp;quot;1o2y&amp;quot;,&amp;quot;1o3&amp;quot;,&amp;quot;1od1y&amp;quot;,&amp;quot;1od2&amp;quot;,&amp;quot;1oda1&amp;quot;,&amp;quot;1oday&amp;quot;,&amp;quot;2d1y&amp;quot;,&amp;quot;2d2&amp;quot;,&amp;quot;2da1&amp;quot;,&amp;quot;2day&amp;quot;,&amp;quot;3a1&amp;quot;,&amp;quot;3ay&amp;quot;,&amp;quot;4y&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;t1d1y&amp;quot;,&amp;quot;t1d2&amp;quot;,&amp;quot;t1da1&amp;quot;,&amp;quot;t1day&amp;quot;,&amp;quot;t2a1&amp;quot;,&amp;quot;t2ay&amp;quot;,&amp;quot;t3y&amp;quot;,&amp;quot;t4&amp;quot;,&amp;quot;to1a1&amp;quot;,&amp;quot;to1ay&amp;quot;,&amp;quot;to2y&amp;quot;,&amp;quot;to3&amp;quot;,&amp;quot;tod1y&amp;quot;,&amp;quot;tod2&amp;quot;,&amp;quot;toda1&amp;quot;,&amp;quot;today&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Valid Word Abbreviation</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ637/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ637/</id>
    <published>2019-04-19T20:39:48.000Z</published>
    <updated>2019-04-19T20:57:40.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-637-valid-word-abbreviation"><a class="markdownIt-Anchor" href="#lintcode-q-637-valid-word-abbreviation"></a> LintCode Q 637 - Valid Word Abbreviation</h1><p>Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.</p><p>A string such as “word” contains only the following valid abbreviations:</p><p><code>[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>This is a String matching question, we can use two pointers method.<br>Be careful about boundary cases. <strong>For example:</strong><br><code>the char is '0'</code>;</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validWordAbbreviation</span><span class="params">(String word, String abbr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word.length() != abbr.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; word.length() &amp;&amp; j &lt; abbr.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(abbr.charAt(j))) &#123;</span><br><span class="line"><span class="keyword">if</span> (word.charAt(i++) != abbr.charAt(j++)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (abbr.charAt(j) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; abbr.length() &amp;&amp; abbr.charAt(j)) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + abbr.charAt(i) - <span class="string">'0'</span>; j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i == word.length() &amp;&amp; j == abbr.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-637-valid-word-abbreviation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-637-valid-word-abbreviation&quot;&gt;&lt;/a&gt; LintCode Q 637 - Valid Word Abbreviation&lt;/h1&gt;
&lt;p&gt;Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.&lt;/p&gt;
&lt;p&gt;A string such as “word” contains only the following valid abbreviations:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Contains Duplicate II</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ219/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ219/</id>
    <published>2019-04-19T17:25:35.000Z</published>
    <updated>2019-04-19T17:38:13.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-217-contains-duplicate-ii"><a class="markdownIt-Anchor" href="#leetcode-q-217-contains-duplicate-ii"></a> LeetCode Q 217 - Contains Duplicate II</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that <code>nums[i] = nums[j]</code> and the absolute difference between i and j is <strong>at most k</strong>.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong><font color="#06bcf9">Note: Don’t forget the update the index of duplicated number.</font></strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(nums[i])) map.put(nums[i], i);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Integer left = map.get(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (i - left &lt;= k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> map.put(nums[i], i); <span class="comment">// don't forget to update the position of nums[i]!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-217-contains-duplicate-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-217-contains-duplicate-ii&quot;&gt;&lt;/a&gt; LeetCode Q 217 - Contains Duplicate II&lt;/h1&gt;
&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that &lt;code&gt;nums[i] = nums[j]&lt;/code&gt; and the absolute difference between i and j is &lt;strong&gt;at most k&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
</feed>
