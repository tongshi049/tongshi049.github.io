<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-14T17:53:03.173Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Minimum Size Subarray Sum</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ209/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ209/</id>
    <published>2019-04-14T17:36:58.000Z</published>
    <updated>2019-04-14T17:53:03.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-209-Minimum-Size-Subarray-Sum"><a href="#LeetCode-Q-209-Minimum-Size-Subarray-Sum" class="headerlink" title="LeetCode Q 209 - Minimum Size Subarray Sum"></a>LeetCode Q 209 - Minimum Size Subarray Sum</h1><p>Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Method-1-Sliding-Window"><a href="#Method-1-Sliding-Window" class="headerlink" title="Method 1: Sliding Window"></a>Method 1: Sliding Window</h3><p><strong>Time Complexity: O(n)</strong></p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, minLength = Integer.MAX_VALUE, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">sum += nums[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right &amp;&amp; sum &gt; s) &#123;</span><br><span class="line">minLength = Math.min(minLength, right - left + <span class="number">1</span>);</span><br><span class="line">sum -= nums[left++];</span><br><span class="line">&#125;</span><br><span class="line">right++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Method-2-Binary-Search"><a href="#Method-2-Binary-Search" class="headerlink" title="Method 2: Binary Search"></a>Method 2: Binary Search</h3><p>Since the given array contains only positive integers, the subarray sum can only increase by including more elements. Therefore, you don’t have to include more elements once the current subarray already has a sum large enough. This gives the linear time complexity solution by maintaining a minimum window with a two indices.</p><p>As to NLogN solution, logN immediately reminds you of binary search. In this case, you cannot sort as the current order actually matters. How does one get an ordered array then? Since all elements are positive, the cumulative sum must be strictly increasing. Then, a subarray sum can expressed as the difference between two cumulative sum. Hence, given a start index for the cumulative sum array, the other end index can be searched using binary search</p><p><strong>Time Complexity: O(nlogn)</strong></p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) sums[i] = nums[i - <span class="number">1</span>] + sums[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> minLength = Integer.MAX_VALUE</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> end = binarySearch(sums, i + <span class="number">1</span>, sums.length - <span class="number">1</span>, s + sums[i]);</span><br><span class="line"><span class="keyword">if</span> (end == sums.length) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> (end - i &lt; minLength) minLength = end - i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] sums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (sums[lo] + sums[hi]) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt;= key) </span><br><span class="line">hi = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">lo = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-209-Minimum-Size-Subarray-Sum&quot;&gt;&lt;a href=&quot;#LeetCode-Q-209-Minimum-Size-Subarray-Sum&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 209 - Minimum Size Subarray Sum&quot;&gt;&lt;/a&gt;LeetCode Q 209 - Minimum Size Subarray Sum&lt;/h1&gt;&lt;p&gt;Given an array of &lt;strong&gt;n&lt;/strong&gt; positive integers and a positive integer &lt;strong&gt;s&lt;/strong&gt;, find the minimal length of a &lt;strong&gt;contiguous&lt;/strong&gt; subarray of which the sum ≥ s. If there isn’t one, return 0 instead.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum II - Input array is sorted</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ167-1/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ167-1/</id>
    <published>2019-04-14T17:35:27.000Z</published>
    <updated>2019-04-14T17:36:21.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-167-Two-Sum-II-Input-array-is-sorted"><a href="#LeetCode-Q-167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="LeetCode Q 167 - Two Sum II - Input array is sorted"></a>LeetCode Q 167 - Two Sum II - Input array is sorted</h1><p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">int</span> idx1 = <span class="number">0</span>, idx2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (numbers[idx1] + numbers[idx2] != target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers[idx1] + numbers[idx2] &gt; target)</span><br><span class="line">            idx2--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            idx1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;idx1 + <span class="number">1</span>, idx2 + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-167-Two-Sum-II-Input-array-is-sorted&quot;&gt;&lt;a href=&quot;#LeetCode-Q-167-Two-Sum-II-Input-array-is-sorted&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 167 - Two Sum II - Input array is sorted&quot;&gt;&lt;/a&gt;LeetCode Q 167 - Two Sum II - Input array is sorted&lt;/h1&gt;&lt;p&gt;Given an array of integers that is already &lt;strong&gt;&lt;em&gt;sorted in ascending order&lt;/em&gt;&lt;/strong&gt;, find two numbers such that they add up to a specific target number.&lt;/p&gt;
&lt;p&gt;The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find Peak Element</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ162/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ162/</id>
    <published>2019-04-14T17:09:42.000Z</published>
    <updated>2019-04-14T17:33:12.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-162-Find-Peak-Element"><a href="#LeetCode-Q-162-Find-Peak-Element" class="headerlink" title="LeetCode Q 162 - Find Peak Element"></a>LeetCode Q 162 - Find Peak Element</h1><p>A peak element is an element that is greater than its neighbors.<br>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that nums[-1] = nums[n] = -∞.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) </span><br><span class="line">right = mid;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-162-Find-Peak-Element&quot;&gt;&lt;a href=&quot;#LeetCode-Q-162-Find-Peak-Element&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 162 - Find Peak Element&quot;&gt;&lt;/a&gt;LeetCode Q 162 - Find Peak Element&lt;/h1&gt;&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;br&gt;Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.&lt;br&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;br&gt;You may imagine that nums[-1] = nums[n] = -∞.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Count Complete Tree Nodes</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ222/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ222/</id>
    <published>2019-04-14T16:08:19.000Z</published>
    <updated>2019-04-14T17:30:53.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-222-Count-Complete-Tree-Nodes"><a href="#LeetCode-Q-222-Count-Complete-Tree-Nodes" class="headerlink" title="LeetCode Q 222 - Count Complete Tree Nodes"></a>LeetCode Q 222 - Count Complete Tree Nodes</h1><p>Given a complete binary tree, count the number of nodes.</p><p><strong>Note</strong>:<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Method-1"><a href="#Method-1" class="headerlink" title="Method 1"></a>Method 1</h3><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The time complexity of this method O(n). We can do it better as follows.</p><h3 id="Method-2"><a href="#Method-2" class="headerlink" title="Method 2"></a>Method 2</h3><p>First, use divide and conquer to find the number of nodes.<br>We use <code>height(root) ==  height(root.right) - 1</code> to check if the child is a complete tree.</p><ul><li>If it is, then we can let <code>root = root.right</code>and find the number of nodes in the right child.</li><li>If it isn’t, then we can let <code>root = root.left</code> and find the number of nodes in the left child.</li></ul><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//return countNodesRecursive(root);</span></span><br><span class="line"><span class="keyword">return</span> countNodesIterative(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodesRecursive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> height = getHeight(root);</span><br><span class="line"><span class="keyword">return</span> height &lt; <span class="number">0</span> ? <span class="number">0</span> : getHeight(root.right) == height - <span class="number">1</span> ? (<span class="number">1</span> &lt;&lt; height) + countNodes(root.right) : (<span class="number">1</span> &lt;&lt; (height - <span class="number">1</span>)) + countNodes(root.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodesIterative</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>, height = getHeight(root);</span><br><span class="line"><span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (getHeight(root.right) == height - <span class="number">1</span>) &#123;</span><br><span class="line">count += <span class="number">1</span> &lt;&lt; height;</span><br><span class="line">root = root.right;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count += <span class="number">1</span> &lt;&lt; (height - <span class="number">1</span>);</span><br><span class="line">root = root.left;</span><br><span class="line">&#125;</span><br><span class="line">height--; <span class="comment">// don't forget this.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> root == <span class="keyword">null</span> ? -<span class="number">1</span> : <span class="number">1</span> + getHeight(root.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-222-Count-Complete-Tree-Nodes&quot;&gt;&lt;a href=&quot;#LeetCode-Q-222-Count-Complete-Tree-Nodes&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 222 - Count Complete Tree Nodes&quot;&gt;&lt;/a&gt;LeetCode Q 222 - Count Complete Tree Nodes&lt;/h1&gt;&lt;p&gt;Given a complete binary tree, count the number of nodes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;br&gt;Definition of a complete binary tree from Wikipedia:&lt;br&gt;In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Search a 2D Matrix II</title>
    <link href="http://yoursite.com/2019/04/14/leetcodeQ240/"/>
    <id>http://yoursite.com/2019/04/14/leetcodeQ240/</id>
    <published>2019-04-14T16:03:51.000Z</published>
    <updated>2019-04-14T16:39:16.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-240-Search-a-2D-Matrix-II"><a href="#LeetCode-Q-240-Search-a-2D-Matrix-II" class="headerlink" title="LeetCode Q 240 - Search a 2D Matrix II"></a>LeetCode Q 240 - Search a 2D Matrix II</h1><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.<a id="more"></a></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Begin our search at the top right corner of the matrix.</p><ul><li>If the target is large than this number, then we find numbers below it.</li><li>If the target is small than this number, then we find numbers on the left of it.</li></ul><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (r &lt; row &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[r][c] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[r][c] &lt; target)</span><br><span class="line">            r++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-240-Search-a-2D-Matrix-II&quot;&gt;&lt;a href=&quot;#LeetCode-Q-240-Search-a-2D-Matrix-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 240 - Search a 2D Matrix II&quot;&gt;&lt;/a&gt;LeetCode Q 240 - Search a 2D Matrix II&lt;/h1&gt;&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted in ascending from left to right.&lt;/li&gt;
&lt;li&gt;Integers in each column are sorted in ascending from top to bottom.
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Search a 2D Matrix</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ74/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ74/</id>
    <published>2019-04-12T21:35:15.000Z</published>
    <updated>2019-04-14T16:04:30.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-74-Search-a-2D-Matrix"><a href="#LeetCode-Q-74-Search-a-2D-Matrix" class="headerlink" title="LeetCode Q 74 - Search a 2D Matrix"></a>LeetCode Q 74 - Search a 2D Matrix</h1><p>Write an efficient algorithm that searches for a value in an <em>m</em> x <em>n</em> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.<a id="more"></a></li></ul><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>We can solve this problem by two methods.</p><p><strong>Method 1:</strong></p><ul><li>Use binary search to find the row no.</li><li>Use binary search to find the number in that row.</li></ul><p><strong>Method 2:</strong></p><ul><li>Take the matrix as an array, and then do the binary search<br><strong>key point is</strong> how to translate the index to row and col no.<br><code>nums[index] = nums[index / col][index % col];</code></li></ul><p><strong>Code: Method 1</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> </span><br><span class="line">        || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// do binary search once</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = row * col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> number = matrix[mid / col][mid % col];</span><br><span class="line">        <span class="keyword">if</span> (number == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (number &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Code: Method 2</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span> </span><br><span class="line">        || target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. find in which row the target may exist, use start as the row index</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = row - <span class="number">1</span>, rowIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &gt; target)</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == row - <span class="number">1</span> || matrix[mid + <span class="number">1</span>][<span class="number">0</span>] &gt; target) &#123;</span><br><span class="line">                start = mid; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now the start represents that row index</span></span><br><span class="line">    <span class="comment">// then use binary searth to find the element</span></span><br><span class="line">    <span class="keyword">return</span> helper(matrix[start], <span class="number">0</span>, col - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-74-Search-a-2D-Matrix&quot;&gt;&lt;a href=&quot;#LeetCode-Q-74-Search-a-2D-Matrix&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 74 - Search a 2D Matrix&quot;&gt;&lt;/a&gt;LeetCode Q 74 - Search a 2D Matrix&lt;/h1&gt;&lt;p&gt;Write an efficient algorithm that searches for a value in an &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; matrix. This matrix has the following properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integers in each row are sorted from left to right.&lt;/li&gt;
&lt;li&gt;The first integer of each row is greater than the last integer of the previous row.
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find First and Last Position of Element in Sorted Array</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ34/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ34/</id>
    <published>2019-04-12T21:26:54.000Z</published>
    <updated>2019-04-12T21:34:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#LeetCode-Q-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="LeetCode Q 34 - Find First and Last Position of Element in Sorted Array"></a>LeetCode Q 34 - Find First and Last Position of Element in Sorted Array</h1><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm’s runtime complexity must be in the order of <strong>O(log n)</strong>.</p><p>If the target is not found in the array, return [-1, -1].<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>First we use binary search to find the target number, if it exists then we want to find the first and last index.<br>When finding these two indexes, we should also use binary search. Or our algorithm has a potential to become linear search when the data is like [1,1,1,1,1,1,1,2,3], then the time complexity would become <strong>O(n)</strong>.</p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">eturn <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line"><span class="keyword">int</span> index = bs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (index == -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">Arrays.fill(res, index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// find the left boundary</span></span><br><span class="line">left = index;</span><br><span class="line"><span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">left = bs(nums, <span class="number">0</span>, left - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> res[<span class="number">0</span>] = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the right boundary</span></span><br><span class="line">right = index;</span><br><span class="line"><span class="keyword">while</span> (right &lt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">right = bs(nums, right + <span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span> res[<span class="number">1</span>] = right;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array&quot;&gt;&lt;a href=&quot;#LeetCode-Q-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 34 - Find First and Last Position of Element in Sorted Array&quot;&gt;&lt;/a&gt;LeetCode Q 34 - Find First and Last Position of Element in Sorted Array&lt;/h1&gt;&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;
&lt;p&gt;Your algorithm’s runtime complexity must be in the order of &lt;strong&gt;O(log n)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Search Insert Position</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ35/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ35/</id>
    <published>2019-04-12T21:20:36.000Z</published>
    <updated>2019-04-12T21:25:56.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-35-Search-Insert-Position"><a href="#LeetCode-Q-35-Search-Insert-Position" class="headerlink" title="LeetCode Q 35 - Search Insert Position"></a>LeetCode Q 35 - Search Insert Position</h1><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You may assume no duplicates in the array.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || target &lt;= nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-35-Search-Insert-Position&quot;&gt;&lt;a href=&quot;#LeetCode-Q-35-Search-Insert-Position&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 35 - Search Insert Position&quot;&gt;&lt;/a&gt;LeetCode Q 35 - Search Insert Position&lt;/h1&gt;&lt;p&gt;Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.&lt;/p&gt;
&lt;p&gt;You may assume no duplicates in the array.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Largest Divisible Subset</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ368/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ368/</id>
    <published>2019-04-12T21:05:20.000Z</published>
    <updated>2019-04-12T21:20:20.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-368-Largest-Divisible-Subset"><a href="#LeetCode-Q-368-Largest-Divisible-Subset" class="headerlink" title="LeetCode Q 368 - Largest Divisible Subset"></a>LeetCode Q 368 - Largest Divisible Subset</h1><p>Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: <code>Si % Sj = 0 or Sj % Si = 0</code></p><p>If there are multiple solutions, return any subset is fine.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>We can solve this problem following these four steps:</p><ol><li>Sort</li><li>Find the length of longest subset</li><li>Record the largest element of it.</li><li>Do a loop from the largest element to nums[0], add every element belongs to the longest subset.</li></ol><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">largestDivisibleSubset</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">// 1. sort</span></span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Find the length of longest subset</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="comment">// records the number of each subset contains i</span></span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line"><span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Record the largest element of it.</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i] &gt;= dp[maxIndex])</span><br><span class="line">maxIndex = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Do a loop from the largest element to nums[0], add every element belongs to the longest subset. -- easily making mistake at this step</span></span><br><span class="line"><span class="keyword">int</span> temp = nums[maxIndex];</span><br><span class="line"><span class="keyword">int</span> val = dp[maxIndex];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = maxIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (val == dp[i] &amp;&amp; temp % nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(nums[i]);</span><br><span class="line">temp = nums[i];</span><br><span class="line">val--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-368-Largest-Divisible-Subset&quot;&gt;&lt;a href=&quot;#LeetCode-Q-368-Largest-Divisible-Subset&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 368 - Largest Divisible Subset&quot;&gt;&lt;/a&gt;LeetCode Q 368 - Largest Divisible Subset&lt;/h1&gt;&lt;p&gt;Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: &lt;code&gt;Si % Sj = 0 or Sj % Si = 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If there are multiple solutions, return any subset is fine.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>Median of Two Sorted Arrays</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ4/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ4/</id>
    <published>2019-04-12T20:48:12.000Z</published>
    <updated>2019-04-12T21:04:41.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-4-Median-of-Two-Sorted-Arrays"><a href="#LeetCode-Q-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="LeetCode Q 4 - Median of Two Sorted Arrays"></a>LeetCode Q 4 - Median of Two Sorted Arrays</h1><p>There are two sorted arrays <strong>nums1</strong> and <strong>nums2</strong> of size m and n respectively.</p><p>Find the median of the two sorted arrays. The overall run time complexity should be <strong>O(log (m+n))</strong>.</p><p>You may assume <strong>nums1</strong> and <strong>nums2</strong> cannot be both empty.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>This solution is following the idea in Tushar’s Youtube video. This video provides a quite clear and comprehensive description of the solution.<br>You can find this video <a href="https://www.youtube.com/watch?v=LPFhl65R7ww" target="_blank" rel="noopener">here</a>.</p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums1.length &gt; nums2.length) <span class="keyword">return</span> findMedianSortedArrays(nums1, nums2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = num1.length, len2 = num2.length;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = len1;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> partitionX = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> partitionY = (len1 + len2 + <span class="number">1</span>) / <span class="number">2</span> - partitionX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> leftX = partitionX == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[partitionX - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> leftY = partitionY == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[partitionY - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rightX = partitionX == len1 ? Integer.MAX_VALUE : nums1[partitionX];</span><br><span class="line"><span class="keyword">int</span> rightY = partitionY == len2 ? Integer.MAX_VALUE : nums2[partitionY];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (leftX &lt;= rightY &amp;&amp; leftY &lt;= rightX) &#123;</span><br><span class="line"><span class="keyword">if</span> ((len1 + len2) % <span class="number">2</span> = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> Math.max(leftX, leftY);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> (Math.max(leftX, leftY) + Math.min(rightX, rightY)) / <span class="number">2.0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftX &gt; rightY) &#123;</span><br><span class="line">right = partitionX - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = partitionX + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-4-Median-of-Two-Sorted-Arrays&quot;&gt;&lt;a href=&quot;#LeetCode-Q-4-Median-of-Two-Sorted-Arrays&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 4 - Median of Two Sorted Arrays&quot;&gt;&lt;/a&gt;LeetCode Q 4 - Median of Two Sorted Arrays&lt;/h1&gt;&lt;p&gt;There are two sorted arrays &lt;strong&gt;nums1&lt;/strong&gt; and &lt;strong&gt;nums2&lt;/strong&gt; of size m and n respectively.&lt;/p&gt;
&lt;p&gt;Find the median of the two sorted arrays. The overall run time complexity should be &lt;strong&gt;O(log (m+n))&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;You may assume &lt;strong&gt;nums1&lt;/strong&gt; and &lt;strong&gt;nums2&lt;/strong&gt; cannot be both empty.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Find Minimum in Rotated Sorted Array II</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ154/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ154/</id>
    <published>2019-04-12T17:56:16.000Z</published>
    <updated>2019-04-12T18:10:39.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#LeetCode-Q-154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="LeetCode Q 154 - Find Minimum in Rotated Sorted Array II"></a>LeetCode Q 154 - Find Minimum in Rotated Sorted Array II</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).<br>Find the minimum element. The array may contain <strong>duplicates</strong>.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Similar to Q81, in the worst case, the time complexity becomes O(n).<br>So, we don’t need to use binary search.</p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; min) min = nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Code: Use fake binary sesarch</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == nums[nums.length - <span class="number">1</span>]) right--;</span><br><span class="line"><span class="comment">//When num[mid] == num[hi], we couldn't sure the position of minimum in mid's left or right, </span></span><br><span class="line"><span class="comment">//so just let upper bound reduce one.</span></span><br><span class="line"><span class="keyword">else</span> right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-154-Find-Minimum-in-Rotated-Sorted-Array-II&quot;&gt;&lt;a href=&quot;#LeetCode-Q-154-Find-Minimum-in-Rotated-Sorted-Array-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 154 - Find Minimum in Rotated Sorted Array II&quot;&gt;&lt;/a&gt;LeetCode Q 154 - Find Minimum in Rotated Sorted Array II&lt;/h1&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).&lt;br&gt;Find the minimum element. The array may contain &lt;strong&gt;duplicates&lt;/strong&gt;.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Find Minimum in Rotated Sorted Array</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ153/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ153/</id>
    <published>2019-04-12T17:54:02.000Z</published>
    <updated>2019-04-12T17:56:01.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#LeetCode-Q-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode Q 153 - Find Minimum in Rotated Sorted Array"></a>LeetCode Q 153 - Find Minimum in Rotated Sorted Array</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).<br>Find the minimum element.<br>You may assume <strong>no duplicate</strong> exists in the array.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (left == right || nums[left] &lt; nums[right])</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-153-Find-Minimum-in-Rotated-Sorted-Array&quot;&gt;&lt;a href=&quot;#LeetCode-Q-153-Find-Minimum-in-Rotated-Sorted-Array&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 153 - Find Minimum in Rotated Sorted Array&quot;&gt;&lt;/a&gt;LeetCode Q 153 - Find Minimum in Rotated Sorted Array&lt;/h1&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).&lt;br&gt;Find the minimum element.&lt;br&gt;You may assume &lt;strong&gt;no duplicate&lt;/strong&gt; exists in the array.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Search in Rotated Sorted Array II</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ81/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ81/</id>
    <published>2019-04-12T17:46:22.000Z</published>
    <updated>2019-04-12T17:53:29.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-81-Search-in-Rotated-Sorted-Array-II"><a href="#LeetCode-Q-81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="LeetCode Q 81 - Search in Rotated Sorted Array II"></a>LeetCode Q 81 - Search in Rotated Sorted Array II</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).<br>You are given a target value to search. If found in the array return true, otherwise return false.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>For this question, we need to know the <strong>worst case</strong> is<br><strong>there is a 0 in the array like [1, 1, 1, 1, 1,…, 1].</strong><br>In this case, we cannot use binary search. The time complexity of the algorithm will become O(n).<br>Therefore, we can just use a for loop to solve it.<br>This question is testing whether we can think of the worst case.</p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> booelan <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (num == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-81-Search-in-Rotated-Sorted-Array-II&quot;&gt;&lt;a href=&quot;#LeetCode-Q-81-Search-in-Rotated-Sorted-Array-II&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 81 - Search in Rotated Sorted Array II&quot;&gt;&lt;/a&gt;LeetCode Q 81 - Search in Rotated Sorted Array II&lt;/h1&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).&lt;br&gt;You are given a target value to search. If found in the array return true, otherwise return false.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Search in Rotated Sorted Array</title>
    <link href="http://yoursite.com/2019/04/12/leetcodeQ33/"/>
    <id>http://yoursite.com/2019/04/12/leetcodeQ33/</id>
    <published>2019-04-12T17:37:49.000Z</published>
    <updated>2019-04-12T17:46:01.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-33-Search-in-Rotated-Sorted-Array"><a href="#LeetCode-Q-33-Search-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode Q 33 - Search in Rotated Sorted Array"></a>LeetCode Q 33 - Search in Rotated Sorted Array</h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.<br>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).<br>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume <strong>no duplicate</strong> exists in the array.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// find the rotation position</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] &gt; nums[nums.length - <span class="number">1</span>])</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// now left indicates the rotation position, i.e left is the index of minimum number in the array</span></span><br><span class="line"><span class="keyword">if</span> (nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> binarySearch(nums, <span class="number">0</span>, left - <span class="number">1</span>, target);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> binarySearch(nums, left + <span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-33-Search-in-Rotated-Sorted-Array&quot;&gt;&lt;a href=&quot;#LeetCode-Q-33-Search-in-Rotated-Sorted-Array&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 33 - Search in Rotated Sorted Array&quot;&gt;&lt;/a&gt;LeetCode Q 33 - Search in Rotated Sorted Array&lt;/h1&gt;&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;br&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;br&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;
&lt;p&gt;You may assume &lt;strong&gt;no duplicate&lt;/strong&gt; exists in the array.&lt;br&gt;Your algorithm’s runtime complexity must be in the order of O(log n).&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Java Thread - currentThread() methods</title>
    <link href="http://yoursite.com/2019/04/11/multithreading-currentThread/"/>
    <id>http://yoursite.com/2019/04/11/multithreading-currentThread/</id>
    <published>2019-04-11T18:19:37.000Z</published>
    <updated>2019-04-11T18:43:37.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h2><p>The <strong>java.lang.Thread.currentThread()</strong> method returns a reference to the currently executing thread object<br><a id="more"></a><br><strong>EXAMPLE</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreaTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Fight"</span>);</span><br><span class="line">System.out.println(<span class="string">"Current Thread is: "</span> + Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">attack();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"current main thread is: "</span> + Thread.currentThread().getName());</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>OUTPUT</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">current main thread is: main</span><br><span class="line">Fight</span><br><span class="line">Current Thread is: Thread-<span class="number">0</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;currentThread&quot;&gt;&lt;a href=&quot;#currentThread&quot; class=&quot;headerlink&quot; title=&quot;currentThread()&quot;&gt;&lt;/a&gt;currentThread()&lt;/h2&gt;&lt;p&gt;The &lt;strong&gt;java.lang.Thread.currentThread()&lt;/strong&gt; method returns a reference to the currently executing thread object&lt;br&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="http://yoursite.com/tags/Java-Basic/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java Thread II - Lifecycle and States</title>
    <link href="http://yoursite.com/2019/04/11/threadII/"/>
    <id>http://yoursite.com/2019/04/11/threadII/</id>
    <published>2019-04-11T17:50:45.000Z</published>
    <updated>2019-04-11T18:33:18.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lifecycle-and-States-of-a-Thread-in-Java-to-be-continued"><a href="#Lifecycle-and-States-of-a-Thread-in-Java-to-be-continued" class="headerlink" title="Lifecycle and States of a Thread in Java (to be continued)"></a>Lifecycle and States of a Thread in Java (to be continued)</h1><p><strong>States:</strong><br>1) New, 2) Runnable, 3) Blocked, 4) Waiting, 5) Timed Waiting, 6) Terminated</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lifecycle-and-States-of-a-Thread-in-Java-to-be-continued&quot;&gt;&lt;a href=&quot;#Lifecycle-and-States-of-a-Thread-in-Java-to-be-continued&quot; class=
      
    
    </summary>
    
    
      <category term="Java Basic" scheme="http://yoursite.com/tags/Java-Basic/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java Thread I - Creation</title>
    <link href="http://yoursite.com/2019/04/11/multithread/"/>
    <id>http://yoursite.com/2019/04/11/multithread/</id>
    <published>2019-04-11T16:00:37.000Z</published>
    <updated>2019-04-11T18:43:27.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h1><p>Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.<br><a id="more"></a><br><strong>Threads can be created by using two mechanisms:</strong></p><ol><li>Extending the Thread class</li><li>Implementing the Runnable Interface**</li></ol><h2 id="Thread-cration-by-extending-the-Thread-class"><a href="#Thread-cration-by-extending-the-Thread-class" class="headerlink" title="Thread cration by extending the Thread class"></a>Thread cration by extending the Thread class</h2><ul><li>create a class that extends the <strong>java.lang.Thread</strong> class</li><li>override the run() method, a thread begins its life inside run() method.</li><li>call start() method to start the execution of a thread. Start() invokes the run() method on the Thread object</li></ul><p><strong>Example:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread start: "</span> + <span class="keyword">this</span>.name + <span class="string">", i= "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</span><br><span class="line">        MyThread mt3 = <span class="keyword">new</span> MyThread(<span class="string">"thread3"</span>);</span><br><span class="line"></span><br><span class="line">        mt1.start();</span><br><span class="line">        mt2.start();</span><br><span class="line">        mt3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Thread-cration-by-implementing-the-Runnable-interface"><a href="#Thread-cration-by-implementing-the-Runnable-interface" class="headerlink" title="Thread cration by implementing the Runnable interface"></a>Thread cration by implementing the Runnable interface</h2><ul><li>create a new class which implements java.lang.Runnable interface</li><li>override run() method</li><li>construct an object of the new class</li><li>instantiate a Thread object from the Runaable: Thread t = new Thread(r)</li><li>call start() method on this object</li></ul><p><strong>Example:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"Thread start: "</span> + <span class="keyword">this</span>.name + <span class="string">", i= "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">MyRunnable mr1 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable1"</span>);</span><br><span class="line">MyRunnable mr2 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable2"</span>);</span><br><span class="line">MyRunnable mr3 = <span class="keyword">new</span> MyRunnable(<span class="string">"Runnable3"</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(mr1);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(mr2);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(mr3);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Supplymentary"><a href="#Supplymentary" class="headerlink" title="Supplymentary"></a>Supplymentary</h2><h3 id="java-lang-Thread"><a href="#java-lang-Thread" class="headerlink" title="java.lang.Thread"></a>java.lang.Thread</h3><ul><li>Thread(Runnable target)<br>constructs a new thread that calls the run() method of the specified target</li><li>void start()<br>starts this thread, causing the run() method to be called. This method will return immediately. The new thread runs concurrently.</li><li>void run()<br>calls the run method of the associated Runnable.</li></ul><h3 id="java-lang-Runnable"><a href="#java-lang-Runnable" class="headerlink" title="java.lang.Runnable"></a>java.lang.Runnable</h3><ul><li>void run()<br>must be overriden and supplied with instructions for the task that you want to have executed.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Multithreading&quot;&gt;&lt;a href=&quot;#Multithreading&quot; class=&quot;headerlink&quot; title=&quot;Multithreading&quot;&gt;&lt;/a&gt;Multithreading&lt;/h1&gt;&lt;p&gt;Multithreading is a Java feature that allows concurrent execution of two or more parts of a program for maximum utilization of CPU. Each part of such program is called a thread. So, threads are light-weight processes within a process.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java Basic" scheme="http://yoursite.com/tags/Java-Basic/"/>
    
      <category term="Thread" scheme="http://yoursite.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Valid Perfect Square</title>
    <link href="http://yoursite.com/2019/04/11/leetcodeQ367/"/>
    <id>http://yoursite.com/2019/04/11/leetcodeQ367/</id>
    <published>2019-04-11T15:49:10.000Z</published>
    <updated>2019-04-11T15:53:13.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-367-Valid-Perfect-Square"><a href="#LeetCode-Q-367-Valid-Perfect-Square" class="headerlink" title="LeetCode Q 367 - Valid Perfect Square"></a>LeetCode Q 367 - Valid Perfect Square</h1><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p><p><strong>Note: Do not</strong> use any built-in library function such as sqrt.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">1</span>, right = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num % mid == <span class="number">0</span> &amp;&amp; mid == num / mid)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; num / mid)</span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (mid + <span class="number">1</span> &gt; num / (mid + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-367-Valid-Perfect-Square&quot;&gt;&lt;a href=&quot;#LeetCode-Q-367-Valid-Perfect-Square&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 367 - Valid Perfect Square&quot;&gt;&lt;/a&gt;LeetCode Q 367 - Valid Perfect Square&lt;/h1&gt;&lt;p&gt;Given a positive integer num, write a function which returns True if num is a perfect square else False.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note: Do not&lt;/strong&gt; use any built-in library function such as sqrt.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Integer Break</title>
    <link href="http://yoursite.com/2019/04/11/leetcodeQ343/"/>
    <id>http://yoursite.com/2019/04/11/leetcodeQ343/</id>
    <published>2019-04-11T15:40:21.000Z</published>
    <updated>2019-04-11T15:48:44.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-343-Integer-Break"><a href="#LeetCode-Q-343-Integer-Break" class="headerlink" title="LeetCode Q 343 - Integer Break"></a>LeetCode Q 343 - Integer Break</h1><p>Given a positive integer n, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>DP function:</strong><br><code>dp[n] = Max{Max(dp[i], i) * Max(dp[n - i], n - i)},  i &lt; n</code></p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// dp[1] = 1; dp[2] = 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">dp[i] = Math.max(dp[i], Math.max(dp[i - j], i - j) * Math.max(dp[j], j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-343-Integer-Break&quot;&gt;&lt;a href=&quot;#LeetCode-Q-343-Integer-Break&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 343 - Integer Break&quot;&gt;&lt;/a&gt;LeetCode Q 343 - Integer Break&lt;/h1&gt;&lt;p&gt;Given a positive integer n, break it into the sum of &lt;strong&gt;at least&lt;/strong&gt; two positive integers and maximize the product of those integers. Return the maximum product you can get.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Bulb Switcher</title>
    <link href="http://yoursite.com/2019/04/11/leetcodeQ319/"/>
    <id>http://yoursite.com/2019/04/11/leetcodeQ319/</id>
    <published>2019-04-11T15:36:48.000Z</published>
    <updated>2019-04-11T15:40:03.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-Q-319-Bulb-Switcher"><a href="#LeetCode-Q-319-Bulb-Switcher" class="headerlink" title="LeetCode Q 319 - Bulb Switcher"></a>LeetCode Q 319 - Bulb Switcher</h1><p>There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.<br><a id="more"></a></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>A bulb ends up on iff it is <strong>switched an odd number of times</strong>.</p><p>Call them bulb 1 to bulb n. Bulb i is switched in round d if and only if d divides i. So bulb i ends up on if and only if it has an <strong>odd number of divisors</strong>.</p><p><strong>Divisors come in pairs</strong>, like i=12 has divisors 1 and 12, 2 and 6, and 3 and 4. Except when i is a square, like 36 has divisors 1 and 36, 2 and 18, 3 and 12, 4 and 9, and double divisor 6. <strong>So bulb i ends up on if and only if i is a square</strong>.</p><p>So just count the square numbers.</p><p>Let R = int(sqrt(n)). That’s the root of the largest square in the range [1,n]. And 1 is the smallest root. So you have the roots from 1 to R, that’s R roots. Which correspond to the R squares.</p><p><strong>Note:</strong>the return type of Math.sqrt is double, we need to cast it to int.</p><p><strong>Code:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LeetCode-Q-319-Bulb-Switcher&quot;&gt;&lt;a href=&quot;#LeetCode-Q-319-Bulb-Switcher&quot; class=&quot;headerlink&quot; title=&quot;LeetCode Q 319 - Bulb Switcher&quot;&gt;&lt;/a&gt;LeetCode Q 319 - Bulb Switcher&lt;/h1&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the i-th round, you toggle every i bulb. For the n-th round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;br&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
</feed>
