<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TongTong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-04T23:29:56.321Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Walls and Gates</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ663/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ663/</id>
    <published>2019-05-04T23:21:52.000Z</published>
    <updated>2019-05-04T23:29:56.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-663-walls-and-gates"><a class="markdownIt-Anchor" href="#lintcode-q-663-walls-and-gates"></a> LintCode Q 663 - Walls and Gates</h1><p>You are given a m x n 2D grid initialized with these three possible values.</p><ul><li>-1 - A wall or an obstacle.</li><li>0 - A gate.</li><li>INF - Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.<br>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a ROOM, that room should remain filled with INF</li></ul><p>Example1<br><code>Input: [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] ; Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]</code></p><p>Explanation:<br>the 2D grid is:<br>INF    -1     0    INF<br>INF    INF    INF    -1<br>INF    -1    INF    -1<br>0     -1    INF    INF<br>the answer is:<br>3    -1    0    1<br>2    2    1    -1<br>1    -1    2    -1<br>0    -1    3    4</p><p>Example2<br><code>Input: [[0,-1],[2147483647,2147483647]] ; Output: [[0,-1],[1,2]]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span>) <span class="comment">// find a gate</span></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != INF) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">grid[nr][nc] = grid[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-663-walls-and-gates&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-663-walls-and-gates&quot;&gt;&lt;/a&gt; LintCode Q 663 - Walls and Gates&lt;/h1&gt;
&lt;p&gt;You are given a m x n 2D grid initialized with these three possible values.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-1 - A wall or an obstacle.&lt;/li&gt;
&lt;li&gt;0 - A gate.&lt;/li&gt;
&lt;li&gt;INF - Infinity means an empty room. We use the value 2^31 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.&lt;br&gt;
Fill each empty room with the distance to its nearest gate. If it is impossible to reach a ROOM, that room should remain filled with INF&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example1&lt;br&gt;
&lt;code&gt;Input: [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]] ; Output: [[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Explanation:&lt;br&gt;
the 2D grid is:&lt;br&gt;
INF    -1     0    INF&lt;br&gt;
INF    INF    INF    -1&lt;br&gt;
INF    -1    INF    -1&lt;br&gt;
0     -1    INF    INF&lt;br&gt;
the answer is:&lt;br&gt;
3    -1    0    1&lt;br&gt;
2    2    1    -1&lt;br&gt;
1    -1    2    -1&lt;br&gt;
0    -1    3    4&lt;/p&gt;
&lt;p&gt;Example2&lt;br&gt;
&lt;code&gt;Input: [[0,-1],[2147483647,2147483647]] ; Output: [[0,-1],[1,2]]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Build Post Office II</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ573/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ573/</id>
    <published>2019-05-04T23:16:19.000Z</published>
    <updated>2019-05-04T23:21:05.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-573-build-post-office-ii"><a class="markdownIt-Anchor" href="#lintcode-q-573-build-post-office-ii"></a> LintCode Q 573 - Build Post Office II</h1><p>Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the sum of the distance from the post office to all the houses is smallest.<br>Return the smallest sum of distance. Return -1 if it is not possible.</p><p>Example 1:<br><code>Input：[[0,1,0,0,0],[1,0,0,2,1],[0,1,0,0,0]] ; Output：8</code><br>Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.</p><p>Example 2:<br><code>Input：[[0,1,0],[1,0,1],[0,1,0]] ; Output：4</code><br>Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.</p><p><strong>Challenge:</strong> Solve this problem within O(n^3) time.</p><p><strong>Notice:</strong></p><ul><li>You cannot pass through wall and house, but can pass through empty.</li><li>You only build post office on an empty.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><ul><li>Use BFS to calculte the distance from house to every empty land in the graph.</li><li>Add distances of all houses to every empty land together.</li><li>Choose the smallest distance</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dist = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"><span class="keyword">int</span> house = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">house++;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">dist[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] += level;</span><br><span class="line">reach[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || visited[nr][nc] || grid[nr][nc] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span> &amp;&amp; reach[r][c] == house &amp;&amp; dist[r][c] &lt; res)</span><br><span class="line">res = dist[r][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-573-build-post-office-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-573-build-post-office-ii&quot;&gt;&lt;/a&gt; LintCode Q 573 - Build Post Office II&lt;/h1&gt;
&lt;p&gt;Given a 2D grid, each cell is either a wall 2, an house 1 or empty 0 (the number zero, one, two), find a place to build a post office so that the sum of the distance from the post office to all the houses is smallest.&lt;br&gt;
Return the smallest sum of distance. Return -1 if it is not possible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[[0,1,0,0,0],[1,0,0,2,1],[0,1,0,0,0]] ; Output：8&lt;/code&gt;&lt;br&gt;
Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[[0,1,0],[1,0,1],[0,1,0]] ; Output：4&lt;/code&gt;&lt;br&gt;
Explanation： Placing a post office at (1,1), the distance that post office to all the house sum is smallest.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Challenge:&lt;/strong&gt; Solve this problem within O(n^3) time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You cannot pass through wall and house, but can pass through empty.&lt;/li&gt;
&lt;li&gt;You only build post office on an empty.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Rectangle Enclosing Black Pixels</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ803/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ803/</id>
    <published>2019-05-04T23:08:55.000Z</published>
    <updated>2019-05-04T23:17:30.999Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-803-smallest-rectangle-enclosing-black-pixels"><a class="markdownIt-Anchor" href="#lintcode-q-803-smallest-rectangle-enclosing-black-pixels"></a> LintCode Q 803 - Smallest Rectangle Enclosing Black Pixels</h1><p>You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:</p><ul><li>Each 0 marks an empty land which you can pass by freely.</li><li>Each 1 marks a building which you cannot pass through.</li><li>Each 2 marks an obstacle which you cannot pass through.</li></ul><p>Example 1<br><code>Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]] ; Output: 7</code><br>Explanation:<br>In this example, there are three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).<br>1 - 0 - 2 - 0 - 1<br>|   |   |   |   |<br>0 - 0 - 0 - 0 - 0<br>|   |   |   |   |<br>0 - 0 - 1 - 0 - 0<br>The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.</p><p>Example 2<br><code>Input: [[1,0],[0,0]] ; Output: 1</code><br>In this example, there is one buildings at (0,0).<br>1 - 0<br>|   |<br>0 - 0<br>The point (1,0) or (0,1) is an ideal empty land to build a house, as the total travel distance of 1 is minimal. So return 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><ul><li>Use BFS to calculte the distance from house to every empty land in the graph.</li><li>Add distances of all houses to every empty land together.</li><li>Choose the smallest distance</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length;</span><br><span class="line"><span class="keyword">int</span> C = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] reach = <span class="keyword">new</span> <span class="keyword">int</span>[R][C]; <span class="comment">// record how many houses have reached this land;</span></span><br><span class="line"><span class="keyword">int</span>[][] distance = <span class="keyword">new</span> <span class="keyword">int</span>[R][C]; <span class="comment">// recode the total ditance from an empty land to all houses</span></span><br><span class="line"><span class="keyword">int</span> building = <span class="number">0</span>; <span class="comment">// number of houses</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="comment">// find a house</span></span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">building++; <span class="comment">// increase number of house</span></span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>; <span class="comment">// dist from curr house to land</span></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size(); <span class="comment">// BFS layer by layer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">distance[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] += level;</span><br><span class="line">reach[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != <span class="number">0</span> || visited[nr][nc]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">visited[nr][nc] = <span class="keyword">true</span>;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">level++; <span class="comment">// update dist layer by layer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="number">0</span> &amp;&amp; reach[r][c] == building &amp;&amp; distance[r][c] &lt; res)</span><br><span class="line">res = distance[r][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res == Integer.MAX_VALUE)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-803-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-803-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;/a&gt; LintCode Q 803 - Smallest Rectangle Enclosing Black Pixels&lt;/h1&gt;
&lt;p&gt;You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each 0 marks an empty land which you can pass by freely.&lt;/li&gt;
&lt;li&gt;Each 1 marks a building which you cannot pass through.&lt;/li&gt;
&lt;li&gt;Each 2 marks an obstacle which you cannot pass through.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1&lt;br&gt;
&lt;code&gt;Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
In this example, there are three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2).&lt;br&gt;
1 - 0 - 2 - 0 - 1&lt;br&gt;
|   |   |   |   |&lt;br&gt;
0 - 0 - 0 - 0 - 0&lt;br&gt;
|   |   |   |   |&lt;br&gt;
0 - 0 - 1 - 0 - 0&lt;br&gt;
The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7.&lt;/p&gt;
&lt;p&gt;Example 2&lt;br&gt;
&lt;code&gt;Input: [[1,0],[0,0]] ; Output: 1&lt;/code&gt;&lt;br&gt;
In this example, there is one buildings at (0,0).&lt;br&gt;
1 - 0&lt;br&gt;
|   |&lt;br&gt;
0 - 0&lt;br&gt;
The point (1,0) or (0,1) is an ideal empty land to build a house, as the total travel distance of 1 is minimal. So return 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Smallest Rectangle Enclosing Black Pixels</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ600/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ600/</id>
    <published>2019-05-04T23:01:34.000Z</published>
    <updated>2019-05-04T23:16:35.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-600-smallest-rectangle-enclosing-black-pixels"><a class="markdownIt-Anchor" href="#lintcode-q-600-smallest-rectangle-enclosing-black-pixels"></a> LintCode Q 600 - Smallest Rectangle Enclosing Black Pixels</h1><p>An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p><p>Example 1:<br><code>Input：[&quot;0010&quot;,&quot;0110&quot;,&quot;0100&quot;]，x=0，y=2 ; Output：6</code><br>Explanation：<br>The upper left coordinate of the matrix is (0,1), and the lower right coordinate is (2,2).</p><p>Example 2:<br><code>Input：[&quot;0000&quot;,&quot;0101&quot;,&quot;0000&quot;]，x=1，y=1 ; Output：3</code><br>Explanation：<br>The upper left coordinate of the matrix is (1,1), and the lower right coordinate is (1,3).</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-bfs"><a class="markdownIt-Anchor" href="#solution-bfs"></a> Solution  : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArea</span><span class="params">(<span class="keyword">char</span>[][] image, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = image.length, C = image[<span class="number">0</span>].length;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;); image[x][y] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">int</span> l = x, r = x, t = y, b = y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || image[nr][nc] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">image[nr][nc] = <span class="string">'0'</span>;</span><br><span class="line">l = Math.min(l, nr); r = Math.max(r, nr);</span><br><span class="line">t = Math.min(t, nc); b = Math.max(b, nc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (r - l + <span class="number">1</span>) * (b - t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-600-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-600-smallest-rectangle-enclosing-black-pixels&quot;&gt;&lt;/a&gt; LintCode Q 600 - Smallest Rectangle Enclosing Black Pixels&lt;/h1&gt;
&lt;p&gt;An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;0010&amp;quot;,&amp;quot;0110&amp;quot;,&amp;quot;0100&amp;quot;]，x=0，y=2 ; Output：6&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
The upper left coordinate of the matrix is (0,1), and the lower right coordinate is (2,2).&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;0000&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0000&amp;quot;]，x=1，y=1 ; Output：3&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
The upper left coordinate of the matrix is (1,1), and the lower right coordinate is (1,3).&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Number of Islands II</title>
    <link href="http://yoursite.com/2019/05/04/lintcodeQ434/"/>
    <id>http://yoursite.com/2019/05/04/lintcodeQ434/</id>
    <published>2019-05-04T22:49:46.000Z</published>
    <updated>2019-05-04T23:16:44.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-434-number-of-islands-ii"><a class="markdownIt-Anchor" href="#lintcode-q-434-number-of-islands-ii"></a> LintCode Q 434 - Number of Islands II</h1><p>Given a n,m which means the row and column of the 2D matrix and an array of pair A( size k). Originally, the 2D matrix is all 0 which means there is only sea in the matrix. The list pair has k operator and each operator has two integer A[i].x, A[i].y means that you can change the grid matrix[A[i].x][A[i].y] from sea to island. Return how many island are there in the matrix after each operator.</p><p>Example 1:<br><code>Input: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]] ; Output: [1,1,2,2]</code><br>Explanation:</p><ol><li>00000<br>00000<br>00000<br>00000</li><li>00000<br>01000<br>00000<br>00000</li><li>01000<br>01000<br>00000<br>00000</li><li>01000<br>01000<br>00000<br>00010</li><li>01000<br>01000<br>00000<br>00011</li></ol><p>Example 2:<br><code>Input: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]; Output: [1,1,2,2]</code></p><p><strong>Notice:</strong> 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-union-find"><a class="markdownIt-Anchor" href="#solution-1-union-find"></a> Solution 1 : Union Find</h3><p>We don’t need an addition array to record if we have visited a node, we can set <code>M[i][i] = 2</code> to indiate that.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != parent[x]) parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123; parent[py] = px; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">numIslands2</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, Point[] operators)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (R == <span class="number">0</span> || C == <span class="number">0</span> || operators == <span class="keyword">null</span> || operators.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] grid = <span class="keyword">new</span> <span class="keyword">int</span>[R][C];</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Point operator: operators) &#123;</span><br><span class="line"><span class="keyword">int</span> r = operator.x, c = operator.y;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">grid[r][c] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C </span><br><span class="line">|| grid[nr][nc] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> pa = ufs.find(r * C + c);</span><br><span class="line"><span class="keyword">int</span> npa = ufs.find(nr * C + nc);</span><br><span class="line"><span class="keyword">if</span> (pa != npa) &#123;</span><br><span class="line">count--;</span><br><span class="line">ufs.union(pa, npa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.add(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-434-number-of-islands-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-434-number-of-islands-ii&quot;&gt;&lt;/a&gt; LintCode Q 434 - Number of Islands II&lt;/h1&gt;
&lt;p&gt;Given a n,m which means the row and column of the 2D matrix and an array of pair A( size k). Originally, the 2D matrix is all 0 which means there is only sea in the matrix. The list pair has k operator and each operator has two integer A[i].x, A[i].y means that you can change the grid matrix[A[i].x][A[i].y] from sea to island. Return how many island are there in the matrix after each operator.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: n = 4, m = 5, A = [[1,1],[0,1],[3,3],[3,4]] ; Output: [1,1,2,2]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;00000&lt;br&gt;
00000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;00000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00000&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00010&lt;/li&gt;
&lt;li&gt;01000&lt;br&gt;
01000&lt;br&gt;
00000&lt;br&gt;
00011&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: n = 3, m = 3, A = [[0,0],[0,1],[2,2],[2,1]]; Output: [1,1,2,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
      <category term="LinttCode" scheme="http://yoursite.com/tags/LinttCode/"/>
    
  </entry>
  
  <entry>
    <title>Friend Circle</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ547/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ547/</id>
    <published>2019-05-04T22:26:18.000Z</published>
    <updated>2019-05-04T22:42:14.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-547-friend-circle"><a class="markdownIt-Anchor" href="#leetcode-q-547-friend-circle"></a> LeetCode Q 547 - Friend Circle</h1><p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a N * N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p>Example 1:<br>Input:<br>[[1,1,0],<br>[1,1,0],<br>[0,0,1]]<br>Output: 2<br>Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.<br>The 2nd student himself is in a friend circle. So return 2.</p><p>Example 2:<br>Input:<br>[[1,1,0],<br>[1,1,1],<br>[0,1,1]]<br>Output: 1<br>Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,<br>so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.</p><p><strong>Note:</strong><br>N is in range [1,200].<br>M[i][i] = 1 for all students.<br>If M[i][j] = 1, then M[j][i] = 1.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>We don’t need an addition array to record if we have visited a node, we can set <code>M[i][i] = 2</code> to indiate that.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">dfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> curr)</span> </span>&#123;</span><br><span class="line">M[curr][curr] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][curr] == <span class="number">1</span> &amp;&amp; M[i][i] == <span class="number">1</span>)</span><br><span class="line">dfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">bfs(M, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> student)</span> </span>&#123;</span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(student);</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line">M[curr][curr] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][i] == <span class="number">1</span> &amp;&amp; M[i][curr] == <span class="number">1</span>)</span><br><span class="line">que.offer(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-3-disjoint-set"><a class="markdownIt-Anchor" href="#solution-3-disjoint-set"></a> Solution 3 : Disjoint Set</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) </span><br><span class="line">parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">parent[px] = py;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = M.length;</span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(N);</span><br><span class="line">ufs.count = N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(i) != ufs.find(j))</span><br><span class="line">ufs.union(i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-547-friend-circle&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-547-friend-circle&quot;&gt;&lt;/a&gt; LeetCode Q 547 - Friend Circle&lt;/h1&gt;
&lt;p&gt;There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.&lt;/p&gt;
&lt;p&gt;Given a N * N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,0],&lt;br&gt;
[0,0,1]]&lt;br&gt;
Output: 2&lt;br&gt;
Explanation:The 0th and 1st students are direct friends, so they are in a friend circle.&lt;br&gt;
The 2nd student himself is in a friend circle. So return 2.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,1],&lt;br&gt;
[0,1,1]]&lt;br&gt;
Output: 1&lt;br&gt;
Explanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,&lt;br&gt;
so the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;
N is in range [1,200].&lt;br&gt;
M[i][i] = 1 for all students.&lt;br&gt;
If M[i][j] = 1, then M[j][i] = 1.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Flood Fill</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ733/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ733/</id>
    <published>2019-05-04T22:17:06.000Z</published>
    <updated>2019-05-04T22:23:56.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-733-flood-fill"><a class="markdownIt-Anchor" href="#leetcode-q-733-flood-fill"></a> LeetCode Q 733 - Flood Fill</h1><p>An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).<br>Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.<br>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.<br>At the end, return the modified image.</p><p>Example 1:<br><code>Input: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 ; Output: [[2,2,2],[2,2,0],[2,0,1]]</code><br>Explanation:<br>From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.</p><p><strong>Note:</strong></p><ul><li>The length of image and image[0] will be in the range [1, 50].</li><li>The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length.</li><li>The value of each color in image[i][j] and newColor will be an integer in [0, 65535].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line"><span class="keyword">if</span> (newColor != image[sr][sc])</span><br><span class="line">dfs(image, sr, sc, newColor, image[sr][sc]);</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor, <span class="keyword">int</span> oriColor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sr &lt; <span class="number">0</span> || sc &lt; <span class="number">0</span> || sr == image.length || sc == image[<span class="number">0</span>].length || image[sr][sc] != oriColor) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">image[sr][sc] = newColor;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = sr + DIRS[i], nc = sc + DIRS[i + <span class="number">1</span>];</span><br><span class="line">dfs(image, nr, nc, newColor, oriColor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] floodFill(<span class="keyword">int</span>[][] image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (image[sr][sc] == newColor) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> oldColor = image[sr][sc];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">image[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] = newColor;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nx = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> ny = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nx &lt; <span class="number">0</span> || ny &lt; <span class="number">0</span> || nx &gt;= image.length || ny &gt;= image[<span class="number">0</span>].length || image[nx][ny] != oldColor) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-733-flood-fill&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-733-flood-fill&quot;&gt;&lt;/a&gt; LeetCode Q 733 - Flood Fill&lt;/h1&gt;
&lt;p&gt;An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).&lt;br&gt;
Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.&lt;br&gt;
To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.&lt;br&gt;
At the end, return the modified image.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 ; Output: [[2,2,2],[2,2,0],[2,0,1]]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected by a path of the same color as the starting pixel are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of image and image[0] will be in the range [1, 50].&lt;/li&gt;
&lt;li&gt;The given starting pixel will satisfy 0 &amp;lt;= sr &amp;lt; image.length and 0 &amp;lt;= sc &amp;lt; image[0].length.&lt;/li&gt;
&lt;li&gt;The value of each color in image[i][j] and newColor will be an integer in [0, 65535].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ200</title>
    <link href="http://yoursite.com/2019/05/04/leetcodeQ200/"/>
    <id>http://yoursite.com/2019/05/04/leetcodeQ200/</id>
    <published>2019-05-04T15:32:36.000Z</published>
    <updated>2019-05-04T22:30:37.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-200-number-of-islands"><a class="markdownIt-Anchor" href="#leetcode-q-200-number-of-islands"></a> LeetCode Q 200 - Number of Islands</h1><p>Given a 2d grid map of '1’s (land) and '0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p>Example 1:<br>Input:<br>11110<br>11010<br>11000<br>00000<br>Output: 1</p><p>Example 2:<br>Input:<br>11000<br>11000<br>00100<br>00011<br>Output: 3</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>We don’t need another boolean[][] visited, since we can set the visited element <code>grid[r][c] = '0'</code> to <strong>avoid re-visit</strong>.<br>Time complexity : R * C nodes,  O(R * C)</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">dfs(grid, i, j);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == grid.length || c == grid[<span class="number">0</span>].length || grid[r][c] != <span class="string">'1'</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">grid[r][c] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">dfs(grid, r + DIRS[i], c + DIRS[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span> <span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r, c&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line">grid[curr[<span class="number">0</span>]][curr[<span class="number">1</span>]] = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = curr[<span class="number">0</span>] + DIRS[i];</span><br><span class="line"><span class="keyword">int</span> nc = curr[<span class="number">1</span>] + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nr &lt; R &amp;&amp; nc &lt; C &amp;&amp; grid[nr][nc] == <span class="string">'1'</span>) </span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nr, nc&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-3-disjoint-set"><a class="markdownIt-Anchor" href="#solution-3-disjoint-set"></a> Solution 3 : Disjoint Set</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line"><span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (parent[x] != x) </span><br><span class="line">parent[x] = find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = find(x), py = find(y);</span><br><span class="line"><span class="keyword">if</span> (px != py) &#123;</span><br><span class="line">parent[px] = py;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = grid.length, C= grid[<span class="number">0</span>].length;   </span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet(R * C);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) total++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ufs.count = total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (grid[r][c] == <span class="string">'1'</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> nr = r + DIRS[i], nc = c + DIRS[i + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (nr &lt; <span class="number">0</span> || nc &lt; <span class="number">0</span> || nr == R || nc == C || grid[nr][nc] != <span class="string">'1'</span>) <span class="keyword">continue</span>;</span><br><span class="line">ufs.union(r * C + c, nr * C + nc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ufs.count;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-200-number-of-islands&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-200-number-of-islands&quot;&gt;&lt;/a&gt; LeetCode Q 200 - Number of Islands&lt;/h1&gt;
&lt;p&gt;Given a 2d grid map of &#39;1’s (land) and &#39;0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
11110&lt;br&gt;
11010&lt;br&gt;
11000&lt;br&gt;
00000&lt;br&gt;
Output: 1&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
Input:&lt;br&gt;
11000&lt;br&gt;
11000&lt;br&gt;
00100&lt;br&gt;
00011&lt;br&gt;
Output: 3&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Find Eventual Safe States</title>
    <link href="http://yoursite.com/2019/05/03/leetcodeQ802/"/>
    <id>http://yoursite.com/2019/05/03/leetcodeQ802/</id>
    <published>2019-05-03T22:51:18.000Z</published>
    <updated>2019-05-04T15:35:10.689Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-802-find-eventual-safe-states"><a class="markdownIt-Anchor" href="#leetcode-q-802-find-eventual-safe-states"></a> LeetCode Q 802 - Find Eventual Safe States</h1><p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.<br>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.<br>Which nodes are eventually safe?  Return them as an array in sorted order.<br>The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.</p><p>Example:<br><code>Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6]</code></p><p><strong>Note:</strong></p><ul><li><code>graph</code> will have length at most <code>10000</code>.</li><li>The number of edges in the graph will not exceed <code>32000</code>.</li><li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="comment">// 2 -&gt; 5, 4 -&gt; 5 ; then map(5) = &#123;2, 4&#125;;</span></span><br><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">map.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[i]) &#123;</span><br><span class="line">map.get(next).add(i);</span><br><span class="line">order[i]++;</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (order[i] == <span class="number">0</span>) que.offer(i); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line">res.add(curr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: map.get(curr)) &#123;</span><br><span class="line">order[next]--;</span><br><span class="line"><span class="keyword">if</span> (order[next] == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.sort(res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.length;</span><br><span class="line"><span class="keyword">int</span>[] status = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasCycle(graph, i, status))</span><br><span class="line">        res.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> i, <span class="keyword">int</span>[] status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">status[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[i]) &#123;</span><br><span class="line"><span class="keyword">if</span> (status[next] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, next, status))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">status[i] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-802-find-eventual-safe-states&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-802-find-eventual-safe-states&quot;&gt;&lt;/a&gt; LeetCode Q 802 - Find Eventual Safe States&lt;/h1&gt;
&lt;p&gt;In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.&lt;br&gt;
Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.&lt;br&gt;
Which nodes are eventually safe?  Return them as an array in sorted order.&lt;br&gt;
The directed graph has N nodes with labels 0, 1, …, N-1, where N is the length of graph.  The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]] Output: [2,4,5,6]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;graph&lt;/code&gt; will have length at most &lt;code&gt;10000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The number of edges in the graph will not exceed &lt;code&gt;32000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each &lt;code&gt;graph[i]&lt;/code&gt; will be a sorted list of different integers, chosen within the range &lt;code&gt;[0, graph.length - 1]&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Course Schedule II</title>
    <link href="http://yoursite.com/2019/05/03/leetcodeQ210/"/>
    <id>http://yoursite.com/2019/05/03/leetcodeQ210/</id>
    <published>2019-05-03T22:23:21.000Z</published>
    <updated>2019-05-04T00:42:28.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-210-course-schedule-ii"><a class="markdownIt-Anchor" href="#leetcode-q-210-course-schedule-ii"></a> LeetCode Q 210 - Course Schedule II</h1><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.<br>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p><p>Example 1:<br><code>Input: 2, [[1,0]] ; Output: [0,1]</code><br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].</p><p>Example 2:<br><code>Input: 4, [[1,0],[2,0],[3,1],[3,2]] ; Output: [0,1,2,3] or [0,2,1,3]</code><br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</p><p><strong>Note:</strong></p><ul><li>The input prerequisites is a graph represented by a list of edges, not adjacency matrices.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] reqs) &#123;</span><br><span class="line">res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line">List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] req: reqs) &#123; </span><br><span class="line">graph[req[<span class="number">1</span>]].add(req[<span class="number">0</span>]);</span><br><span class="line">order[req[<span class="number">0</span>]]++;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (order[i] == <span class="number">0</span>) que.offer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line">res[count++] = curr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph.get(curr)) &#123;</span><br><span class="line">order[next]--;</span><br><span class="line"><span class="keyword">if</span> (order[next] == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count == numCourses ? res : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] reqs) &#123;</span><br><span class="line">res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">count = numCourses - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line">List&lt;Integer&gt;[] graph = <span class="keyword">new</span> ArrayList[numCourses];</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">graph[i] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] req: reqs)</span><br><span class="line">graph[req[<span class="number">1</span>]].add(req[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] status = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (status[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, i, status))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span> <span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> course, <span class="keyword">int</span>[] status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status[course] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">status[course] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[course]) &#123;</span><br><span class="line"><span class="keyword">if</span> (status[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, next, status))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status[course] = <span class="number">2</span>;</span><br><span class="line">res[count--] = course;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-210-course-schedule-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-210-course-schedule-ii&quot;&gt;&lt;/a&gt; LeetCode Q 210 - Course Schedule II&lt;/h1&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n-1.&lt;br&gt;
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;br&gt;
Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.&lt;br&gt;
There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: 2, [[1,0]] ; Output: [0,1]&lt;/code&gt;&lt;br&gt;
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: 4, [[1,0],[2,0],[3,1],[3,2]] ; Output: [0,1,2,3] or [0,2,1,3]&lt;/code&gt;&lt;br&gt;
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input prerequisites is a graph represented by a list of edges, not adjacency matrices.&lt;/li&gt;
&lt;li&gt;You may assume that there are no duplicate edges in the input prerequisites.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Course Schedule</title>
    <link href="http://yoursite.com/2019/05/03/leetcodeQ207/"/>
    <id>http://yoursite.com/2019/05/03/leetcodeQ207/</id>
    <published>2019-05-03T21:33:53.000Z</published>
    <updated>2019-05-04T00:42:34.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-207-course-schedule"><a class="markdownIt-Anchor" href="#leetcode-q-207-course-schedule"></a> LeetCode Q 207 - Course Schedule</h1><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p><p>Example 1:<br><code>Input: 2, [[1,0]] ; Output: true</code><br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.</p><p>Example 2:<br><code>Input: 2, [[1,0],[0,1]] ; Output: false</code><br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.</p><p><strong>Note:</strong></p><ul><li>The input prerequisites is a graph represented by <strong>a list of edges</strong>, not adjacency matrices. Read more about how a graph is <a href="https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs" title="represented" target="_blank" rel="noopener"></a>.</li><li>You may assume that there are no duplicate edges in the input prerequisites.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] reqs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numCourses &lt;= <span class="number">0</span> || reqs == <span class="keyword">null</span> || reqs.length == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the graph and order array</span></span><br><span class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">graph.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] req: reqs) &#123;</span><br><span class="line">graph.get(req[<span class="number">1</span>]).add(req[<span class="number">0</span>]);</span><br><span class="line">order[req[<span class="number">0</span>]]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (order[i] == <span class="number">0</span>) que.offer(numCourses);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph.get(curr)) &#123;</span><br><span class="line">order[next]--;</span><br><span class="line"><span class="keyword">if</span> (order[next] == <span class="number">0</span>)</span><br><span class="line">que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Tip:</strong><br>Use an <code>int[] status</code> to represent the status of the current node.<br>It has 3 potential values, i.e.<br><code>0</code>: unvisited; <code>1</code>: visiting; <code>2</code>: visited.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] reqs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numCourses &lt;= <span class="number">0</span> || reqs == <span class="keyword">null</span> || reqs.length == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the graph </span></span><br><span class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">graph.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] req: reqs) </span><br><span class="line">graph.get(req[<span class="number">1</span>]).add(req[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] status = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (status[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, i, status))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> course, <span class="keyword">int</span>[] status)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status[course] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">status[course] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph.get(course)) &#123;</span><br><span class="line"><span class="keyword">if</span> (status[i] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (hasCycle(graph, next, status))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status[course] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-207-course-schedule&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-207-course-schedule&quot;&gt;&lt;/a&gt; LeetCode Q 207 - Course Schedule&lt;/h1&gt;
&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n-1.&lt;br&gt;
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;br&gt;
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: 2, [[1,0]] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: 2, [[1,0],[0,1]] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input prerequisites is a graph represented by &lt;strong&gt;a list of edges&lt;/strong&gt;, not adjacency matrices. Read more about how a graph is &lt;a href=&quot;https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs&quot; title=&quot;represented&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;You may assume that there are no duplicate edges in the input prerequisites.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
  </entry>
  
  <entry>
    <title>Is Graph Bipartite?</title>
    <link href="http://yoursite.com/2019/05/02/leetcodeQ785/"/>
    <id>http://yoursite.com/2019/05/02/leetcodeQ785/</id>
    <published>2019-05-02T23:39:45.000Z</published>
    <updated>2019-05-03T00:45:43.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-785-is-graph-bipartite"><a class="markdownIt-Anchor" href="#leetcode-q-785-is-graph-bipartite"></a> LeetCode Q 785 - Is Graph Bipartite?</h1><p>Given an undirected graph, return true if and only if it is bipartite.<br>Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.<br>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.</p><p>Example 1:<br><code>Input: [[1,3], [0,2], [1,3], [0,2]] ; Output: true</code><br>Explanation:<br>The graph looks like this:<br>0----1<br>|    |<br>|    |<br>3----2<br>We can divide the vertices into two groups: {0, 2} and {1, 3}.</p><p>Example 2:<br><code>Input: [[1,2,3], [0,2], [0,1,3], [0,2]] ; Output: false</code><br>Explanation:<br>The graph looks like this:<br>0----1<br>| \  |<br>|  \ |<br>3----2<br>We cannot find a way to divide the set of nodes into two independent subsets.</p><p><strong>Note:</strong></p><ul><li>graph will have length in range [1, 100].</li><li>graph[i] will contain integers in range [0, graph.length - 1].</li><li>graph[i] will not contain i or duplicate values.</li><li>The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>By <strong>coloring</strong> each node in the graph <strong>black</strong> or <strong>white</strong>, we can check is a graph is <strong>bipartite</strong>.</p><p>Traverse the graph, coloring the <strong>adjenct nodes</strong> to <strong>different colors</strong>. If we can finish the coloring procedure successfully, the graph is <strong>bipartite</strong>, otherwise it isn’t.</p><p>We can do this using DFS or BFS.</p><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><code>int[] colors</code> has three values, 0 : unvisiting, 1 : white, 2: black</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.length;   <span class="comment">// n nodes</span></span><br><span class="line"><span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; graph[i].length != <span class="number">0</span>) &#123;</span><br><span class="line">colors[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[curr]) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[next] == -<span class="number">1</span>) &#123;</span><br><span class="line">que.offer(next); colors[next] = <span class="number">1</span> - colors[curr];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[next] == colors[curr]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.length;   <span class="comment">// n nodes</span></span><br><span class="line"><span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.fill(colors, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (colors[i] == -<span class="number">1</span> &amp;&amp; !validColor(graph, colors, <span class="number">0</span>, i))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validColor</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> currColor, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (colors[node] != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> colors[node] == color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph[curr]) &#123;</span><br><span class="line"><span class="keyword">if</span> (color[next] != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> color[next] == <span class="number">1</span> - currColor;</span><br><span class="line">color[next] == <span class="number">1</span> - currColor;</span><br><span class="line">dfs(graph, next, <span class="number">1</span> - currColor, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-785-is-graph-bipartite&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-785-is-graph-bipartite&quot;&gt;&lt;/a&gt; LeetCode Q 785 - Is Graph Bipartite?&lt;/h1&gt;
&lt;p&gt;Given an undirected graph, return true if and only if it is bipartite.&lt;br&gt;
Recall that a graph is bipartite if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.&lt;br&gt;
The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn’t contain any element twice.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[1,3], [0,2], [1,3], [0,2]] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The graph looks like this:&lt;br&gt;
0----1&lt;br&gt;
|    |&lt;br&gt;
|    |&lt;br&gt;
3----2&lt;br&gt;
We can divide the vertices into two groups: {0, 2} and {1, 3}.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[1,2,3], [0,2], [0,1,3], [0,2]] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The graph looks like this:&lt;br&gt;
0----1&lt;br&gt;
| \  |&lt;br&gt;
|  \ |&lt;br&gt;
3----2&lt;br&gt;
We cannot find a way to divide the set of nodes into two independent subsets.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;graph will have length in range [1, 100].&lt;/li&gt;
&lt;li&gt;graph[i] will contain integers in range [0, graph.length - 1].&lt;/li&gt;
&lt;li&gt;graph[i] will not contain i or duplicate values.&lt;/li&gt;
&lt;li&gt;The graph is undirected: if any element j is in graph[i], then i will be in graph[j].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Clone Graph</title>
    <link href="http://yoursite.com/2019/05/02/leetcodeQ133/"/>
    <id>http://yoursite.com/2019/05/02/leetcodeQ133/</id>
    <published>2019-05-02T23:19:05.000Z</published>
    <updated>2019-05-03T00:21:11.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-892-clone-graph"><a class="markdownIt-Anchor" href="#leetcode-q-892-clone-graph"></a> LeetCode Q 892 - Clone Graph</h1><p>Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.</p><p><strong>Note:</strong></p><ul><li>The number of nodes will be between 1 and 100.</li><li>The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.</li><li>Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.</li><li>You must return the copy of the given node as a reference to the cloned graph.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Definition for a Node.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> _val,List&lt;Node&gt; _neighbors)</span> </span>&#123;</span><br><span class="line">    val = _val;</span><br><span class="line">    neighbors = _neighbors;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;Node&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">Set&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(node); set.add(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy nodes</span></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">Node curr = que.poll();</span><br><span class="line">map.put(curr, <span class="keyword">new</span> Node(curr.val, <span class="keyword">new</span> List&lt;Node&gt;()));</span><br><span class="line"><span class="keyword">for</span> (Node nei: curr.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span> (set.contains(nei)) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(nei); set.add(nei);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy edges</span></span><br><span class="line"><span class="keyword">for</span> (Node curr: map.keySet) &#123;</span><br><span class="line"><span class="keyword">for</span> (Node nei: map.get(curr)) &#123;</span><br><span class="line">map.get(curr).neighbors.add(map.get(nei));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> map.get(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dfs"><a class="markdownIt-Anchor" href="#solution-2-dfs"></a> Solution 2 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Node, Node&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(root, <span class="keyword">new</span> Node(root.val, <span class="keyword">new</span> ArrayList&lt;Node&gt;()));</span><br><span class="line"></span><br><span class="line">dfs(map, root);</span><br><span class="line"><span class="keyword">return</span> map.get(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;Node, Node&gt; map, Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Node nei: node.neighbors) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(nei)) &#123;</span><br><span class="line">map.put(nei, <span class="keyword">new</span> Node(nei.value, <span class="keyword">new</span> List&lt;Node&gt;()));</span><br><span class="line">dfs(map, nei);</span><br><span class="line">&#125;</span><br><span class="line">map.get(node).neighbors.add(nei);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-892-clone-graph&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-892-clone-graph&quot;&gt;&lt;/a&gt; LeetCode Q 892 - Clone Graph&lt;/h1&gt;
&lt;p&gt;Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of nodes will be between 1 and 100.&lt;/li&gt;
&lt;li&gt;The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.&lt;/li&gt;
&lt;li&gt;Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.&lt;/li&gt;
&lt;li&gt;You must return the copy of the given node as a reference to the cloned graph.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Alien Dictionary</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ892/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ892/</id>
    <published>2019-05-02T22:58:18.000Z</published>
    <updated>2019-05-02T23:18:03.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-892-alien-dictionary"><a class="markdownIt-Anchor" href="#lintcode-q-892-alien-dictionary"></a> LintCode Q 892 - Alien Dictionary</h1><p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p><p>Example 1:<br><code>Input：[&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;] ; Output：&quot;wertf&quot;</code><br>Explanation：<br>from “wrt&quot;and&quot;wrf” ,we can get ‘t’&lt;‘f’<br>from “wrt&quot;and&quot;er” ,we can get ‘w’&lt;‘e’<br>from “er&quot;and&quot;ett” ,we can get ‘r’&lt;‘t’<br>from “ett&quot;and&quot;rtff” ,we can get ‘e’&lt;‘r’<br>So return “wertf”</p><p>Example 2:<br><code>Input：[&quot;z&quot;,&quot;x&quot;] ; Output：&quot;zx&quot;</code><br>Explanation：<br>from “z” and “x”，we can get ‘z’ &lt; ‘x’<br>So return “zx”</p><p><strong>Notice:</strong></p><ul><li>You may assume all letters are in lowercase.</li><li>You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.</li><li>If the order is invalid, return an empty string.</li><li>There may be multiple valid order of letters, return the smallest in normal lexicographical order</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Set&lt;Character&gt;&gt; graph = buildGraph(words);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> topologySorting(graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;Character, Set&lt;Character&gt;&gt; buildGraph(String[] words) &#123;</span><br><span class="line"></span><br><span class="line">Map&lt;Character, Set&lt;Character&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) </span><br><span class="line">graph.putIfAbsent(ch, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; words[i].length; index++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word[i].charAt(index) != word[i + <span class="number">1</span>].charAt(index)) &#123;</span><br><span class="line">graph.get(word[i].charAt(index), word[i + <span class="number">1</span>].charAt(index));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">topologySorting</span><span class="params">(Map&lt;Character, Set&lt;Character&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.size();</span><br><span class="line">Map&lt;Character, Integer&gt; order = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: graph.keySet()) </span><br><span class="line">order.put(ch, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: graph.keySet()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> next: graph.get(ch)) </span><br><span class="line">order.put(next, order.get(next) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Character&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;();  <span class="comment">// not LinkedList</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: order.keySet()) &#123;</span><br><span class="line"><span class="keyword">if</span> (order.get(ch) == <span class="number">0</span>) que.offer(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">char</span> curr = que.poll();</span><br><span class="line">sb.append(curr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> next: graph.get(curr)) &#123;</span><br><span class="line">map.put(next, map.get(next) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (map.get(next) == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sb.length() != order.size()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Tip: why using PriorityQueue not just LinkedList</strong><br>Since for test case <code>[&quot;zy&quot;, &quot;zx&quot;]</code>, the correct output should be <code>&quot;yxz&quot;</code>. If using LinkedList, we get <code>&quot;yzx&quot;</code> which is not correct.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-892-alien-dictionary&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-892-alien-dictionary&quot;&gt;&lt;/a&gt; LintCode Q 892 - Alien Dictionary&lt;/h1&gt;
&lt;p&gt;There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;wrt&amp;quot;,&amp;quot;wrf&amp;quot;,&amp;quot;er&amp;quot;,&amp;quot;ett&amp;quot;,&amp;quot;rftt&amp;quot;] ; Output：&amp;quot;wertf&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
from “wrt&amp;quot;and&amp;quot;wrf” ,we can get ‘t’&amp;lt;‘f’&lt;br&gt;
from “wrt&amp;quot;and&amp;quot;er” ,we can get ‘w’&amp;lt;‘e’&lt;br&gt;
from “er&amp;quot;and&amp;quot;ett” ,we can get ‘r’&amp;lt;‘t’&lt;br&gt;
from “ett&amp;quot;and&amp;quot;rtff” ,we can get ‘e’&amp;lt;‘r’&lt;br&gt;
So return “wertf”&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input：[&amp;quot;z&amp;quot;,&amp;quot;x&amp;quot;] ; Output：&amp;quot;zx&amp;quot;&lt;/code&gt;&lt;br&gt;
Explanation：&lt;br&gt;
from “z” and “x”，we can get ‘z’ &amp;lt; ‘x’&lt;br&gt;
So return “zx”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You may assume all letters are in lowercase.&lt;/li&gt;
&lt;li&gt;You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.&lt;/li&gt;
&lt;li&gt;If the order is invalid, return an empty string.&lt;/li&gt;
&lt;li&gt;There may be multiple valid order of letters, return the smallest in normal lexicographical order&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Topological Sorting</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ127/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ127/</id>
    <published>2019-05-02T22:28:46.000Z</published>
    <updated>2019-05-02T23:24:44.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-127-topological-sorting"><a class="markdownIt-Anchor" href="#lintcode-q-127-topological-sorting"></a> LintCode Q 127 - Topological Sorting</h1><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p><ul><li>For each directed edge A -&gt; B in graph, A must before B in the order list.</li><li>The first node in the order can be any node in the graph with no nodes direct to it.</li><li>Find any topological order for the given graph.</li></ul><p><strong>Challenge:</strong> Can you do it in both BFS and DFS?</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p>Definition for Directed graph.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedGraphNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> label;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; neighbors;</span><br><span class="line">DirectedGraphNode(<span class="keyword">int</span> x) &#123; label = x; neighbors = <span class="keyword">new</span> ArrayList&lt;DirectedGraphNode&gt;(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Set&lt;DirectedGraphNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) </span><br><span class="line">dfs(node, visited, res);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DirectedGraphNode node, Set&lt;DirectedGraphNode&gt; visited, ArrayList&lt;DirectedGraphNode&gt; res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (visited.contains(node)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited.add(node);</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: node.neighbors) &#123;</span><br><span class="line">dfs(next, visited, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res.add(<span class="number">0</span>, node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs-topology-sorting"><a class="markdownIt-Anchor" href="#solution-2-bfs-topology-sorting"></a> Solution 2 : BFS / Topology Sorting</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;DirectedGraphNode&gt; <span class="title">topSort</span><span class="params">(ArrayList&lt;DirectedGraphNode&gt; graph)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;DirectedGraphNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.size() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = graph.size();</span><br><span class="line"><span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) &#123;</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: node.neighbors) &#123;</span><br><span class="line">order[next.label]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;DirectedGraphNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode node: graph) &#123;</span><br><span class="line"><span class="keyword">if</span> (order[node.label] == <span class="number">0</span>) que.offer(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">DirectedGraphNode curr = que.poll();</span><br><span class="line">res.add(curr);</span><br><span class="line"><span class="keyword">for</span> (DirectedGraphNode next: curr.neighbors) &#123;</span><br><span class="line">order[next.label]--;</span><br><span class="line"><span class="keyword">if</span> (order[next.label] == <span class="number">0</span>) que.offer(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-127-topological-sorting&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-127-topological-sorting&quot;&gt;&lt;/a&gt; LintCode Q 127 - Topological Sorting&lt;/h1&gt;
&lt;p&gt;Given an directed graph, a topological order of the graph nodes is defined as follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For each directed edge A -&amp;gt; B in graph, A must before B in the order list.&lt;/li&gt;
&lt;li&gt;The first node in the order can be any node in the graph with no nodes direct to it.&lt;/li&gt;
&lt;li&gt;Find any topological order for the given graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Challenge:&lt;/strong&gt; Can you do it in both BFS and DFS?&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Topology Sorting" scheme="http://yoursite.com/tags/Topology-Sorting/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Graph Valid Tree</title>
    <link href="http://yoursite.com/2019/05/02/lintcodeQ178/"/>
    <id>http://yoursite.com/2019/05/02/lintcodeQ178/</id>
    <published>2019-05-02T21:26:21.000Z</published>
    <updated>2019-05-02T22:28:11.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-178-graph-valid-tree"><a class="markdownIt-Anchor" href="#lintcode-q-178-graph-valid-tree"></a> LintCode Q 178 - Graph Valid Tree</h1><p>Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p><p>Example 1:<br><code>Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] ; Output: true.</code></p><p>Example 2:<br><code>Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] ; Output: false.</code></p><p><strong>Notice:</strong> You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong><font color="#06bcf9">An undirected graph is tree if it has following properties.</font></strong></p><ol><li>There is no cycle.</li><li>The graph is connected.</li></ol><p><strong><font color="#06bcf9">How to check if a graph satisfies the above two properties?</font></strong></p><ol><li>If there are <em><strong>N</strong></em> nodes and <em><strong>N-1</strong></em> edges, then the graph has no cycle. That is <code>edges = n - 1</code>.</li><li>There is no island in the graph, <em>if and only if</em> we can visit every node in the graph from any <strong>arbitrary</strong> node in the graph.</li></ol><h3 id="solution-1-bfs"><a class="markdownIt-Anchor" href="#solution-1-bfs"></a> Solution 1 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (edges.length != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the graph</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">graph.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line">graph.get(edge[<span class="number">0</span>]).add(edge[<span class="number">1</span>]);</span><br><span class="line">graph.get(edge[<span class="number">1</span>]).add(edge[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; que = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">que.offer(<span class="number">0</span>); visited.add(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> next: graph.get(curr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited.contains(next)) <span class="keyword">continue</span>;</span><br><span class="line">que.offer(next);</span><br><span class="line">visited.add(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> vistied.size() == n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-disjoint-set-union-find-set"><a class="markdownIt-Anchor" href="#solution-2-disjoint-set-union-find-set"></a> Solution 2 : Disjoint Set / Union Find Set</h3><ol><li>Build the union, if I am trying to union an existing edge, then return false;</li><li>Check if there is only one union in the graph.</li></ol><p><strong>Another way:</strong></p><ol><li>Add a count field in the UnionFindSet, denoting the number of different unions.</li><li>check if the <code>count</code> for the given graph equals <code>1</code>.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] parent;</span><br><span class="line"><span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">parent = <span class="keyword">new</span> <span class="keyword">int</span>[size]; rank = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) </span><br><span class="line">parent[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x != parent[x])</span><br><span class="line">parent[x] = Find(parent[x]);</span><br><span class="line"><span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Union</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> px = Find(x), py = Find(y);</span><br><span class="line"><span class="keyword">if</span> (rank(px) &gt; rank(py)) parent[py] = px;</span><br><span class="line"><span class="keyword">if</span> (rank(py) &gt; rank(px)) parent[px] = py;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">parent[py] = px;</span><br><span class="line">rank[px]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (edges.length != n - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">UnionFindSet ufs = <span class="keyword">new</span> UnionFindSet();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] edge: edges) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(edge[<span class="number">0</span>]) == ufs.find(edge[<span class="number">1</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">ufs.union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (ufs.find(i - <span class="number">1</span>) != ufs.find(i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-178-graph-valid-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-178-graph-valid-tree&quot;&gt;&lt;/a&gt; LintCode Q 178 - Graph Valid Tree&lt;/h1&gt;
&lt;p&gt;Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: n = 5 edges = [[0, 1], [0, 2], [0, 3], [1, 4]] ; Output: true.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: n = 5 edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] ; Output: false.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.&lt;/p&gt;
    
    </summary>
    
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Disjoint Set" scheme="http://yoursite.com/tags/Disjoint-Set/"/>
    
      <category term="Union Find" scheme="http://yoursite.com/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Serialize and Deserialize Binary Tree</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ297/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ297/</id>
    <published>2019-05-01T20:16:30.000Z</published>
    <updated>2019-05-01T20:43:01.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-297-serialize-and-deserialize-binary-tree"><a class="markdownIt-Anchor" href="#leetcode-q-297-serialize-and-deserialize-binary-tree"></a> LeetCode Q 297 - Serialize and Deserialize Binary Tree</h1><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Example:<br>You may serialize the following tree: as “[1,2,3,null,null,4,5]”<br>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>You can find Binary Tree Representation in BFS <a href="https://www.lintcode.com/help/binary-tree-representation/" target="_blank" rel="noopener">here</a></p><h3 id="solution-1-dfs"><a class="markdownIt-Anchor" href="#solution-1-dfs"></a> Solution 1 : DFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root.val + <span class="string">","</span> + serialize(root.left) + <span class="string">","</span> + serialize(root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">String[] strs= data.split(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">return</span> deserializeDFS(strs, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">deserializeDFS</span><span class="params">(strs, <span class="keyword">int</span>[] index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (strs[index[<span class="number">0</span>]].equals(<span class="string">"#"</span>)) &#123;</span><br><span class="line">index[<span class="number">0</span>]++; <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode (Integer.parseInt(strs[index[<span class="number">0</span>]]));</span><br><span class="line">index[<span class="number">0</span>]++;</span><br><span class="line">root.left = deserializeDFS(strs, index);</span><br><span class="line">root.right = deserializeDFS(strs, index);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(root.val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">sb.append(<span class="string">"#"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sb.append(curr.val);</span><br><span class="line">que.offer(curr.left);</span><br><span class="line">que.offer(curr.right);</span><br><span class="line">&#125; </span><br><span class="line">que.offer(<span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sb.toString.substring(<span class="number">0</span>, sb.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (data.equals(<span class="string">"#"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">String[] strs = data.split(<span class="string">","</span>);</span><br><span class="line">Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">TreeNode head = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[<span class="number">0</span>]));</span><br><span class="line">que.offer(head);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (idx &lt; s.length()) &#123;</span><br><span class="line">TreeNode curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (strs[idx].equals(<span class="string">'#'</span>)) &#123;</span><br><span class="line">curr.left = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[idx]));</span><br><span class="line">que.offer(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strs[idx].equals(<span class="string">'#'</span>)) &#123;</span><br><span class="line">curr.right = <span class="keyword">null</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curr.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[idx]));</span><br><span class="line">que.offer(cur.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-297-serialize-and-deserialize-binary-tree&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-297-serialize-and-deserialize-binary-tree&quot;&gt;&lt;/a&gt; LeetCode Q 297 - Serialize and Deserialize Binary Tree&lt;/h1&gt;
&lt;p&gt;Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.&lt;br&gt;
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
You may serialize the following tree: as “[1,2,3,null,null,4,5]”&lt;br&gt;
Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.&lt;/p&gt;
&lt;p&gt;Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ102/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ102/</id>
    <published>2019-05-01T20:05:26.000Z</published>
    <updated>2019-05-01T20:16:53.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-102-binary-tree-level-order-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-102-binary-tree-level-order-traversal"></a> LeetCode Q 102 - Binary Tree Level Order Traversal</h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p><p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>3<br>/ <br>9  20<br>/  <br>15   7<br>return its level order traversal as:<br>[<br>[3],<br>[9,20],<br>[15,7]<br>]</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(root);</span><br><span class="line"><span class="keyword">while</span>(!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">TreeNode node = que.poll();</span><br><span class="line">temp.add(node.val);</span><br><span class="line"><span class="keyword">if</span> (node.left != <span class="keyword">null</span>) que.offer(node.left);</span><br><span class="line"><span class="keyword">if</span> (node.right != <span class="keyword">null</span>) que.offer(node.right);</span><br><span class="line">&#125;</span><br><span class="line">res.add(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-102-binary-tree-level-order-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-102-binary-tree-level-order-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 102 - Binary Tree Level Order Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;
Given binary tree [3,9,20,null,null,15,7],&lt;br&gt;
3&lt;br&gt;
/ &lt;br&gt;
9  20&lt;br&gt;
/  &lt;br&gt;
15   7&lt;br&gt;
return its level order traversal as:&lt;br&gt;
[&lt;br&gt;
[3],&lt;br&gt;
[9,20],&lt;br&gt;
[15,7]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Cut Off Trees for Golf Event</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ675/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ675/</id>
    <published>2019-05-01T19:23:30.000Z</published>
    <updated>2019-05-01T19:59:39.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-675-cut-off-trees-for-golf-event"><a class="markdownIt-Anchor" href="#leetcode-q-675-cut-off-trees-for-golf-event"></a> LeetCode Q 675 - Cut Off Trees for Golf Event</h1><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p><ul><li>0 represents the obstacle can’t be reached.</li><li>1 represents the ground can be walked through.</li><li>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.</li></ul><p>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.<br>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p><p>Example 1:<br>Input:<br>[<br>[1,2,3],<br>[0,0,4],<br>[7,6,5]<br>]<br>Output: 6</p><p>Example 2:</p><p>Input:<br>[<br>[1,2,3],<br>[0,0,0],<br>[7,6,5]<br>]<br>Output: -1</p><p>Example 3:<br>Input:<br>[<br>[2,3,4],<br>[0,0,5],<br>[8,7,6]<br>]<br>Output: 6<br>Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.</p><p><strong>Hint:</strong> size of the given matrix will not exceed 50x50.</p><a id="more"></a><h2 id="solution-bfs-priorityqueue"><a class="markdownIt-Anchor" href="#solution-bfs-priorityqueue"></a> Solution : BFS + PriorityQueue</h2><p><strong>PriorityQueue:</strong> store each tree, order them according to their heights for low to high.</p><p><strong>BFS:</strong> find min steps</p><p><strong>Time complexity analysis:</strong><br>The <strong>worst case</strong> time complexity could be <code>O(m^2 * n^2) (m = number of rows, n = number of columns)</code> since there are <code>m * n</code> <strong>trees</strong> and for <strong>each BFS</strong> worst case time complexity is <code>O(m * n)</code> too.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line">PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the priorityqueue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; r++) &#123;</span><br><span class="line"><span class="keyword">if</span> (forest.get(r).get(c) &gt; <span class="number">0</span>)</span><br><span class="line">pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c, forest.get(r).get(c)&#125;); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bfs find the min step</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, sr = <span class="number">0</span>, sc = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span>[] tree = pq.poll();</span><br><span class="line"><span class="keyword">int</span> dist = getDistBFS(forest, sr, sc, tree[<span class="number">0</span>], tree[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (dist == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">sum += dist;</span><br><span class="line">sr = tree[<span class="number">0</span>]; sc = tree[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistBFS</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; forest, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> tr, <span class="keyword">int</span> tc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = forest.size(), C = forest.get(<span class="number">0</span>).size();</span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">visited[sr][sc] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList();</span><br><span class="line">que.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;sr, sc, <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">if</span> (curr[<span class="number">0</span>] == tr &amp;&amp; curr[<span class="number">1</span>] == tc) <span class="keyword">return</span> curr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) &#123;</span><br><span class="line"><span class="keyword">int</span> r = curr[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> c = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; R &amp;&amp; c &lt; C &amp;&amp; !visited[r][c]) &#123;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c, curr[<span class="number">2</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-675-cut-off-trees-for-golf-event&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-675-cut-off-trees-for-golf-event&quot;&gt;&lt;/a&gt; LeetCode Q 675 - Cut Off Trees for Golf Event&lt;/h1&gt;
&lt;p&gt;You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 represents the obstacle can’t be reached.&lt;/li&gt;
&lt;li&gt;1 represents the ground can be walked through.&lt;/li&gt;
&lt;li&gt;The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).&lt;br&gt;
You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.&lt;br&gt;
You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
Input:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[0,0,4],&lt;br&gt;
[7,6,5]&lt;br&gt;
]&lt;br&gt;
Output: 6&lt;/p&gt;
&lt;p&gt;Example 2:&lt;/p&gt;
&lt;p&gt;Input:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[0,0,0],&lt;br&gt;
[7,6,5]&lt;br&gt;
]&lt;br&gt;
Output: -1&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
Input:&lt;br&gt;
[&lt;br&gt;
[2,3,4],&lt;br&gt;
[0,0,5],&lt;br&gt;
[8,7,6]&lt;br&gt;
]&lt;br&gt;
Output: 6&lt;br&gt;
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hint:&lt;/strong&gt; size of the given matrix will not exceed 50x50.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Shortest Bridge</title>
    <link href="http://yoursite.com/2019/05/01/leetcodeQ934/"/>
    <id>http://yoursite.com/2019/05/01/leetcodeQ934/</id>
    <published>2019-05-01T16:41:11.000Z</published>
    <updated>2019-05-01T19:44:57.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-934-shortest-bridge"><a class="markdownIt-Anchor" href="#leetcode-q-934-shortest-bridge"></a> LeetCode Q 934 - Shortest Bridge</h1><p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)<br>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.<br>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p><p>Example 1:<br><code>Input: [[0,1],[1,0]] ; Output: 1</code></p><p>Example 2:<br><code>Input: [[0,1,0],[0,0,0],[0,0,1]] ; Output: 2</code></p><p>Example 3:<br><code>Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]; Output: 1</code></p><p><strong>Note:</strong></p><ul><li>1 &lt;= A.length = A[0].length &lt;= 100</li><li>A[i][j] == 0 or A[i][j] == 1</li></ul><a id="more"></a><h2 id="solution-dfs-bfs"><a class="markdownIt-Anchor" href="#solution-dfs-bfs"></a> Solution : DFS + BFS</h2><p><strong>DFS:</strong> find the first island, offer all its lands to the que.</p><p><strong>BFS:</strong> expand the found island layer by layer until it reaches another one.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] DIRS = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123; &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line"></span><br><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; que = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. DFS to find one island, put its land in the queue</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; c++) &#123;</span><br><span class="line"><span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (A[r][c] == <span class="number">1</span>) &#123;</span><br><span class="line">dfs(A, visited, r, c, que);</span><br><span class="line">found = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. BFS to expand the current found island to let it reach another one</span></span><br><span class="line"><span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">while</span> (size-- != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>[] curr = que.poll();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) &#123;</span><br><span class="line"><span class="keyword">int</span> i = curr[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> j = curr[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; R &amp;&amp; j &lt; C &amp;&amp; !visited[i][j] ) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) <span class="keyword">return</span> level;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">level++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c, Queue&lt;<span class="keyword">int</span>[]&gt; que)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span> || r == A.length || c == A[<span class="number">0</span>].length || visited[r][c] || A[r][c] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">que.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;r, c&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] dir: DIRS) dfs(A, visited, dirs, que, r + dir[<span class="number">0</span>], c + dir[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-934-shortest-bridge&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-934-shortest-bridge&quot;&gt;&lt;/a&gt; LeetCode Q 934 - Shortest Bridge&lt;/h1&gt;
&lt;p&gt;In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)&lt;br&gt;
Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.&lt;br&gt;
Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[0,1],[1,0]] ; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: [[0,1,0],[0,0,0],[0,0,1]] ; Output: 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;
&lt;code&gt;Input: [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= A.length = A[0].length &amp;lt;= 100&lt;/li&gt;
&lt;li&gt;A[i][j] == 0 or A[i][j] == 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
</feed>
