<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-23T22:04:40.583Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Paint House</title>
    <link href="http://yoursite.com/2019/04/23/lintcodeQ515/"/>
    <id>http://yoursite.com/2019/04/23/lintcodeQ515/</id>
    <published>2019-04-23T21:53:34.000Z</published>
    <updated>2019-04-23T22:04:40.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-515-paint-house"><a class="markdownIt-Anchor" href="#lintcode-q-515-paint-house"></a> LintCode Q 515 - Paint House</h1><p>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost.<br>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p><p>Example 1:<br><code>Input: [[14,2,11],[11,14,5],[14,3,10]] ; Output: 10</code><br>Explanation: blue green blue, 2 + 5 + 3 = 10<br>Example 2:<br><code>Input: [[1,2,3],[1,4,6]] ; Output: 3</code><br>Notice: All costs are positive integers.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><h3 id="solution-1"><a class="markdownIt-Anchor" href="#solution-1"></a> Solution 1</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (costs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = costs.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>]) + costs[i][<span class="number">0</span>];</span><br><span class="line">    dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>]) + costs[i][<span class="number">1</span>];</span><br><span class="line">    dp[i][<span class="number">2</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]) + costs[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(dp[n-<span class="number">1</span>][<span class="number">0</span>], Math.min(dp[n-<span class="number">1</span>][<span class="number">1</span>], dp[n-<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-optimizing-the-space-complexity-using-sliding-arrays"><a class="markdownIt-Anchor" href="#solution-2-optimizing-the-space-complexity-using-sliding-arrays"></a> Solution 2: Optimizing the space complexity using sliding arrays</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (costs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> old = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = costs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = costs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">2</span>] = costs[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">old = now;    <span class="comment">// old = 0 now = 1  or old = 1 now = 0</span></span><br><span class="line">now = <span class="number">1</span> - old;</span><br><span class="line">dp[now][<span class="number">0</span>] = Math.min(dp[old][<span class="number">1</span>], dp[old][<span class="number">2</span>]) + costs[i][<span class="number">0</span>];</span><br><span class="line">dp[now][<span class="number">1</span>] = Math.min(dp[old][<span class="number">0</span>], dp[old][<span class="number">2</span>]) + costs[i][<span class="number">1</span>];</span><br><span class="line">dp[now][<span class="number">2</span>] = Math.min(dp[old][<span class="number">0</span>], dp[old][<span class="number">1</span>]) + costs[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(dp[now][<span class="number">0</span>], Math.min(dp[now][<span class="number">1</span>], dp[now][<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#06bcf9">Sliding arrays is always used to save the space complexity.</font>**<br>**For example: **<br><strong>Tradition method for solving the Fibonacci problem</strong><br><code>int f[100]; f[0] = 0; f[1] = 1; f[2] = 1; for(int i = 3; i &lt;= n; ++i) f[i] = f[i - 1] + f[i - 2]; return f[n];</code><br><strong>Sliding array for solving the Fibonacci problem</strong><br><code>int f[3]; f[1] = 0; f[2] = 1; for(int i = 2; i &lt;= n; ++i) { f[0] = f[1]; f[1] = f[2]; f[2] = f[0] + f[1]; } return f[2];</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-515-paint-house&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-515-paint-house&quot;&gt;&lt;/a&gt; LintCode Q 515 - Paint House&lt;/h1&gt;
&lt;p&gt;There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color, and you need to cost the least. Return the minimum cost.&lt;br&gt;
The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [[14,2,11],[11,14,5],[14,3,10]] ; Output: 10&lt;/code&gt;&lt;br&gt;
Explanation: blue green blue, 2 + 5 + 3 = 10&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [[1,2,3],[1,4,6]] ; Output: 3&lt;/code&gt;&lt;br&gt;
Notice: All costs are positive integers.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>House Robber II</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ213/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ213/</id>
    <published>2019-04-23T21:24:09.000Z</published>
    <updated>2019-04-23T21:35:16.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-213-house-robber-ii"><a class="markdownIt-Anchor" href="#leetcode-q-213-house-robber-ii"></a> LeetCode Q 213 - House Robber II</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:<br><code>Input: [2,3,2] ; Output: 3</code><br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.<br>Example 2:<br><code>Input: [1,2,3,1] ; Output: 4</code><br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp1 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span>[] dp2 = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">// including from the first house not the last house</span></span><br><span class="line">dp1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) </span><br><span class="line">dp1[i] = Math.max(dp1[i - <span class="number">1</span>], nums[i] + (i &gt;= <span class="number">2</span> ? dp1[i - <span class="number">2</span>] : <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// including from the last house not the first house</span></span><br><span class="line">dp2[<span class="number">0</span>] = <span class="number">0</span>; dp2[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++) </span><br><span class="line">dp2[i] = Math.max(dp2[i - <span class="number">1</span>], nums[i] + dp2[i - <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(dp1[nums.length - <span class="number">2</span>], dp2[nums.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-213-house-robber-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-213-house-robber-ii&quot;&gt;&lt;/a&gt; LeetCode Q 213 - House Robber II&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are &lt;strong&gt;arranged in a circle&lt;/strong&gt;. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;br&gt;
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [2,3,2] ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,1] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>House Robber</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ198/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ198/</id>
    <published>2019-04-23T21:21:53.000Z</published>
    <updated>2019-04-23T21:23:35.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-198-house-robber"><a class="markdownIt-Anchor" href="#leetcode-q-198-house-robber"></a> LeetCode Q 198 - House Robber</h1><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p><p>Example 1:<br><code>Input: [1,2,3,1] ; Output: 4</code><br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.<br>Example 2:<br><code>Input: [2,7,9,3,1] ; Output: 12</code><br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="comment">// boundary case 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) </span><br><span class="line">dp[i] = Math.max(nums[i] + (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>), dp[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-198-house-robber&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-198-house-robber&quot;&gt;&lt;/a&gt; LeetCode Q 198 - House Robber&lt;/h1&gt;
&lt;p&gt;You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;br&gt;
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,1] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [2,7,9,3,1] ; Output: 12&lt;/code&gt;&lt;br&gt;
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock with Cooldown</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ309/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ309/</id>
    <published>2019-04-23T20:56:37.000Z</published>
    <updated>2019-04-23T21:13:46.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-123-best-time-to-buy-and-sell-stock-with-cooldown"><a class="markdownIt-Anchor" href="#leetcode-q-123-best-time-to-buy-and-sell-stock-with-cooldown"></a> LeetCode Q 123 - Best Time to Buy and Sell Stock with Cooldown</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). <strong>After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)</strong><br>Example:<br><code>Input: [1,2,3,0,2] ; Output: 3</code><br>Explanation: transactions = [buy, sell, cooldown, buy, sell]</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p>We can use 4 varaibles to represent the transaction states until day <em><strong>i</strong></em>. They are <strong>buy, sell, hold, cooldown</strong>. Their relationship is shown as follows.<br><img src="leetcodeQ309-1.png" width="50%" height="50%"></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buy = -prices[<span class="number">0</span>], hold = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> sell = <span class="number">0</span>, cooldown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line"><span class="keyword">int</span> orig_hold = hold, orig_sell = sell;</span><br><span class="line">hold = Math.max(hold, buy);</span><br><span class="line">sell = Math.max(buy, orig_hold) + price;</span><br><span class="line">buy = cooldown - price;</span><br><span class="line">cooldown = Math.max(cooldown, orig_sell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(sell, cooldown);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-123-best-time-to-buy-and-sell-stock-with-cooldown&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-123-best-time-to-buy-and-sell-stock-with-cooldown&quot;&gt;&lt;/a&gt; LeetCode Q 123 - Best Time to Buy and Sell Stock with Cooldown&lt;/h1&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;br&gt;
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:&lt;br&gt;
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). &lt;strong&gt;After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)&lt;/strong&gt;&lt;br&gt;
Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,0,2] ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: transactions = [buy, sell, cooldown, buy, sell]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock III</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ123/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ123/</id>
    <published>2019-04-23T20:40:01.000Z</published>
    <updated>2019-04-23T20:56:21.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-123-best-time-to-buy-and-sell-stock-iii"><a class="markdownIt-Anchor" href="#leetcode-q-123-best-time-to-buy-and-sell-stock-iii"></a> LeetCode Q 123 - Best Time to Buy and Sell Stock III</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete <strong>at most two transactions</strong>.<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:<br><code>Input: [3,3,5,0,0,3,1,4] ; Output: 6</code><br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.<br>Example 2:<br><code>Input: [1,2,3,4,5] ; Output: 4</code><br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:<br><code>Input: [7,6,4,3,1] ; Output: 0</code><br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Transfer state function:</strong><br><code>dp[k][i] = Math.max(dp[k][i-1], prices[i]-prices[j]+dp[k-1][j-1]) j=[0,1,..i-1]</code></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][prices.length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> max = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= prices.length; i++) &#123;</span><br><span class="line">max = Math.max(max, -prices[i] + dp[k - <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">dp[k][i] = Math.max(dp[k][i - <span class="number">1</span>], prices[i] + max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">2</span>][prices.length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code: Optimize the Time Complexity to O(1)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oneBuyCost = Integer.MIN_VALUE, oneBuyProfit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> twoBuyCost = Integer.MIN_VALUE, twoBuyProfit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">oneBuyCost = Math.min(oneBuyCost, price);</span><br><span class="line">oneBuyProfit = Math.max(oneBuyProfit, price - oneBuyCost);</span><br><span class="line">twoBuyCost = Math.max(twoBuyCost, -price + oneBuyProfit);</span><br><span class="line">twoBuyProfit = Math.max(twoBuyProfit, price + twoBuyCost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> twoBuyProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the oneBuyCost keeps track of the lowest price, and oneBuyProfit keeps track of the biggest profit we could get.<br>Then the <strong>tricky</strong> part comes, how to handle the <strong>twoBuyCost</strong>? Why <code>twoBuyCost = Math.max(twoBuyCost, -price + oneBuyProfit);</code>? Suppose in real life, you have bought and sold a stock and made $100 dollar profit. When you want to purchase a stock which costs you $300 dollars, how would you think this? You must think, um, I have made $100 profit, so I think this $300 dollar stock is worth $200 FOR ME since I have hold $100 for free.<br>There we go, you got the idea how we calculate twoBuyCost!! We just minimize the cost again!! The twoBuyProfit is just making as much profit as possible.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-123-best-time-to-buy-and-sell-stock-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-123-best-time-to-buy-and-sell-stock-iii&quot;&gt;&lt;/a&gt; LeetCode Q 123 - Best Time to Buy and Sell Stock III&lt;/h1&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;br&gt;
Design an algorithm to find the maximum profit. You may complete &lt;strong&gt;at most two transactions&lt;/strong&gt;.&lt;br&gt;
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [3,3,5,0,0,3,1,4] ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,4,5] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [7,6,4,3,1] ; Output: 0&lt;/code&gt;&lt;br&gt;
Explanation: In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock II</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ122/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ122/</id>
    <published>2019-04-23T19:35:43.000Z</published>
    <updated>2019-04-23T20:47:40.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-122-best-time-to-buy-and-sell-stock-ii"><a class="markdownIt-Anchor" href="#leetcode-q-122-best-time-to-buy-and-sell-stock-ii"></a> LeetCode Q 122 - Best Time to Buy and Sell Stock II</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may <strong>complete as many transactions as you like</strong> (i.e., buy one and sell one share of the stock multiple times).</p><p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p><p>Example 1:</p><p><code>Input: [7,1,5,3,6,4] ; Output: 7</code><br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.<br>Example 2:<br><code>Input: [1,2,3,4,5] ; Output: 4</code><br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:<br><code>Input: [7,6,4,3,1] ; Output: 0</code><br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = i;</span><br><span class="line"><span class="keyword">while</span> (temp + <span class="number">1</span> &lt; prices.length &amp;&amp; prices[temp] &lt; prices[temp + <span class="number">1</span>]) </span><br><span class="line">temp++; </span><br><span class="line">profit += prices[temp] - prices[i];</span><br><span class="line">i = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-122-best-time-to-buy-and-sell-stock-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-122-best-time-to-buy-and-sell-stock-ii&quot;&gt;&lt;/a&gt; LeetCode Q 122 - Best Time to Buy and Sell Stock II&lt;/h1&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;br&gt;
Design an algorithm to find the maximum profit. You may &lt;strong&gt;complete as many transactions as you like&lt;/strong&gt; (i.e., buy one and sell one share of the stock multiple times).&lt;/p&gt;
&lt;p&gt;Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: [7,1,5,3,6,4] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,4,5] ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [7,6,4,3,1] ; Output: 0&lt;/code&gt;&lt;br&gt;
Explanation: In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Best Time to Buy and Sell Stock</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ121/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ121/</id>
    <published>2019-04-23T19:30:54.000Z</published>
    <updated>2019-04-23T19:35:12.619Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-121-best-time-to-buy-and-sell-stock"><a class="markdownIt-Anchor" href="#leetcode-q-121-best-time-to-buy-and-sell-stock"></a> LeetCode Q 121 - Best Time to Buy and Sell Stock</h1><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p><p>Example 1:<br><code>Input: [7,1,5,3,6,4] ; Output: 5</code><br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:<br><code>Input: [7,6,4,3,1] ; Output: 0</code><br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code: Use Array</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buy = <span class="number">0</span>, sell = <span class="number">0</span>, profit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &lt; prices[buy]) buy = i;</span><br><span class="line"><span class="keyword">if</span> (prices[i] &gt; prices[sell]) sell = i;</span><br><span class="line"><span class="keyword">if</span> (buy &gt; sell) sell = buy;</span><br><span class="line">profit = Math.max(profit, prices[sell] - prices[buy]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-121-best-time-to-buy-and-sell-stock&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-121-best-time-to-buy-and-sell-stock&quot;&gt;&lt;/a&gt; LeetCode Q 121 - Best Time to Buy and Sell Stock&lt;/h1&gt;
&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;br&gt;
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;br&gt;
Note that you cannot sell a stock before you buy one.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [7,1,5,3,6,4] ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [7,6,4,3,1] ; Output: 0&lt;/code&gt;&lt;br&gt;
Explanation: In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Triangle</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ120/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ120/</id>
    <published>2019-04-23T19:09:17.000Z</published>
    <updated>2019-04-23T19:14:03.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-120-triangle"><a class="markdownIt-Anchor" href="#leetcode-q-120-triangle"></a> LeetCode Q 120 - Triangle</h1><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>For example, given the following triangle<br><code>[ [2], [3,4], [6,5,7], [4,1,8,3] ]</code><br>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p><p><strong>Note:</strong> Bonus point if you are able to do this using only <strong>O(n)</strong> extra space, where n is the total number of rows in the triangle.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code: Use Array</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (triangle == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dp.length; i++) </span><br><span class="line">dp[i] = triangle.get(triangle.size() - <span class="number">1</span>).get(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = triangle.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">List&lt;Integer&gt; list = triangle.get(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++)</span><br><span class="line">dp[j] = Math.min(dp[j], dp[j + <span class="number">1</span>]) + list.get(j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Code: Use ArrayList</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = triangle.size();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(triangle.get(n-<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">list.set(j, triangle.get(i).get(j) + Math.min(list.get(j), list.get(j + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-120-triangle&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-120-triangle&quot;&gt;&lt;/a&gt; LeetCode Q 120 - Triangle&lt;/h1&gt;
&lt;p&gt;Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.&lt;/p&gt;
&lt;p&gt;For example, given the following triangle&lt;br&gt;
&lt;code&gt;[ [2], [3,4], [6,5,7], [4,1,8,3] ]&lt;/code&gt;&lt;br&gt;
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Bonus point if you are able to do this using only &lt;strong&gt;O(n)&lt;/strong&gt; extra space, where n is the total number of rows in the triangle.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees II</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ95/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ95/</id>
    <published>2019-04-23T19:01:38.000Z</published>
    <updated>2019-04-23T19:08:10.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-95-unique-binary-search-trees-ii"><a class="markdownIt-Anchor" href="#leetcode-q-95-unique-binary-search-trees-ii"></a> LeetCode Q 95 - Unique Binary Search Trees II</h1><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.</p><p>Example:<br><code>Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ]</code></p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">return</span> generate(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generate</span> <span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">List&lt;TreeNode&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">res.add(<span class="keyword">null</span>); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> TreeNode(start)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">List&lt;TreeNode&gt; leftNodes = generate(start, i - <span class="number">1</span>);</span><br><span class="line">List&lt;TreeNode&gt; rightNodes = generate(i + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (TreeNode l: leftNodes) &#123;</span><br><span class="line"><span class="keyword">for</span> (TreeNode r: rightNodes) &#123;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">root.left = l; root.right = r;</span><br><span class="line">res.add(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-95-unique-binary-search-trees-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-95-unique-binary-search-trees-ii&quot;&gt;&lt;/a&gt; LeetCode Q 95 - Unique Binary Search Trees II&lt;/h1&gt;
&lt;p&gt;Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1 … n.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Unique Binary Search Trees</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ96/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ96/</id>
    <published>2019-04-23T17:32:16.000Z</published>
    <updated>2019-04-23T19:01:20.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-96-unique-binary-search-trees"><a class="markdownIt-Anchor" href="#leetcode-q-96-unique-binary-search-trees"></a> LeetCode Q 96 - Unique Binary Search Trees</h1><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p><p>Example:<br><code>Input: 3 ; Output: 5</code></p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>]  = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) </span><br><span class="line">dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-96-unique-binary-search-trees&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-96-unique-binary-search-trees&quot;&gt;&lt;/a&gt; LeetCode Q 96 - Unique Binary Search Trees&lt;/h1&gt;
&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 3 ; Output: 5&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
  </entry>
  
  <entry>
    <title>Decode Ways II</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ639/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ639/</id>
    <published>2019-04-23T17:19:01.000Z</published>
    <updated>2019-04-23T17:31:09.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-639-decode-ways-ii"><a class="markdownIt-Anchor" href="#leetcode-q-639-decode-ways-ii"></a> LeetCode Q 639 - Decode Ways II</h1><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><code>'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26</code><br><strong>Beyond that, now the encoded string can also contain the character ‘*’, which can be treated as one of the numbers from 1 to 9.</strong><br>Given the encoded message containing digits and the character ‘*’, return the total number of ways to decode it.<br>Also, since the answer may be very large, you should return the <strong>output mod 10^9 + 7</strong>.</p><p>Example 1:<br><code>Input: &quot;*&quot; ; Output: 9</code><br>Explanation: The encoded message can be decoded to the string: “A”, “B”, “C”, “D”, “E”, “F”, “G”, “H”, “I”.<br>Example 2:<br><code>Input: &quot;1*&quot; ; Output: 9 + 9 = 18</code></p><p><strong>Note:</strong> The length of the input string will fit in range [1, 105]. The input string will only contain the character ‘*’ and digits ‘0’ - ‘9’.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span>[] dp = <span class="keyword">new</span> <span class="keyword">long</span>[s.length() + <span class="number">1</span>]; <span class="comment">// int[] will cause Integer overflow!</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'*'</span> ? <span class="number">9</span> : s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'*'</span>) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>] = dp[i] * <span class="number">9</span>;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>] * <span class="number">9</span>) % M;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>] * <span class="number">6</span>) % M;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>] * <span class="number">15</span>) % M; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dp[i + <span class="number">1</span>] = s.charAt(i) == <span class="string">'0'</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'6'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + dp[i - <span class="number">1</span>]) % M;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">dp[i + <span class="number">1</span>] = (dp[i + <span class="number">1</span>] + (s.charAt(i) &lt;= <span class="string">'6'</span> ? <span class="number">2</span> : <span class="number">1</span>) * dp[i - <span class="number">1</span>]) % M;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>) dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-639-decode-ways-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-639-decode-ways-ii&quot;&gt;&lt;/a&gt; LeetCode Q 639 - Decode Ways II&lt;/h1&gt;
&lt;p&gt;A message containing letters from A-Z is being encoded to numbers using the following mapping:&lt;br&gt;
&lt;code&gt;&#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Beyond that, now the encoded string can also contain the character ‘*’, which can be treated as one of the numbers from 1 to 9.&lt;/strong&gt;&lt;br&gt;
Given the encoded message containing digits and the character ‘*’, return the total number of ways to decode it.&lt;br&gt;
Also, since the answer may be very large, you should return the &lt;strong&gt;output mod 10^9 + 7&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;*&amp;quot; ; Output: 9&lt;/code&gt;&lt;br&gt;
Explanation: The encoded message can be decoded to the string: “A”, “B”, “C”, “D”, “E”, “F”, “G”, “H”, “I”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;1*&amp;quot; ; Output: 9 + 9 = 18&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The length of the input string will fit in range [1, 105]. The input string will only contain the character ‘*’ and digits ‘0’ - ‘9’.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Decode Ways</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ91/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ91/</id>
    <published>2019-04-23T17:02:06.000Z</published>
    <updated>2019-04-23T17:18:27.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-91-decode-ways"><a class="markdownIt-Anchor" href="#leetcode-q-91-decode-ways"></a> LeetCode Q 91 - Decode Ways</h1><p>A message containing letters from A-Z is being encoded to numbers using the following mapping:<br><code>'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26</code><br>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p><p>Example 1:<br><code>Input: &quot;12&quot; ; Output: 2</code><br>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:<br><code>Input: &quot;226&quot; ; Output: 3</code><br>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()]; </span><br><span class="line">dp[<span class="number">0</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) != <span class="string">'0'</span>)</span><br><span class="line">dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'1'</span> || </span><br><span class="line">    s.charAt(i - <span class="number">1</span>) == <span class="string">'2'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'6'</span>)</span><br><span class="line">dp[i] += i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[s.length() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-91-decode-ways&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-91-decode-ways&quot;&gt;&lt;/a&gt; LeetCode Q 91 - Decode Ways&lt;/h1&gt;
&lt;p&gt;A message containing letters from A-Z is being encoded to numbers using the following mapping:&lt;br&gt;
&lt;code&gt;&#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26&lt;/code&gt;&lt;br&gt;
Given a non-empty string containing only digits, determine the total number of ways to decode it.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;12&amp;quot; ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: It could be decoded as “AB” (1 2) or “L” (12).&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;226&amp;quot; ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Trapping Rain Water</title>
    <link href="http://yoursite.com/2019/04/23/leetcodeQ42/"/>
    <id>http://yoursite.com/2019/04/23/leetcodeQ42/</id>
    <published>2019-04-23T14:14:37.000Z</published>
    <updated>2019-04-23T15:32:07.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-42-trapping-rain-water"><a class="markdownIt-Anchor" href="#leetcode-q-42-trapping-rain-water"></a> LeetCode Q 42 - Trapping Rain Water</h1><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><img src="leetcodeQ42-1.png" width="30%" height="30%"><br>The above elevation map is represented by array [2,1,0,2,4]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!<br>Example:<br><code>Input: [2,1,0,2,4] ; Output: 3</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><ol><li>Build two arrays <code>left[] and right[]</code>, which stores the maximum height of the water considering only its left and its right, respectively.</li><li>Traverse the arrays, calculate <code>Sum(min(left[i], right[i]) - height[i])</code>. This is because the maximum water it can trap depends both on its left and right.</li></ol><p>We can use the following graph to explain.<br><img src="leetcodeQ42-2.png" width="50%" height="50%"></p><ol><li>the <strong>yellow shade</strong> shows the water trapped only considering its <strong>left</strong></li><li>the <strong>green shade</strong> shows the water trapped only considering its <strong>right</strong></li><li>the <strong>blue shade</strong> shows their intersection, the sum of which is the answer.</li></ol><p><strong>Tips:</strong> in this question we actually need to consider the influence of both left and right. We simply this type of question by only consider left or right at a time and find the intersection.<br><strong>Similar Questions:</strong> {}, {}</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = height.length;</span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">left[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">left[i] = Math.max(left[i - <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line">right[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">right[i] = Math.max(right[i + <span class="number">1</span>], height[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">res += Math.min(left[i], right[i]) - height[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-stack"><a class="markdownIt-Anchor" href="#solution-2-stack"></a> Solution 2: Stack</h3><p>The <strong>Key point</strong> is We use the stack to store the positions, the corresponding heights of which are ordered <strong>decreasingly</strong>. So the <strong>top</strong> int stored in the stack is <strong>the pos of local minimum height</strong>. When we meet a height, which is higher than the height corresponding ot the top element in the stack, we find the vally, which can trap water.</p><p>Using the stack, we fill the water layer by layer, shown as follows.<br><img src="leetcodeQ42-3.png" width="30%" height="30%"></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (curr &lt; height.length) &#123;</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() || height[curr] &gt; height[stack.peek()]) &#123;</span><br><span class="line"><span class="keyword">int</span> top = stack.pop(); <span class="comment">// we pop the pos of local minimum height</span></span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty) <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">int</span> dist = curr - stack.peek() - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> height = Math.min(height[curr], height[stack.peek()]) - height[top];</span><br><span class="line">res += dist * height;</span><br><span class="line">&#125;</span><br><span class="line">stack.push(curr++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-42-trapping-rain-water&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-42-trapping-rain-water&quot;&gt;&lt;/a&gt; LeetCode Q 42 - Trapping Rain Water&lt;/h1&gt;
&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;br&gt;
&lt;img src=&quot;leetcodeQ42-1.png&quot; width=&quot;30%&quot; height=&quot;30%&quot;&gt;&lt;br&gt;
The above elevation map is represented by array [2,1,0,2,4]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!&lt;br&gt;
Example:&lt;br&gt;
&lt;code&gt;Input: [2,1,0,2,4] ; Output: 3&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>Edit Distance</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ72/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ72/</id>
    <published>2019-04-23T00:10:51.000Z</published>
    <updated>2019-04-23T00:25:21.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-72-edit-distance"><a class="markdownIt-Anchor" href="#leetcode-q-72-edit-distance"></a> LeetCode Q 72 - Edit Distance</h1><p>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.<br>You have the following 3 operations permitted on a word:</p><ul><li><strong>Insert a character</strong></li><li><strong>Delete a character</strong></li><li><strong>Replace a character</strong></li></ul><p>Example 1:<br><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot; ; Output: 3</code><br>Explanation:<br><code>horse -&gt; rorse (replace 'h' with 'r') rorse -&gt; rose (remove 'r') rose -&gt; ros (remove 'e')</code><br>Example 2:<br><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot; ; Output: 5</code><br>Explanation:<br><code>intention -&gt; inention (remove 't') inention -&gt; enention (replace 'i' with 'e') enention -&gt; exention (replace 'n' with 'x') exention -&gt; exection (replace 'n' with 'c') exection -&gt; execution (insert 'u')</code></p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><p>dp[i][j]: the distance between ith char in word1 and jth char in word2</p><ul><li>if (word1.charAt(i) == word1.charAt(j)) dp[i][j] = dp[i - 1][j - 1];</li><li>else we can get to j from i though<ul><li>replace a char, dp[i][j] = dp[i - 1][j - 1]</li><li>delete a char, dp[i][j] = dp[i][j - 1];</li><li>insert a char, dp[i][j] = dp[i - 1][j];</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word1.length() == <span class="number">0</span>) <span class="keyword">return</span> word2.length(); <span class="comment">// insert</span></span><br><span class="line"><span class="keyword">if</span> (word2.length() == <span class="number">0</span>) <span class="keyword">return</span> word1.length(); <span class="comment">// delete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = word1.length(), len2 = word2.length();</span><br><span class="line"><span class="comment">// dp[i][j]: the distance between ith char in word1 and jth char in word2</span></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// word1 is ""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len2; i++) </span><br><span class="line">dp[<span class="number">0</span>][i] = i; </span><br><span class="line"><span class="comment">// word2 is ""</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-72-edit-distance&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-72-edit-distance&quot;&gt;&lt;/a&gt; LeetCode Q 72 - Edit Distance&lt;/h1&gt;
&lt;p&gt;Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.&lt;br&gt;
You have the following 3 operations permitted on a word:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Insert a character&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Delete a character&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replace a character&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: word1 = &amp;quot;horse&amp;quot;, word2 = &amp;quot;ros&amp;quot; ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;horse -&amp;gt; rorse (replace &#39;h&#39; with &#39;r&#39;) rorse -&amp;gt; rose (remove &#39;r&#39;) rose -&amp;gt; ros (remove &#39;e&#39;)&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: word1 = &amp;quot;intention&amp;quot;, word2 = &amp;quot;execution&amp;quot; ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;intention -&amp;gt; inention (remove &#39;t&#39;) inention -&amp;gt; enention (replace &#39;i&#39; with &#39;e&#39;) enention -&amp;gt; exention (replace &#39;n&#39; with &#39;x&#39;) exention -&amp;gt; exection (replace &#39;n&#39; with &#39;c&#39;) exection -&amp;gt; execution (insert &#39;u&#39;)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Climbing Stairs</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ70/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ70/</id>
    <published>2019-04-23T00:08:37.000Z</published>
    <updated>2019-04-23T00:24:48.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-70-climbing-stairs"><a class="markdownIt-Anchor" href="#leetcode-q-70-climbing-stairs"></a> LeetCode Q 70 - Climbing Stairs</h1><p>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><strong>Note</strong>: Given n will be a positive integer.</p><p>Example 1:<br><code>Input: 2 ; Output: 2</code><br>Explanation: There are two ways to climb to the top.</p><ol><li>1 step + 1 step</li><li>2 steps<br>Example 2:<br><code>Input: 3 ; Output: 3</code><br>Explanation: There are three ways to climb to the top.</li><li>1 step + 1 step + 1 step</li><li>1 step + 2 steps</li><li>2 steps + 1 step</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-70-climbing-stairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-70-climbing-stairs&quot;&gt;&lt;/a&gt; LeetCode Q 70 - Climbing Stairs&lt;/h1&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;br&gt;
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt;: Given n will be a positive integer.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: 2 ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: There are two ways to climb to the top.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1 step + 1 step&lt;/li&gt;
&lt;li&gt;2 steps&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: 3 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: There are three ways to climb to the top.&lt;/li&gt;
&lt;li&gt;1 step + 1 step + 1 step&lt;/li&gt;
&lt;li&gt;1 step + 2 steps&lt;/li&gt;
&lt;li&gt;2 steps + 1 step&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Path Sum</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ64/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ64/</id>
    <published>2019-04-23T00:02:22.000Z</published>
    <updated>2019-04-23T00:12:36.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-64-minimum-path-sum"><a class="markdownIt-Anchor" href="#leetcode-q-64-minimum-path-sum"></a> LeetCode Q 64 - Minimum Path Sum</h1><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.<br>Note: You can only move either down or right at any point in time.</p><p>Example:<br><code>Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7</code><br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp-using-an-additional-array"><a class="markdownIt-Anchor" href="#solution-1-dp-using-an-additional-array"></a> Solution 1: DP using an additional array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col]; dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-in-place"><a class="markdownIt-Anchor" href="#solution-2-dp-in-place"></a> Solution 2: DP in place</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = grid.length, col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) </span><br><span class="line">grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++)</span><br><span class="line">grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">grid[i][j] += Math.min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> grid[row - <span class="number">1</span>][col - <span class="number">1</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-64-minimum-path-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-64-minimum-path-sum&quot;&gt;&lt;/a&gt; LeetCode Q 64 - Minimum Path Sum&lt;/h1&gt;
&lt;p&gt;Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.&lt;br&gt;
Note: You can only move either down or right at any point in time.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: Because the path 1→3→1→1→1 minimizes the sum.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Paths II</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ63/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ63/</id>
    <published>2019-04-22T23:50:34.000Z</published>
    <updated>2019-04-23T00:25:12.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-63-unique-paths-ii"><a class="markdownIt-Anchor" href="#leetcode-q-63-unique-paths-ii"></a> LeetCode Q 63 - Unique Paths II</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as 1 and 0 respectively in the grid.<br>Note: m and n will be at most 100.</p><p>Comparing with <a href="/2019/04/22/leetcodeQ62/" title="Unique Path">Unique Path</a>, now we have <strong>obstable</strong>!</p><p>Example 1:<br><code>Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2</code><br>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:</p><ol><li>Right -&gt; Right -&gt; Down -&gt; Down</li><li>Down -&gt; Down -&gt; Right -&gt; Right</li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp-using-an-additional-array"><a class="markdownIt-Anchor" href="#solution-1-dp-using-an-additional-array"></a> Solution 1: DP using an additional array</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = obstacleGrid.length, col = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] == <span class="number">0</span>) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-in-place"><a class="markdownIt-Anchor" href="#solution-2-dp-in-place"></a> Solution 2: DP in place</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> R = obstacleGrid.length;</span><br><span class="line"><span class="keyword">int</span> C = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the starting cell has an obstacle, then simply return as there would be</span></span><br><span class="line"><span class="comment">// no paths to the destination.</span></span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of ways of reaching the starting cell = 1.</span></span><br><span class="line">obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filling the values for the first column</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line">obstacleGrid[i][<span class="number">0</span>] = (obstacleGrid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filling the values for the first row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; C; i++) &#123;</span><br><span class="line">obstacleGrid[<span class="number">0</span>][i] = (obstacleGrid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; obstacleGrid[<span class="number">0</span>][i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Starting from cell(1,1) fill up the values</span></span><br><span class="line"><span class="comment">// No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]</span></span><br><span class="line"><span class="comment">// i.e. From above and left.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; R; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; C; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) obstacleGrid[i][j] = obstacleGrid[i - <span class="number">1</span>][j] + obstacleGrid[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return value stored in rightmost bottommost cell. That is the destination.</span></span><br><span class="line"><span class="keyword">return</span> obstacleGrid[R - <span class="number">1</span>][C - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-63-unique-paths-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-63-unique-paths-ii&quot;&gt;&lt;/a&gt; LeetCode Q 63 - Unique Paths II&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;br&gt;
Now consider if some obstacles are added to the grids. How many unique paths would there be?&lt;br&gt;
An obstacle and empty space is marked as 1 and 0 respectively in the grid.&lt;br&gt;
Note: m and n will be at most 100.&lt;/p&gt;
&lt;p&gt;Comparing with &lt;a href=&quot;/2019/04/22/leetcodeQ62/&quot; title=&quot;Unique Path&quot;&gt;Unique Path&lt;/a&gt;, now we have &lt;strong&gt;obstable&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [ [0,0,0], [0,1,0], [0,0,0] ] Output: 2&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
There is one obstacle in the middle of the 3x3 grid above.&lt;br&gt;
There are two ways to reach the bottom-right corner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Right -&amp;gt; Right -&amp;gt; Down -&amp;gt; Down&lt;/li&gt;
&lt;li&gt;Down -&amp;gt; Down -&amp;gt; Right -&amp;gt; Right&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Unique Paths</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ62/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ62/</id>
    <published>2019-04-22T23:47:30.000Z</published>
    <updated>2019-04-23T00:25:17.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-62-unique-paths"><a class="markdownIt-Anchor" href="#leetcode-q-62-unique-paths"></a> LeetCode Q 62 - Unique Paths</h1><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>How many possible unique paths are there?<br>Note: m and n will be at most 100.</p><p>Example 1:<br><code>Input: m = 3, n = 2 ; Output: 3</code><br>Explanation:<br>From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</p><ol><li>Right -&gt; Right -&gt; Down</li><li>Right -&gt; Down -&gt; Right</li><li>Down -&gt; Right -&gt; Right<br>Example 2:<br><code>Input: m = 7, n = 3 ; Output: 28</code></li></ol><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">1</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-62-unique-paths&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-62-unique-paths&quot;&gt;&lt;/a&gt; LeetCode Q 62 - Unique Paths&lt;/h1&gt;
&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;br&gt;
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;br&gt;
How many possible unique paths are there?&lt;br&gt;
Note: m and n will be at most 100.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: m = 3, n = 2 ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Right -&amp;gt; Right -&amp;gt; Down&lt;/li&gt;
&lt;li&gt;Right -&amp;gt; Down -&amp;gt; Right&lt;/li&gt;
&lt;li&gt;Down -&amp;gt; Right -&amp;gt; Right&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: m = 7, n = 3 ; Output: 28&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Subarray</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ53/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ53/</id>
    <published>2019-04-22T23:24:57.000Z</published>
    <updated>2019-04-22T23:43:52.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-53-maximum-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-53-maximum-subarray"></a> LeetCode Q 53 - Maximum Subarray</h1><p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p><p>Example:<br><code>Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6</code><br>Explanation: [4,-1,2,1] has the largest sum = 6.<br><strong>Follow up:</strong> If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>] &lt;= <span class="number">0</span>) dp[i] = nums[i];</span><br><span class="line"><span class="keyword">else</span> dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">maxSum = Math.max(maxSum, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-divide-and-conquer"><a class="markdownIt-Anchor" href="#solution-2-divide-and-conquer"></a> Solution 2: Divide and Conquer</h3><p>A quite clean but detailed explanation can be found <a href="https://leetcode.com/problems/maximum-subarray/discuss/232505/java-solution-divide-and-conquer-way-dynamic-programming-way" target="_blank" rel="noopener">here</a>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> leftSum = sum(nums, left, mid);</span><br><span class="line"><span class="keyword">int</span> rightSum = sum(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="keyword">int</span> crossSum = crossSum(nums, left, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(leftSum, Math.max(rightSum, crossSum));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">crossSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> leftSum = Integer.MIN_VALUE, rightSum = Integer.MIN_VALUE, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (leftSum &lt; sum) leftSum = sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">    <span class="keyword">if</span> (rightSum &lt; sum) rightSum = sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-53-maximum-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-53-maximum-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 53 - Maximum Subarray&lt;/h1&gt;
&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: [4,-1,2,1] has the largest sum = 6.&lt;br&gt;
&lt;strong&gt;Follow up:&lt;/strong&gt; If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>Longest Valid Parentheses</title>
    <link href="http://yoursite.com/2019/04/22/leetcodeQ32/"/>
    <id>http://yoursite.com/2019/04/22/leetcodeQ32/</id>
    <published>2019-04-22T23:04:52.000Z</published>
    <updated>2019-04-22T23:24:22.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-32-longest-valid-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-32-longest-valid-parentheses"></a> LeetCode Q 32 - Longest Valid Parentheses</h1><p>Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p><p>Example 1:<br><code>Input: &quot;(()&quot; ; Output: 2</code><br>Explanation: The longest valid parentheses substring is “()”<br>Example 2:<br><code>Input: &quot;)()())&quot; ; Output: 4</code><br>Explanation: The longest valid parentheses substring is “()()”</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-stack"><a class="markdownIt-Anchor" href="#solution-1-stack"></a> Solution 1: Stack</h3><p>The integer stored the index of invalid ‘)’ and last ‘(’</p><ul><li>whenver we encount a ‘(’, we also push its index;</li><li>whenever we encounter a ‘)’, we first <strong>pop</strong> the 1st element from stack, there are <strong>two</strong> cases:<ul><li>the 1st element is the index of ‘(’, in which case the stack must not be <strong>empty</strong>, since we always store the last index of invalid ‘)’ in the stack, then update the <strong>maxLen</strong>;</li><li>the 1st element is the index of ‘)’, in which case the stack should be <strong>empty</strong>, since we only store the last index of invalid ‘)’ in the stack, then update the index of ‘)’ stored in the stack.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'('</span>) &#123;</span><br><span class="line">stack.push(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">stack.push(i);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">maxLen = Math.max(maxLen, i - stack.peek());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-todo"><a class="markdownIt-Anchor" href="#solution-2-dp-todo"></a> Solution 2: DP (TODO)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-32-longest-valid-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-32-longest-valid-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 32 - Longest Valid Parentheses&lt;/h1&gt;
&lt;p&gt;Given a string containing just the characters ‘(’ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;(()&amp;quot; ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: The longest valid parentheses substring is “()”&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;)()())&amp;quot; ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest valid parentheses substring is “()()”&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
</feed>
