<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-26T22:41:20.045Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Permutation in String</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ567/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ567/</id>
    <published>2019-04-26T22:32:32.000Z</published>
    <updated>2019-04-26T22:41:20.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-567-permutation-in-string"><a class="markdownIt-Anchor" href="#leetcode-q-567-permutation-in-string"></a> LeetCode Q 567 - Permutation in String</h1><p>Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.</p><p>Example 1:<br><code>Input: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot; ; Output: True</code><br>Explanation: s2 contains one permutation of s1 (“ba”).<br>Example 2:<br><code>Input:s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot; ; Output: False</code></p><p><strong>Note:</strong></p><ul><li>The input strings only contain lower case letters.</li><li>The length of both given strings is in range [1, 10,000].</li></ul><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><ol><li>Swap String <em><strong>s1</strong></em>, count the times each char appears.</li><li>Get the first <em><strong>s1.length()</strong></em> char of String <em><strong>s2</strong></em>, to check if the times of each char in <em><strong>s2</strong></em> mataches that in <em><strong>s1</strong></em>.<ul><li>If it matches, we return <strong>true</strong>.</li><li>If not, we apply <strong>slinding window</strong> algorithm to keep checking, increasing the last char and decreasing the first char.</li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.length() &gt; s2.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length(); i++) &#123;</span><br><span class="line">count[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (allZeros(count)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s1.length(); i &lt; s2.length(); i++) &#123;</span><br><span class="line">count[s2.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">count[s2.charAt(i - s1.length()) - <span class="string">'a'</span>]++;</span><br><span class="line"><span class="keyword">if</span> (allZeros(count)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allZeros</span><span class="params">(<span class="keyword">int</span>[] count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c: count)</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-567-permutation-in-string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-567-permutation-in-string&quot;&gt;&lt;/a&gt; LeetCode Q 567 - Permutation in String&lt;/h1&gt;
&lt;p&gt;Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string’s permutations is the substring of the second string.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; ; Output: True&lt;/code&gt;&lt;br&gt;
Explanation: s2 contains one permutation of s1 (“ba”).&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input:s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; ; Output: False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The input strings only contain lower case letters.&lt;/li&gt;
&lt;li&gt;The length of both given strings is in range [1, 10,000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Max Consecutive Ones III</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ1004/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ1004/</id>
    <published>2019-04-26T22:27:54.000Z</published>
    <updated>2019-04-26T22:33:32.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-1004-max-consecutive-ones-iii"><a class="markdownIt-Anchor" href="#leetcode-q-1004-max-consecutive-ones-iii"></a> LeetCode Q 1004 - Max Consecutive Ones III</h1><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.</p><p>Example 1:<br><code>Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 ; Output: 6</code><br>Explanation: [1,1,1,0,0,1,1,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.<br>Example 2:<br><code>Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 ; Output: 10</code><br>Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= A.length &lt;= 20000</li><li>0 &lt;= K &lt;= A.length</li><li>A[i] is 0 or 1</li></ul><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><p>This problem is similar to <a href="/2019/04/26/leetcodeQ424/" title="Longest Repeating Character Replacement">Longest Repeating Character Replacement</a>.</p><p>Without constraints, maximum consecutive Ones length is<br><code>length of array</code><br>With constraints, then it becomes<br><code>length of array - number of 1s in the array &lt;= k</code></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (A.length &lt;= K) <span class="keyword">return</span> A.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, maxCount = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (end &lt; A.length) &#123;</span><br><span class="line">count[A[end]]++;</span><br><span class="line"><span class="keyword">while</span> (end - start + <span class="number">1</span> - count[<span class="number">1</span>] &gt; K) &#123;</span><br><span class="line">count[A[start++]]--;</span><br><span class="line">&#125;</span><br><span class="line">maxCount = Math.max(maxCount, end - start + <span class="number">1</span>);</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-1004-max-consecutive-ones-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-1004-max-consecutive-ones-iii&quot;&gt;&lt;/a&gt; LeetCode Q 1004 - Max Consecutive Ones III&lt;/h1&gt;
&lt;p&gt;Given an array A of 0s and 1s, we may change up to K values from 0 to 1. Return the length of the longest (contiguous) subarray that contains only 1s.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: [1,1,1,0,0,1,1,1,1,1,1]&lt;br&gt;
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3 ; Output: 10&lt;/code&gt;&lt;br&gt;
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]&lt;br&gt;
Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 20000&lt;/li&gt;
&lt;li&gt;0 &amp;lt;= K &amp;lt;= A.length&lt;/li&gt;
&lt;li&gt;A[i] is 0 or 1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Repeating Character Replacement</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ424/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ424/</id>
    <published>2019-04-26T22:20:24.000Z</published>
    <updated>2019-04-26T22:29:55.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-424-longest-repeating-character-replacement"><a class="markdownIt-Anchor" href="#leetcode-q-424-longest-repeating-character-replacement"></a> LeetCode Q 424 - Longest Repeating Character Replacement</h1><p>Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.</p><p><strong>Note:</strong> Both the string’s length and k will not exceed 104.</p><p>Example 1:<br><code>Input: s = &quot;ABAB&quot;, k = 2 ; Output: 4</code><br>Explanation: Replace the two 'A’s with two 'B’s or vice versa.<br>Example 2:<br><code>Input: s = &quot;AABABBA&quot;, k = 1 ; Output: 4</code><br>Explanation: Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”. The substring “BBBB” has the longest repeating letters, which is 4.</p><a id="more"></a><h2 id="solution-sliding-window"><a class="markdownIt-Anchor" href="#solution-sliding-window"></a> Solution : Sliding Window</h2><p>The problem says that we can make at most k changes to the string (any character can be replaced with any other character).</p><ol><li><p>First, let’s say there were no constraints like the k. Given a string convert it to a string with all same characters with minimal changes. The <strong>answer</strong> to this is<br><code>length of the entire string - number of times of the maximum occurring character in the string</code>.</p></li><li><p>Given this, we can apply the at most k changes constraint and maintain a sliding window such that<br><code>length of substring - number of times of the maximum occurring character in the substring) &lt;= k</code></p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, maxCount = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">count[s.charAt(end) - <span class="string">'A'</span>]++;</span><br><span class="line">maxCount = Math.max(maxCount, count[s.charAt(end) - <span class="string">'A'</span>]);</span><br><span class="line"><span class="keyword">while</span> (end - start + <span class="number">1</span> - maxCount &gt; k) &#123;</span><br><span class="line">count[s.charAt(start++) - <span class="string">'A'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="comment">// update maxCount</span></span><br><span class="line"><span class="keyword">if</span> (count[i] &gt; maxCount) maxCount = count[i];</span><br><span class="line">&#125;</span><br><span class="line">res = Math.max(res, end - start + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-424-longest-repeating-character-replacement&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-424-longest-repeating-character-replacement&quot;&gt;&lt;/a&gt; LeetCode Q 424 - Longest Repeating Character Replacement&lt;/h1&gt;
&lt;p&gt;Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Both the string’s length and k will not exceed 104.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;ABAB&amp;quot;, k = 2 ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Replace the two &#39;A’s with two &#39;B’s or vice versa.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;AABABBA&amp;quot;, k = 1 ; Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: Replace the one ‘A’ in the middle with ‘B’ and form “AABBBBA”. The substring “BBBB” has the longest repeating letters, which is 4.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Partition to K Equal Sum Subsets</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ698/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ698/</id>
    <published>2019-04-26T22:11:37.000Z</published>
    <updated>2019-04-26T22:18:36.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-698-partition-to-k-equal-sum-subsets"><a class="markdownIt-Anchor" href="#leetcode-q-698-partition-to-k-equal-sum-subsets"></a> LeetCode Q 698 - Partition to K Equal Sum Subsets</h1><p>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.</p><p>Example 1:<br><code>Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 ; Output: True</code><br>Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= k &lt;= len(nums) &lt;= 16.</li><li>0 &lt; nums[i] &lt; 10000.</li></ul><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.length &lt; k || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">sum /= k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> backtrack(nums, k, sum, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> targetSum, <span class="keyword">int</span> currSum, <span class="keyword">int</span> index, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boundary cases</span></span><br><span class="line"><span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currSum == targetSum) </span><br><span class="line"><span class="keyword">return</span> backtrack(nums, k - <span class="number">1</span>, targetSum, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; targetSum)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// keep recursion:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">visited[i] = <span class="keyword">true</span>; <span class="comment">//choose</span></span><br><span class="line"><span class="keyword">if</span> (dfs(nums, k, targetSum, currSum + nums[i], i + <span class="number">1</span>, visited))   <span class="comment">// explore</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[i] = <span class="keyword">false</span>; <span class="comment">// unchoose</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-698-partition-to-k-equal-sum-subsets&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-698-partition-to-k-equal-sum-subsets&quot;&gt;&lt;/a&gt; LeetCode Q 698 - Partition to K Equal Sum Subsets&lt;/h1&gt;
&lt;p&gt;Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4 ; Output: True&lt;/code&gt;&lt;br&gt;
Explanation: It’s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= k &amp;lt;= len(nums) &amp;lt;= 16.&lt;/li&gt;
&lt;li&gt;0 &amp;lt; nums[i] &amp;lt; 10000.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Longest Turbulent Subarray</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ978/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ978/</id>
    <published>2019-04-26T22:00:24.000Z</published>
    <updated>2019-04-26T22:11:12.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-978-longest-turbulent-subarray"><a class="markdownIt-Anchor" href="#leetcode-q-978-longest-turbulent-subarray"></a> LeetCode Q 978 - Longest Turbulent Subarray</h1><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p><ul><li>For <code>i &lt;= k &lt; j, A[k] &gt; A[k+1]</code> when k is odd, and <code>A[k] &lt; A[k+1]</code> when k is even;</li><li>OR, for <code>i &lt;= k &lt; j, A[k] &gt; A[k+1]</code> when k is even, and <code>A[k] &lt; A[k+1]</code> when k is odd.<br>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.<br>Return the length of a maximum size turbulent subarray of A.</li></ul><p>Example 1:<br><code>Input: [9,4,2,10,7,8,8,1,9] ; Output: 5</code><br>Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])<br>Example 2:<br><code>Input: [4,8,12,16] ; Output: 2</code><br>Example 3:<br><code>Input: [100] ; Output: 1</code></p><p><strong>Note:</strong></p><ul><li><code>1 &lt;= A.length &lt;= 40000</code></li><li><code>0 &lt;= A[i] &lt;= 10^9</code></li></ul><p>Similar Question: <a href="/2019/04/24/leetcodeQ376/" title="Wiggle Subsequence">Wiggle Subsequence</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h2 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h2><ol><li><p><strong>States</strong><br><code>up[i]</code>: the maximum length until <em><strong>i</strong></em> if <em><strong>ith</strong></em> number is in peak.<br><code>down[i]</code>: the maximum length until <em><strong>i</strong></em> if <em><strong>ith</strong></em> number is in valley.</p></li><li><p><strong>State Transfer Function:</strong></p><ul><li><code>if (A[i] &gt; A[i - 1])</code> then <code>up[i] = down[i] + 1; down[i] = 1</code></li><li><code>if (A[i] &lt; A[i - 1])</code> then <code>dwon[i] = up[i] + 1; up[i] = 1</code></li><li><code>if (A[i] == A[i - 1])</code> then <code>up[i] = down[i] = 1</code></li></ul></li><li><p><strong>Optimization:</strong> Since the <em><strong>ith</strong></em> state only depends on the <em><strong>(i-1)th</strong></em> state, therefore we can just use two variables <em><strong>up</strong></em> and <em><strong>down</strong></em>.</p></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; A[i - <span class="number">1</span>]) &#123;</span><br><span class="line">up = down + <span class="number">1</span>;</span><br><span class="line">down = <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, up);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>])&#123;</span><br><span class="line">down = up + <span class="number">1</span>;</span><br><span class="line">up = <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, down);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">up = down = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="solution-2-sliding-window-todo"><a class="markdownIt-Anchor" href="#solution-2-sliding-window-todo"></a> Solution 2: Sliding Window (TODO)</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-978-longest-turbulent-subarray&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-978-longest-turbulent-subarray&quot;&gt;&lt;/a&gt; LeetCode Q 978 - Longest Turbulent Subarray&lt;/h1&gt;
&lt;p&gt;A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1]&lt;/code&gt; when k is odd, and &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt; when k is even;&lt;/li&gt;
&lt;li&gt;OR, for &lt;code&gt;i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1]&lt;/code&gt; when k is even, and &lt;code&gt;A[k] &amp;lt; A[k+1]&lt;/code&gt; when k is odd.&lt;br&gt;
That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.&lt;br&gt;
Return the length of a maximum size turbulent subarray of A.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [9,4,2,10,7,8,8,1,9] ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: (A[1] &amp;gt; A[2] &amp;lt; A[3] &amp;gt; A[4] &amp;lt; A[5])&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [4,8,12,16] ; Output: 2&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [100] ; Output: 1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= A.length &amp;lt;= 40000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= A[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/24/leetcodeQ376/&quot; title=&quot;Wiggle Subsequence&quot;&gt;Wiggle Subsequence&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>Longest Increasing Path in a Matrix</title>
    <link href="http://yoursite.com/2019/04/26/leetcodeQ329/"/>
    <id>http://yoursite.com/2019/04/26/leetcodeQ329/</id>
    <published>2019-04-26T21:43:58.000Z</published>
    <updated>2019-04-26T22:19:47.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-329-longest-increasing-path-in-a-matrix"><a class="markdownIt-Anchor" href="#leetcode-q-329-longest-increasing-path-in-a-matrix"></a> LeetCode Q 329 - Longest Increasing Path in a Matrix</h1><p>Given an integer matrix, find the length of the longest increasing path.<br>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p><p>Example 1:<br><code>Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4</code><br>Explanation: The longest increasing path is [1, 2, 6, 9].<br>Example 2:<br><code>Input: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4</code><br>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p><strong>DFS + Memorization</strong><br><code>memo[i][j]</code>: the maximum length of increasing numbers until point [i][j]</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">booelan visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"><span class="keyword">int</span>[] directions = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">res = Math.max(res, dfs(matrix, i, j, memo, visited))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span>[][] memo, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span>[] dirictions)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[row][col]) <span class="keyword">return</span> memo[row][col];</span><br><span class="line"><span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">nx = row + directions[i];</span><br><span class="line">ny = col + directions[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; matrix[nx][ny] &gt; matrix[x][y])</span><br><span class="line">res = Math.max(res, <span class="number">1</span> + dfs(matrix, nx, ny, memo, visited, directions));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">memo[x][y] = res;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-329-longest-increasing-path-in-a-matrix&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-329-longest-increasing-path-in-a-matrix&quot;&gt;&lt;/a&gt; LeetCode Q 329 - Longest Increasing Path in a Matrix&lt;/h1&gt;
&lt;p&gt;Given an integer matrix, find the length of the longest increasing path.&lt;br&gt;
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest increasing path is [1, 2, 6, 9].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [ [3,4,5], [3,2,6], [2,2,1] ] Output: 4&lt;/code&gt;&lt;br&gt;
Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Memorization" scheme="http://yoursite.com/tags/Memorization/"/>
    
  </entry>
  
  <entry>
    <title>Maximal Square</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ221/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ221/</id>
    <published>2019-04-25T23:14:44.000Z</published>
    <updated>2019-04-25T23:28:07.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-221-maximal-square"><a class="markdownIt-Anchor" href="#leetcode-q-221-maximal-square"></a> LeetCode Q 221 -  Maximal Square</h1><p>Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.</p><p>Example:<br>Input:<br>1 0 1 0 0<br>1 0 1 1 1<br>1 1 1 1 1<br>1 0 0 1 0<br>Output: 4</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong> <code>dp(i,j)</code> represents the side length of the maximum square whose bottom right corner is the cell with index <code>(i,j)</code> in the original matrix.</p></li><li><p><strong>state transfer fuction:</strong><br>Starting from index (0,0), for every <em><strong>1</strong></em> found in the original matrix, we update the value of the current element as<br><code>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1)) + 1</code>.</p></li></ol><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.min(Math.min(dp[i][j], dp[i+<span class="number">1</span>][j]), dp[i][j+<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">maxLen = Math.max(maxLen, dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen * maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-221-maximal-square&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-221-maximal-square&quot;&gt;&lt;/a&gt; LeetCode Q 221 -  Maximal Square&lt;/h1&gt;
&lt;p&gt;Given a 2D binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Input:&lt;br&gt;
1 0 1 0 0&lt;br&gt;
1 0 1 1 1&lt;br&gt;
1 1 1 1 1&lt;br&gt;
1 0 0 1 0&lt;br&gt;
Output: 4&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Minimum ASCII Delete Sum for Two Strings</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ712/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ712/</id>
    <published>2019-04-25T22:58:26.000Z</published>
    <updated>2019-04-25T23:14:29.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-712-minimum-ascii-delete-sum-for-two-strings"><a class="markdownIt-Anchor" href="#leetcode-q-712-minimum-ascii-delete-sum-for-two-strings"></a> LeetCode Q 712 -  Minimum ASCII Delete Sum for Two Strings</h1><p>Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.</p><p>Example 1:<br><code>Input: s1 = &quot;sea&quot;, s2 = &quot;eat&quot; ; Output: 231</code><br>Explanation: Deleting “s” from “sea” adds the ASCII value of “s” (115) to the sum. Deleting “t” from “eat” adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.<br>Example 2:<br><code>Input: s1 = &quot;delete&quot;, s2 = &quot;leet&quot; ; Output: 403</code><br>Explanation: Deleting “dee” from “delete” to turn the string into “let”, adds 100[d]+101[e]+101[e] to the sum.  Deleting “e” from “leet” adds 101[e] to the sum. At the end, both strings are equal to “let”, and the answer is 100+101+101+101 = 403. If instead we turned both strings into “lee” or “eet”, we would get answers of 433 or 417, which are higher.</p><p><strong>Note:</strong></p><ul><li>0 &lt; s1.length, s2.length &lt;= 1000.</li><li>All elements of each string will have an ASCII value in [97, 122].</li></ul><p>Similar Question: <a href="/2019/04/25/leetcodeQ712/" title="Minimum ASCII Delete Sum for Two Strings">Minimum ASCII Delete Sum for Two Strings</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><p>Different with <a href="/2019/04/25/leetcodeQ712/" title="Minimum ASCII Delete Sum for Two Strings">Minimum ASCII Delete Sum for Two Strings</a>, to solve this question we find the <strong>maximum ASCII for common substrings</strong>, and <strong>delete it from the sum of ASCII value of two strings.</strong></p><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; i++) </span><br><span class="line">sum += (<span class="keyword">int</span>)s1.charAt(i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; j++) </span><br><span class="line">sum += (<span class="keyword">int</span>)s2.charAt(j - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j))</span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j] + (<span class="keyword">int</span>)s1.charAt(i), Math.max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sum - <span class="number">2</span> * dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-712-minimum-ascii-delete-sum-for-two-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-712-minimum-ascii-delete-sum-for-two-strings&quot;&gt;&lt;/a&gt; LeetCode Q 712 -  Minimum ASCII Delete Sum for Two Strings&lt;/h1&gt;
&lt;p&gt;Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;sea&amp;quot;, s2 = &amp;quot;eat&amp;quot; ; Output: 231&lt;/code&gt;&lt;br&gt;
Explanation: Deleting “s” from “sea” adds the ASCII value of “s” (115) to the sum. Deleting “t” from “eat” adds 116 to the sum. At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s1 = &amp;quot;delete&amp;quot;, s2 = &amp;quot;leet&amp;quot; ; Output: 403&lt;/code&gt;&lt;br&gt;
Explanation: Deleting “dee” from “delete” to turn the string into “let”, adds 100[d]+101[e]+101[e] to the sum.  Deleting “e” from “leet” adds 101[e] to the sum. At the end, both strings are equal to “let”, and the answer is 100+101+101+101 = 403. If instead we turned both strings into “lee” or “eet”, we would get answers of 433 or 417, which are higher.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 &amp;lt; s1.length, s2.length &amp;lt;= 1000.&lt;/li&gt;
&lt;li&gt;All elements of each string will have an ASCII value in [97, 122].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/25/leetcodeQ712/&quot; title=&quot;Minimum ASCII Delete Sum for Two Strings&quot;&gt;Minimum ASCII Delete Sum for Two Strings&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Delete Operation for Two Strings</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ583/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ583/</id>
    <published>2019-04-25T22:46:55.000Z</published>
    <updated>2019-04-25T22:57:42.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-583-delete-operation-for-two-strings"><a class="markdownIt-Anchor" href="#leetcode-q-583-delete-operation-for-two-strings"></a> LeetCode Q 583 -  Delete Operation for Two Strings</h1><p>Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.</p><p>Example 1: <code>Input: &quot;sea&quot;, &quot;eat&quot; ; Output: 2</code><br>Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.<br><strong>Note:</strong></p><ul><li>The length of given words won’t exceed 500.</li><li>Characters in given words can only be lower-case letters.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><strong>State:</strong> <code>dp[i][j]</code> denotes the minimum number of steps to make <code>word1.substring(0, i+1)</code> and <code>word2.substring(0, j+1)</code> the same;</li><li><strong>state transfer function:</strong><ul><li><code>if (word1.charAt(i) == word2.charAt(j))</code>, we don’t need to do anying therefore<br><code>dp[i][j] = dp[i-1][j-1]</code></li><li>else <code>dp[i][j] = Math.min(dp[i][j-1], dp[i-1][j]) + 1</code>, that is we can either delete char <em><strong>i</strong></em> from <strong>word1</strong> or char <em><strong>j</strong></em> from <strong>word2</strong>.</li></ul></li><li><strong>boundary case:</strong><br><code>dp[0][j] = j, j = 0, 1, 2,... dp[i][0] = i, i = 0, 1, 2,...</code><br>Previously, I only set dp[0][1] = dp[1][0] = 1, so I made mistake!</li></ol><p><strong>Time Complexity: O(n * m)</strong><br><strong>Space Complexity: O(n * m)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word1.length() == <span class="number">0</span>) <span class="keyword">return</span> word2.length();</span><br><span class="line"><span class="keyword">if</span> (word2.length() == <span class="number">0</span>) <span class="keyword">return</span> word1.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= word1.length(); i++) </span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word2.length(); j++) </span><br><span class="line">dp[<span class="number">0</span>][j] = j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.length(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (word1.charAt(i) == word2.charAt(j)) </span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = Math.min(dp[i + <span class="number">1</span>][j], dp[i][j + <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-583-delete-operation-for-two-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-583-delete-operation-for-two-strings&quot;&gt;&lt;/a&gt; LeetCode Q 583 -  Delete Operation for Two Strings&lt;/h1&gt;
&lt;p&gt;Given two words word1 and word2, find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string.&lt;/p&gt;
&lt;p&gt;Example 1: &lt;code&gt;Input: &amp;quot;sea&amp;quot;, &amp;quot;eat&amp;quot; ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: You need one step to make “sea” to “ea” and another step to make “eat” to “ea”.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of given words won’t exceed 500.&lt;/li&gt;
&lt;li&gt;Characters in given words can only be lower-case letters.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Number of Longest Increasing Subsequence</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ673/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ673/</id>
    <published>2019-04-25T22:23:11.000Z</published>
    <updated>2019-04-25T22:48:08.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-673-number-of-longest-increasing-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-673-number-of-longest-increasing-subsequence"></a> LeetCode Q 673 -  Number of Longest Increasing Subsequence</h1><p>Given an unsorted array of integers, find the number of longest increasing subsequence.</p><p>Example 1:<br><code>Input: [1,3,5,4,7] ; Output: 2</code><br>Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].<br>Example 2:<br><code>Input: [2,2,2,2,2] ; Output: 5</code><br>Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences’ length is 1, so output 5.<br><strong>Note:</strong> Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.</p><p>Similar Question: <a href="/2019/04/15/leetcodeQ300/" title="Longest Increasing Subsequence">Longest Increasing Subsequence</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong></p><ul><li><code>len[i]</code>, record the longest increasing subsequence till <em><strong>ith</strong></em> num in <strong>nums</strong>. The length of <strong>len</strong> should be the <em><strong>nums.length</strong></em>.</li><li><code>count[i]</code>, the number of the string whose length is i. The length of <strong>len</strong> should be the <em><strong>nums.length</strong></em>.</li></ul></li><li><p><strong>state transfer fuction:</strong><br><code>len[i] = Math.max(len[j] + 1, len[i])</code>, where j = 1,…,i-1 and nums[i] &gt; nums[j].<br><strong>Note then when building array len, we should also update the array count.</strong></p><ul><li><code>if (len[i] &lt; len[j] + 1)</code> then <code>count[i] = count[j];</code></li><li><code>if (len[i] == len[j] + 1)</code> then <code>count[i] += count[j];</code></li></ul></li><li><p><strong>boundary cases:</strong> <code>dp[i] = count[i] = 1</code></p></li></ol><p><strong>Time Complexity: O(n^2)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] len = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>, maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">len[i] = count[i] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// update len[i] and count[i] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i ; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line"><span class="keyword">if</span> (len[i] == len[j] + <span class="number">1</span>) &#123;</span><br><span class="line">count[i] += count[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (len[i] &lt; len[j] + <span class="number">1</span>) &#123;</span><br><span class="line">len[i] = len[j] + <span class="number">1</span>;</span><br><span class="line">count[i] = count[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// update maxLen</span></span><br><span class="line"><span class="keyword">if</span> (maxLen == len[i]) &#123;</span><br><span class="line">res += count[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (maxLen &lt; len[i]) &#123;</span><br><span class="line">maxLen = len[i];</span><br><span class="line">res = count[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-673-number-of-longest-increasing-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-673-number-of-longest-increasing-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 673 -  Number of Longest Increasing Subsequence&lt;/h1&gt;
&lt;p&gt;Given an unsorted array of integers, find the number of longest increasing subsequence.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1,3,5,4,7] ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [2,2,2,2,2] ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences’ length is 1, so output 5.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.&lt;/p&gt;
&lt;p&gt;Similar Question: &lt;a href=&quot;/2019/04/15/leetcodeQ300/&quot; title=&quot;Longest Increasing Subsequence&quot;&gt;Longest Increasing Subsequence&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Word Break II</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ140/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ140/</id>
    <published>2019-04-25T22:08:57.000Z</published>
    <updated>2019-04-25T22:26:28.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-140-word-break-ii"><a class="markdownIt-Anchor" href="#leetcode-q-140-word-break-ii"></a> LeetCode Q 140 - Word Break II</h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:<br><code>Input: s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;] Output: [ &quot;cats and dog&quot;, &quot;cat sand dog&quot; ]</code><br>Example 2:<br><code>Input: s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;] Output: [ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot; ]</code><br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:<br><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] Output: []</code></p><a id="more"></a><h2 id="solution-backtracking-with-memorization"><a class="markdownIt-Anchor" href="#solution-backtracking-with-memorization"></a> Solution : Backtracking with memorization</h2><p><strong><font color="#ff0066">Using DFS directly will lead to TLE, so just use HashMap to save the previous results to prune duplicated branches.</font></strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, ArrayList&lt;String&gt;&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">memo = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;String&gt;&gt;();</span><br><span class="line"><span class="keyword">return</span> wordBreakHelper(s, wordDict);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Strig&gt; <span class="title">wordBreakHelper</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (memo.containsKey(s)) <span class="keyword">return</span> memo.get(s);</span><br><span class="line"></span><br><span class="line">List&lt;Strig&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"><span class="keyword">if</span> (wordDict.contains(s)) res.add(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; s.length; i++) &#123;</span><br><span class="line">String word = s.substring(<span class="number">0</span>, len);</span><br><span class="line"><span class="keyword">if</span> (!wordDict.contains(word)) <span class="keyword">continue</span>;</span><br><span class="line">List&lt;String&gt; strs = wordBreak(s.substring(len), wordDict);</span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line">res.add(word + <span class="string">" "</span> + str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">memo.put(s, res);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-140-word-break-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-140-word-break-ii&quot;&gt;&lt;/a&gt; LeetCode Q 140 - Word Break II&lt;/h1&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The same word in the dictionary may be reused multiple times in the segmentation.&lt;/li&gt;
&lt;li&gt;You may assume the dictionary does not contain duplicate words.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsanddog&amp;quot;, wordDict = [&amp;quot;cat&amp;quot;, &amp;quot;cats&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;dog&amp;quot;] Output: [ &amp;quot;cats and dog&amp;quot;, &amp;quot;cat sand dog&amp;quot; ]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;pineapplepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;, &amp;quot;applepen&amp;quot;, &amp;quot;pine&amp;quot;, &amp;quot;pineapple&amp;quot;] Output: [ &amp;quot;pine apple pen apple&amp;quot;, &amp;quot;pineapple pen apple&amp;quot;, &amp;quot;pine applepen apple&amp;quot; ]&lt;/code&gt;&lt;br&gt;
Explanation: Note that you are allowed to reuse a dictionary word.&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;] Output: []&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Memorization" scheme="http://yoursite.com/tags/Memorization/"/>
    
  </entry>
  
  <entry>
    <title>Word Break</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ139/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ139/</id>
    <published>2019-04-25T21:49:53.000Z</published>
    <updated>2019-04-25T22:25:46.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-139-word-break"><a class="markdownIt-Anchor" href="#leetcode-q-139-word-break"></a> LeetCode Q 139 - Word Break</h1><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note:</strong></p><ul><li>The same word in the dictionary may be reused multiple times in the segmentation.</li><li>You may assume the dictionary does not contain duplicate words.</li></ul><p>Example 1:<br><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;] ; Output: true</code><br>Explanation: Return true because “leetcode” can be segmented as “leet code”.<br>Example 2:<br><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]; Output: true</code><br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”. <strong>Note that you are allowed to reuse a dictionary word.</strong><br>Example 3:<br><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;] ; Output: false</code></p><a id="more"></a><h2 id="solution-dp-bottom-up"><a class="markdownIt-Anchor" href="#solution-dp-bottom-up"></a> Solution : DP bottom-up</h2><ol><li><p><strong>State:</strong> <code>boolean dp[i]</code> represents if <code>s.substring(0, i+1)</code> is valid.</p></li><li><p><strong>state transfer fuction:</strong><br>For String  <code>s.substring(0, i+1)</code>, we divide it into two parts, one is <code>s.substring(0, j)</code> and another is <code>s.substring(j, i+1)</code> if they are all valid then <code>s.substring(0, i+1)</code> is valid.<br>Therefore,<br><code>dp[i] = dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+1));</code></p></li></ol><p><strong>Caution:</strong> when we find one valid partition of <code>s.substring(0, i+1)</code>, we need to <strong>break</strong> the <em><strong>for</strong></em> loop.</p><ol start="3"><li><strong>boundary cases:</strong> <code>dp[0] = true</code>.</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (wordDict == <span class="keyword">null</span> || wordDict.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>))) &#123;</span><br><span class="line">dp[i + <span class="number">1</span>] = <span class="keyword">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[s.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-139-word-break&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-139-word-break&quot;&gt;&lt;/a&gt; LeetCode Q 139 - Word Break&lt;/h1&gt;
&lt;p&gt;Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The same word in the dictionary may be reused multiple times in the segmentation.&lt;/li&gt;
&lt;li&gt;You may assume the dictionary does not contain duplicate words.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: Return true because “leetcode” can be segmented as “leet code”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;applepenapple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;]; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”. &lt;strong&gt;Note that you are allowed to reuse a dictionary word.&lt;/strong&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;] ; Output: false&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Swaps To Make Sequences Increasing</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ801/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ801/</id>
    <published>2019-04-25T21:07:17.000Z</published>
    <updated>2019-04-25T22:30:20.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-801-minimum-swaps-to-make-sequences-increasing"><a class="markdownIt-Anchor" href="#leetcode-q-801-minimum-swaps-to-make-sequences-increasing"></a> LeetCode Q 801 -  Minimum Swaps To Make Sequences Increasing</h1><p>We have two integer sequences A and B of the same non-zero length.<br>We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.<br>At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] &lt; A[1] &lt; A[2] &lt; … &lt; A[A.length - 1].)<br>Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.</p><p>Example:<br><code>Input: A = [1,3,5,4], B = [1,2,3,7] ; Output: 1</code><br>Explanation: Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.</p><p><strong>Note:</strong></p><ul><li>A, B are arrays with the same length, and that length will be in the range [1, 1000].</li><li>A[i], B[i] are integer values in the range [0, 2000].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><ol><li><p><strong>State:</strong> <code>dp[i][j]</code> denotes the minimum steps we need to make <code>A.substring(i - 1)</code> is the same as <code>B.substring(i - 1)</code> and j represents the operation type. To let those two strings equal, we have two choices, one is swap <em><strong>ith</strong></em> char in <em><strong>A</strong></em> and <em><strong>B</strong></em>, or do nothing.</p><ul><li><code>dp[i][0]</code>: we don’t swap <em><strong>ith</strong></em> char in <em><strong>A</strong></em> and <em><strong>B</strong></em>.</li><li><code>dp[i][1]</code>: we swap them.</li></ul></li><li><p><strong>state transfer fuction:</strong><br>Since this question is guaranteed to have the answer, therefore at least one of the following two conditions exists:</p><ol><li>A[i] &gt; A[i - 1] &amp;&amp; B[i] &gt; B[i - 1]</li><li>A[i] &gt; B[i - 1] &amp;&amp; B[i] &gt; A[i - 1]</li></ol></li></ol><ul><li>if <strong>condition 1</strong> exists,<ul><li>if we don’t need to swap chars, then<br><code>dp[i][0] = min(dp[i-1][0], dp[i][0])</code></li><li>if we still swap chars, we also need to swap <em><strong>(i-1)th</strong></em> char in A and B, then<br><code>dp[i][1] = min(dp[i-1][1] + 1, dp[i][1])</code></li></ul></li><li>if <strong>condition 2</strong> exists,<ul><li>if we don’t need to swap chars, then we need to swap <em><strong>(i-1)th</strong></em> char in A and B, which means we can only get to <code>dp[i][0]</code> from <code>dp[i-1][1]</code>, therefore<br><code>dp[i][0] = min(dp[i-1][1], dp[i][0]))</code></li><li>if we still swap chars, we don’t need to swap <em><strong>(i-1)th</strong></em> char in A and B, then<br><code>dp[i][1] = min(dp[i-1][0] + 1, dp[i][1])</code></li></ul></li></ul><ol start="3"><li><p><strong>boundary cases:</strong><br><code>dp[0][0] = 0, dp[0][1] = 1</code>, other numbers in <em><strong>dp</strong></em> are all initialized as <strong>INF</strong>.</p></li><li><p><strong>Optimization:</strong><br>Since <code>dp[i]</code> is only depends on <code>dp[i-1]</code>, we can use sliding array to optimize space complexity to O(1).</p></li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(2n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSwap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span> || B == <span class="keyword">null</span> || B.length != A.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = A.length;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; A[i-<span class="number">1</span>] &amp;&amp; B[i] &gt; B[i-<span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>, dp[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[i] &gt; B[i-<span class="number">1</span>] &amp;&amp; B[i] &gt; A[i-<span class="number">1</span>]) &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i][<span class="number">0</span>]);</span><br><span class="line">dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>, dp[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.min(dp[len-<span class="number">1</span>][<span class="number">0</span>], dp[len-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-801-minimum-swaps-to-make-sequences-increasing&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-801-minimum-swaps-to-make-sequences-increasing&quot;&gt;&lt;/a&gt; LeetCode Q 801 -  Minimum Swaps To Make Sequences Increasing&lt;/h1&gt;
&lt;p&gt;We have two integer sequences A and B of the same non-zero length.&lt;br&gt;
We are allowed to swap elements A[i] and B[i].  Note that both elements are in the same index position in their respective sequences.&lt;br&gt;
At the end of some number of swaps, A and B are both strictly increasing.  (A sequence is strictly increasing if and only if A[0] &amp;lt; A[1] &amp;lt; A[2] &amp;lt; … &amp;lt; A[A.length - 1].)&lt;br&gt;
Given A and B, return the minimum number of swaps to make both sequences strictly increasing.  It is guaranteed that the given input always makes it possible.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: A = [1,3,5,4], B = [1,2,3,7] ; Output: 1&lt;/code&gt;&lt;br&gt;
Explanation: Swap A[3] and B[3].  Then the sequences are: A = [1, 3, 5, 7] and B = [1, 2, 3, 4] which are both strictly increasing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A, B are arrays with the same length, and that length will be in the range [1, 1000].&lt;/li&gt;
&lt;li&gt;A[i], B[i] are integer values in the range [0, 2000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Domino and Tromino Tiling</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ790/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ790/</id>
    <published>2019-04-25T20:46:51.000Z</published>
    <updated>2019-04-25T22:25:29.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-790-domino-and-tromino-tiling"><a class="markdownIt-Anchor" href="#leetcode-q-790-domino-and-tromino-tiling"></a> LeetCode Q 790 -  Domino and Tromino Tiling</h1><p>We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.<br><code>XX &lt;- domino XX &lt;- &quot;L&quot; tromino X</code><br>Given N, how many ways are there to tile a 2 x N board? <strong>Return your answer modulo 10^9 + 7.</strong></p><p>(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)</p><p>Example:<br><code>Input: 3 ; Output: 5</code><br>Explanation:<br>The five different ways are listed below, different letters indicates different tiles:<br><code>XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY</code><br><strong>Note:</strong> N  will be in range [1, 1000].</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><ol><li><p><strong>State:</strong> <code>f[i][j]</code>, i: until which col the floor is all covered; j: the tail states.</p><ul><li><code>f[i][0]</code>: there is no redundant tail at ith col. (1st row: i, 2nd row: i)</li><li><code>f[i][1]</code>: there is one more tail at 1st row. (1st row: i + 1, 2nd row: i)</li><li><code>f[i][2]</code>: there is one more tail at 1st row. (1st row: i, 2nd row: i + 1)</li></ul></li><li><p><strong>state transfer fuction:</strong></p><ul><li><code>f[i][0] = f[i-1][0] + f[i - 2][0] + f[i-2][1] + f[i-2][2];</code><br>Put one type I vertically, or put two I types horizontally, or put L type (two directions)</li><li><code>f[i][1] = f[i-1][0] + f[i-1][2];</code><br>Put a type I across the top row, or put an L-shape</li><li><code>f[i][2] = f[i-1][0] + f[i-1][1];</code><br>Place a type I across the next line, or put an L type</li></ul></li><li><p><strong>boundary cases:</strong><br><code>f[0][0] = f[1][0] = f[1][1] = f[1][2] = 1</code></p></li></ol><p><strong>Caution:</strong> use <em><strong>long</strong></em> to avoid <strong>integer overflow</strong></p><ol start="4"><li><strong>Optimization:</strong><br>Since <code>f[i]</code> is only depends on <code>f[i-1]</code> and <code>f[i-2]</code>, we can use sliding array to optimize space complexity to O(1).</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(3n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MOD = <span class="number">1000000007</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">2</span>) <span class="keyword">return</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[][] f = <span class="keyword">new</span> <span class="keyword">long</span>[N+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">1</span>] = f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">f[i][<span class="number">0</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">2</span>][<span class="number">0</span>] + f[i-<span class="number">2</span>][<span class="number">1</span>] + f[i-<span class="number">2</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">f[i][<span class="number">1</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">1</span>][<span class="number">2</span>]) % MOD;</span><br><span class="line">f[i][<span class="number">2</span>] = (f[i-<span class="number">1</span>][<span class="number">0</span>] + f[i-<span class="number">1</span>][<span class="number">1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)f[N][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-790-domino-and-tromino-tiling&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-790-domino-and-tromino-tiling&quot;&gt;&lt;/a&gt; LeetCode Q 790 -  Domino and Tromino Tiling&lt;/h1&gt;
&lt;p&gt;We have two types of tiles: a 2x1 domino shape, and an “L” tromino shape. These shapes may be rotated.&lt;br&gt;
&lt;code&gt;XX &amp;lt;- domino XX &amp;lt;- &amp;quot;L&amp;quot; tromino X&lt;/code&gt;&lt;br&gt;
Given N, how many ways are there to tile a 2 x N board? &lt;strong&gt;Return your answer modulo 10^9 + 7.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.)&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 3 ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
The five different ways are listed below, different letters indicates different tiles:&lt;br&gt;
&lt;code&gt;XYZ XXZ XYY XXY XYY XYZ YYZ XZZ XYY XXY&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; N  will be in range [1, 1000].&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Delete and Earn</title>
    <link href="http://yoursite.com/2019/04/25/leetcodeQ740/"/>
    <id>http://yoursite.com/2019/04/25/leetcodeQ740/</id>
    <published>2019-04-25T19:15:34.000Z</published>
    <updated>2019-04-25T22:26:58.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-740-delete-and-earn"><a class="markdownIt-Anchor" href="#leetcode-q-740-delete-and-earn"></a> LeetCode Q 740 -  Delete and Earn</h1><p>Given an array nums of integers, you can perform operations on the array.<br>In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.<br>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><p>Example 1:<br><code>Input: nums = [3, 4, 2] ; Output: 6</code><br>Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.</p><p>Example 2:<br><code>Input: nums = [2, 2, 3, 3, 3, 4] ; Output: 9</code><br>Explanation: Delete 3 to earn 3 points, deleting both 2’s and the 4.<br>Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.<br>9 total points are earned.</p><p><strong>Note:</strong></p><ul><li>The length of nums is at most 20000.</li><li>Each element nums[i] is an integer in the range [1, 10000].</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><p>First, We use an array <code>int[] count</code> store the times of each element appeared in <em><strong>nums</strong></em>. Since <em><strong>nums[i]</strong></em> is in the range [1, 10000]. We can initialize <code>int[] count = new int[10001]</code>.</p><p>Then, traverse <em><strong>nums</strong></em> and build <em><strong>count</strong></em>.</p><p>Next, use DP algorithm to find the answer.</p><ol><li><strong>State:</strong> <code>dp[i]</code>, the best score we can get till <em><strong>i</strong></em>.</li><li><strong>State Transfer Function:</strong><br><code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + i * counter[i]);</code><br>We have two options:</li></ol><ul><li>We pick <em><strong>i</strong></em>. Since we must <strong>delete</strong> <em><strong>i-1</strong></em> and <em><strong>i+1</strong></em>, that is we can only reach <em><strong>i</strong></em> from <em><strong>i-2</strong></em>.</li><li>We don’t pick <em><strong>i</strong></em>. We pick <em><strong>i - 1</strong></em>.</li></ul><p>We choose one from these two options, which has higher value.</p><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) count[num]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10001</span>];</span><br><span class="line">dp[<span class="number">1</span>] = count[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">10001</span>; i++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + i * counter[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">10000</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-740-delete-and-earn&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-740-delete-and-earn&quot;&gt;&lt;/a&gt; LeetCode Q 740 -  Delete and Earn&lt;/h1&gt;
&lt;p&gt;Given an array nums of integers, you can perform operations on the array.&lt;br&gt;
In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.&lt;br&gt;
You start with 0 points. Return the maximum number of points you can earn by applying such operations.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [3, 4, 2] ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: Delete 4 to earn 4 points, consequently 3 is also deleted. Then, delete 2 to earn 2 points. 6 total points are earned.&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [2, 2, 3, 3, 3, 4] ; Output: 9&lt;/code&gt;&lt;br&gt;
Explanation: Delete 3 to earn 3 points, deleting both 2’s and the 4.&lt;br&gt;
Then, delete 3 again to earn 3 points, and 3 again to earn 3 points.&lt;br&gt;
9 total points are earned.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of nums is at most 20000.&lt;/li&gt;
&lt;li&gt;Each element nums[i] is an integer in the range [1, 10000].&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum IV</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ377/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ377/</id>
    <published>2019-04-24T22:58:09.000Z</published>
    <updated>2019-04-26T21:59:59.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-377-combination-sum-iv"><a class="markdownIt-Anchor" href="#leetcode-q-377-combination-sum-iv"></a> LeetCode Q 377 - Combination Sum IV</h1><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p><p>Example:<br><code>nums = [1, 2, 3] ; target = 4</code><br>The possible combination ways are:<br>(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)<br><strong>Note</strong> that different sequences are counted as different combinations.<br>Therefore the output is 7.</p><p><strong>Follow up:</strong></p><ul><li>What if negative numbers are allowed in the given array?</li><li>How does it change the problem?</li><li>What limitation we need to add to the question to allow negative numbers?</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dp"><a class="markdownIt-Anchor" href="#solution-1-dp"></a> Solution 1: DP</h3><p><strong>State Transfer Function:</strong><br><code>dp[i] += dp[i - num], where num belongs to nums.</code></p><p><strong>Time Complexity: O(n * t)</strong><br><strong>Space Complexity: O(t)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= num) dp[i] += dp[i - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-recursion-hashmap"><a class="markdownIt-Anchor" href="#solution-2-recursion-hashmap"></a> Solution 2: Recursion + HashMap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || target &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> ( target == <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(target)) <span class="keyword">return</span> map.get(target);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums)</span><br><span class="line">    count += combinationSum4(nums, target - num);</span><br><span class="line">map.put(target, count);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="follow-up"><a class="markdownIt-Anchor" href="#follow-up"></a> Follow up:</h3><p><strong>In order to allow negative integers, the length of the combination sum needs to be restricted, or the search will not stop. We need to use memory to avoid repeated calculations.</strong></p><p>In order to solve this question, we use backtrack with memory. In <a href="/2019/04/25/leetcodeQ140/" title="Word Breaker II">Word Breaker II</a>, we also use backtrack + memory method.</p><p><strong>Code: Backtrack with memorizing</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum42</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length ==<span class="number">0</span> || MaxLen &lt;= <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">return</span> helper2(nums, <span class="number">0</span>, target, MaxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Map&lt;Integer,Integer&gt;&gt; map2 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len, <span class="keyword">int</span> target, <span class="keyword">int</span> MaxLen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (len &gt; MaxLen) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (map2.containsKey(target) &amp;&amp; map2.get(target).containsKey(len))</span><br><span class="line"><span class="keyword">return</span> map2.get(target).get(len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( target == <span class="number">0</span> )   count++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">count+= helper2(nums, len+<span class="number">1</span>, target-num, MaxLen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!map2.containsKey(target)) </span><br><span class="line">map2.put(target, <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;());</span><br><span class="line">Map&lt;Integer,Integer&gt; memo = map2.get(target);</span><br><span class="line"></span><br><span class="line">memo.put(len, count);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-377-combination-sum-iv&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-377-combination-sum-iv&quot;&gt;&lt;/a&gt; LeetCode Q 377 - Combination Sum IV&lt;/h1&gt;
&lt;p&gt;Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;nums = [1, 2, 3] ; target = 4&lt;/code&gt;&lt;br&gt;
The possible combination ways are:&lt;br&gt;
(1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt; that different sequences are counted as different combinations.&lt;br&gt;
Therefore the output is 7.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if negative numbers are allowed in the given array?&lt;/li&gt;
&lt;li&gt;How does it change the problem?&lt;/li&gt;
&lt;li&gt;What limitation we need to add to the question to allow negative numbers?&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="Memorization" scheme="http://yoursite.com/tags/Memorization/"/>
    
      <category term="Recurtion" scheme="http://yoursite.com/tags/Recurtion/"/>
    
  </entry>
  
  <entry>
    <title>Wiggle Subsequence</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ376/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ376/</id>
    <published>2019-04-24T22:38:24.000Z</published>
    <updated>2019-04-25T22:27:23.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-376-wiggle-subsequence"><a class="markdownIt-Anchor" href="#leetcode-q-376-wiggle-subsequence"></a> LeetCode Q 376 - Wiggle Subsequence</h1><p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.<br>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.<br>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><p>Example 1:<br><code>Input: [1,7,4,9,2,5] ; Output: 6</code><br>Explanation: The entire sequence is a wiggle sequence.<br>Example 2:<br><code>Input: [1,17,5,10,13,15,10,5,16,8] ; Output: 7</code><br>Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].<br>Example 3:<br><code>Input: [1,2,3,4,5,6,7,8,9] ; Output: 2</code></p><p><strong>Follow up:</strong> Can you do it in <strong>O(n)</strong> time?</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-traditional-dp"><a class="markdownIt-Anchor" href="#solution-1-traditional-dp"></a> Solution 1 : traditional DP</h3><p>We use two arrays to store the states.</p><ol><li><code>up[i]</code>: the <em><strong>ith</strong></em> number is the <strong>peak</strong>.</li><li><code>sell[i]</code>: the <em><strong>ith</strong></em> number is the <strong>vally</strong>.</li></ol><p>We update these two arrays depends on the following case:</p><ol><li><code>if (nums[i] &gt; nums[i - 1])</code>, which means the curr number is larger than its left, then we update <code>up[i] = Math.max(up[i - 1], down[i - 1] + 1)</code> and <code>down[i] keeps the same</code> (i.e. <code>down[i] = down[i - 1]</code>);</li><li><code>if (nums[i] &lt; nums[i - 1])</code>, which means the curr number is smaller than its left, then we update <code>down[i] = Math.max(down[i - 1], up[i - 1] + 1)</code> and <code>up[i] keeps the same</code> (i.e. <code>up[i] = up[i - 1]</code>);</li><li><code>if (nums[i] == nums[i - 1])</code>, we will neither update <code>up[i]</code> nor <code>sell[i]</code>, that is <code>up[i] = up[i - 1]</code> and <code>down[i] = down[i - 1]</code>.</li></ol><p><strong>Time Complexity: O(n)</strong><br><strong>Space Complexity: O(n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] up = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length]; <span class="keyword">int</span>[] down = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">up[<span class="number">0</span>] = <span class="number">1</span>; down[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">up[i] = Math.max(up[i - <span class="number">1</span>], down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">down[i] = Math.max(down[i - <span class="number">1</span>], up[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(up[nums.length - <span class="number">1</span>], down[nums.length - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp-optimized-space"><a class="markdownIt-Anchor" href="#solution-2-dp-optimized-space"></a> Solution 2 : DP Optimized Space</h3><p>Using <em><strong>up</strong></em> and <em><strong>down</strong></em> instead of <code>up[i]</code> and <code>down[i]</code>, optimizing the <strong>space complecity</strong> to be <strong>O(1)</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">up = Math.max(up, down + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>])</span><br><span class="line">down = Math.max(down, up + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Math.max(up, down);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-376-wiggle-subsequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-376-wiggle-subsequence&quot;&gt;&lt;/a&gt; LeetCode Q 376 - Wiggle Subsequence&lt;/h1&gt;
&lt;p&gt;A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.&lt;br&gt;
For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.&lt;br&gt;
Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1,7,4,9,2,5] ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: The entire sequence is a wiggle sequence.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1,17,5,10,13,15,10,5,16,8] ; Output: 7&lt;/code&gt;&lt;br&gt;
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: [1,2,3,4,5,6,7,8,9] ; Output: 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Can you do it in &lt;strong&gt;O(n)&lt;/strong&gt; time?&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Partition Equal Subset Sum</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ416/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ416/</id>
    <published>2019-04-24T22:19:44.000Z</published>
    <updated>2019-04-25T22:27:30.396Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-416-partition-equal-subset-sum"><a class="markdownIt-Anchor" href="#leetcode-q-416-partition-equal-subset-sum"></a> LeetCode Q 416 - Partition Equal Subset Sum</h1><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.<br><strong>Note:</strong></p><ul><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ul><p>Example 1:<br><code>Input: [1, 5, 11, 5] ; Output: true</code><br>Explanation: The array can be partitioned as [1, 5, 5] and [11].<br>Example 2:<br><code>Input: [1, 2, 3, 5] ; Output: false</code><br>Explanation: The array cannot be partitioned into equal sum subsets.</p><a id="more"></a><h2 id="solution-dp"><a class="markdownIt-Anchor" href="#solution-dp"></a> Solution : DP</h2><ol><li><p>We calculate the <strong>sum</strong> of the array, if the <strong>sum</strong> cannot divided by two, then directly returning <strong>false</strong>.</p></li><li><p>boolean array <code>dp[]</code> is used to store the sum values of the array. If <code>dp[sum / 2]</code> can be achieved, then we can return <strong>true</strong>.</p></li></ol><p><strong>State Transfer Function</strong><br><code>dp[i] = dp[i] || dp[i - nums[j]];</code> i: sum value;</p><p><strong>Time Complexity: O(kn)</strong><br><strong>Time Complexity: O(kn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"><span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = sum / <span class="number">2</span>; j &gt;= nums[i - <span class="number">1</span>]; j--)</span><br><span class="line">dp[j] = dp[j] || dp[j - nums[i - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[sum / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#ff0066">Wrong Code:</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum / <span class="number">2</span>; i++) &#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt;= num) dp[i] = dp[i] || dp[i - num];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Since each num can only be used once, this code is <font color="#ff0066">wrong!!!</font></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-416-partition-equal-subset-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-416-partition-equal-subset-sum&quot;&gt;&lt;/a&gt; LeetCode Q 416 - Partition Equal Subset Sum&lt;/h1&gt;
&lt;p&gt;Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each of the array element will not exceed 100.&lt;/li&gt;
&lt;li&gt;The array size will not exceed 200.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [1, 5, 11, 5] ; Output: true&lt;/code&gt;&lt;br&gt;
Explanation: The array can be partitioned as [1, 5, 5] and [11].&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [1, 2, 3, 5] ; Output: false&lt;/code&gt;&lt;br&gt;
Explanation: The array cannot be partitioned into equal sum subsets.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Target Sum</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ494/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ494/</id>
    <published>2019-04-24T22:03:16.000Z</published>
    <updated>2019-04-25T22:27:36.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-494-target-sum"><a class="markdownIt-Anchor" href="#leetcode-q-494-target-sum"></a> LeetCode Q 494 - Target Sum</h1><p>You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.<br>Find out how many ways to assign symbols to make sum of integers equal to target S.</p><p>Example 1:<br><code>Input: nums is [1, 1, 1, 1, 1], S is 3. ; Output: 5</code><br>Explanation:<br><code>-1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3</code><br>There are 5 ways to assign symbols to make the sum of nums be target 3.<br><strong>Note:</strong></p><ul><li>The length of the given array is positive and will not exceed 20.</li><li>The sum of elements in the given array will not exceed 1000.<br>Your output answer is guaranteed to be fitted in a 32-bit integer.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-1-dfs-backtracking"></a> Solution 1 : DFS / backtracking</h3><p><strong>Time Complexity: O(2^n)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">backtrack(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S, <span class="keyword">int</span> index, <span class="keyword">int</span> currSum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (currSum == S) res++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explore</span></span><br><span class="line">backtrack(nums, S, index + <span class="number">1</span>, currSum + nums[index]);</span><br><span class="line">backtrack(nums, S, index + <span class="number">1</span>, currSum - nums[index]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-dp"><a class="markdownIt-Anchor" href="#solution-2-dp"></a> Solution 2 : DP</h3><p><code>dp[i][j]</code> refers to the number of assignments which can lead to a sum of j upto the ith index.</p><p><strong>State Transfer Function</strong><br><code>dp[i][sum+nums[i]] = dp[i][sum+nums[i]]+dp[i-1][sum] dp[i][sum-nums[i]] = dp[i][sum-nums[i]]+dp[i-1][sum]</code></p><p><strong>Note:</strong> we add an offset sum to the second index to avoid negative index value.</p><p><strong>Time Complexity: O(kn)</strong><br><strong>Time Complexity: O(kn)</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) sum += num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span> * sum + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][sum + nums[i]] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">0</span>][sum - nums[i]] += <span class="number">1</span>; <span class="comment">// += not = !</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span> * sum + <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums[i];</span><br><span class="line">dp[i][j + n] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">dp[i][j - n] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][sum + S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-494-target-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-494-target-sum&quot;&gt;&lt;/a&gt; LeetCode Q 494 - Target Sum&lt;/h1&gt;
&lt;p&gt;You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.&lt;br&gt;
Find out how many ways to assign symbols to make sum of integers equal to target S.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums is [1, 1, 1, 1, 1], S is 3. ; Output: 5&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;-1+1+1+1+1 = 3 +1-1+1+1+1 = 3 +1+1-1+1+1 = 3 +1+1+1-1+1 = 3 +1+1+1+1-1 = 3&lt;/code&gt;&lt;br&gt;
There are 5 ways to assign symbols to make the sum of nums be target 3.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The length of the given array is positive and will not exceed 20.&lt;/li&gt;
&lt;li&gt;The sum of elements in the given array will not exceed 1000.&lt;br&gt;
Your output answer is guaranteed to be fitted in a 32-bit integer.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="backtracking" scheme="http://yoursite.com/tags/backtracking/"/>
    
  </entry>
  
  <entry>
    <title>Palindromic Substrings</title>
    <link href="http://yoursite.com/2019/04/24/leetcodeQ647/"/>
    <id>http://yoursite.com/2019/04/24/leetcodeQ647/</id>
    <published>2019-04-24T21:54:37.000Z</published>
    <updated>2019-04-25T22:27:52.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-647-palindromic-substrings"><a class="markdownIt-Anchor" href="#leetcode-q-647-palindromic-substrings"></a> LeetCode Q 647 - Palindromic Substrings</h1><p>Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><p>Example 1:<br><code>Input: &quot;abc&quot; ; Output: 3</code><br>Explanation: Three palindromic strings: “a”, “b”, “c”.<br>Example 2:<br><code>Input: &quot;aaa&quot; ; Output: 6</code><br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p><p><strong>Note:</strong> The input string length won’t exceed 1000.</p><a id="more"></a><h2 id="solution-expand-around-center"><a class="markdownIt-Anchor" href="#solution-expand-around-center"></a> Solution : Expand Around Center</h2><p>Similar Question: <a href="/2019/04/22/leetcodeQ5/" title="Longest Palindromic Substring">Longest Palindromic Substring</a></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span>&lt; s.length(); i++) &#123;</span><br><span class="line">expandAroundCerter(s, i, i);</span><br><span class="line">expandAroundCerter(s, i, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expandAroundCerter</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; end &lt; s.length() </span><br><span class="line">&amp;&amp; s.charAt(start) == s.charAt(end)) &#123;</span><br><span class="line">  start--; end++; num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-647-palindromic-substrings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-647-palindromic-substrings&quot;&gt;&lt;/a&gt; LeetCode Q 647 - Palindromic Substrings&lt;/h1&gt;
&lt;p&gt;Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;abc&amp;quot; ; Output: 3&lt;/code&gt;&lt;br&gt;
Explanation: Three palindromic strings: “a”, “b”, “c”.&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;aaa&amp;quot; ; Output: 6&lt;/code&gt;&lt;br&gt;
Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The input string length won’t exceed 1000.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
</feed>
