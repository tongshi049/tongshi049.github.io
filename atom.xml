<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-20T17:02:24.042Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Top K Frequent Elements</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ347/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ347/</id>
    <published>2019-04-20T16:41:21.000Z</published>
    <updated>2019-04-20T17:02:24.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-347-top-k-frequent-elements"><a class="markdownIt-Anchor" href="#leetcode-q-347-top-k-frequent-elements"></a> LeetCode Q 347 - Top K Frequent Elements</h1><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>Example 1:<br><code>Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]</code><br>Example 2:<br><code>Input: nums = [1], k = 1 ; Output: [1]</code><br><strong>Note</strong>: You may assume k is always valid, <strong>1 ≤ k ≤ number of unique elements</strong>. Your algorithm’s time complexity must be better than <strong>O(n log n)</strong>, where n is the array’s size.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Heap Sort: time O(NlogN)</strong><br><strong>Bucket Sort: tiem O(N)</strong></p><h3 id="solution-1-heap-sort"><a class="markdownIt-Anchor" href="#solution-1-heap-sort"></a> Solution 1: Heap Sort</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; (map.get(a) - map.get(b)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line">pq.offer(num);</span><br><span class="line"><span class="keyword">if</span> (pq.size() &gt; k) pq.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: pq)</span><br><span class="line">res.add(<span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bucket-sort-counting-sort"><a class="markdownIt-Anchor" href="#solution-2-bucket-sort-counting-sort"></a> Solution 2: Bucket Sort (Counting sort)</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt;[] lists = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// first traverse: calculate frequencies, recode in the map</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line">map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// build buckets</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: map.keySet()) &#123;</span><br><span class="line"><span class="keyword">int</span> freq = map.get(num);</span><br><span class="line"><span class="keyword">if</span> (lists[freq] == <span class="keyword">null</span>) lists[freq] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">lists[freq].add(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// traverse each bucket </span></span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lists.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; k != <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">res.addAll(lists[i]);</span><br><span class="line">k -= lists[i].size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-347-top-k-frequent-elements&quot;&gt;&lt;/a&gt; LeetCode Q 347 - Top K Frequent Elements&lt;/h1&gt;
&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: nums = [1,1,1,2,2,3], k = 2 ; Output: [1,2]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: nums = [1], k = 1 ; Output: [1]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note&lt;/strong&gt;: You may assume k is always valid, &lt;strong&gt;1 ≤ k ≤ number of unique elements&lt;/strong&gt;. Your algorithm’s time complexity must be better than &lt;strong&gt;O(n log n)&lt;/strong&gt;, where n is the array’s size.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Pairs</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ336/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ336/</id>
    <published>2019-04-20T16:23:37.000Z</published>
    <updated>2019-04-20T16:40:06.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-336-palindrome-pairs"><a class="markdownIt-Anchor" href="#leetcode-q-336-palindrome-pairs"></a> LeetCode Q 336 - Palindrome Pairs</h1><p>Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.</p><p>Example 1:<br><code>Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]</code><br>Example 2:<br><code>Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>The idea is we first store each string and its index in the map.<br>Then, for each string, we divide it into two substrings(<strong>str1 and str2</strong>), and check all the substring pairs.</p><ol><li>if <code>str1</code> is Palindrome, then we reverse <code>str2</code>, and check if the map containsKey <code>reversedStr2</code>. If it contains, then we can concate String <code>reversedStr2</code> and <code>str1</code> to get the palindrome string. <strong>Note:</strong> the <code>reversedStr2</code> should be on the left and <code>str1</code> on the right.</li><li>if <code>str2</code> is Palindrome, then we reverse <code>str1</code>, and check if the map containsKey <code>reversedStr1</code>. If it contains, then we can concate String <code>str2</code> and <code>reversedStr1</code> to get the palindrome string. <strong>Note:</strong> the <code>str2</code> should be on the left and <code>reversedStr1</code> on the right.</li></ol><p><strong>Caution</strong>: MUST CHECK whether str.length() is equal to 0 in either if statement, because we need to make sure we do not add duplicate pairs (if str1.length() == 0, both of str1 and str2 will from input array).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++)</span><br><span class="line">map.put(words[i], i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">String word = words[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= word.length(); j++) &#123;</span><br><span class="line">String str1 = word.substring(<span class="number">0</span>, j);</span><br><span class="line">String str2 = word.substring(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str1)) &#123;</span><br><span class="line">String reversedStr2 = <span class="keyword">new</span> StringBuilder(str2).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr2) &amp;&amp; map.get(reversedStr2) != i &amp;&amp; j != <span class="number">0</span>)</span><br><span class="line">res.add(Arrays.asList(map.get(reversedStr2), str1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isPalindrome(str2)) &#123;</span><br><span class="line">String reversedStr1 = <span class="keyword">new</span> StringBuilder(str1).reverse().toString();</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(reversedStr1) &amp;&amp; map.get(reversedStr1) != i)</span><br><span class="line">res.add(Arrays.asList(i,map.get(reversedStr1)));   </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = str.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">if</span> (str.charAt(i++) != str.charAt(j--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-336-palindrome-pairs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-336-palindrome-pairs&quot;&gt;&lt;/a&gt; LeetCode Q 336 - Palindrome Pairs&lt;/h1&gt;
&lt;p&gt;Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;abcd&amp;quot;,&amp;quot;dcba&amp;quot;,&amp;quot;lls&amp;quot;,&amp;quot;s&amp;quot;,&amp;quot;sssll&amp;quot;] Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&amp;quot;dcbaabcd&amp;quot;,&amp;quot;abcddcba&amp;quot;,&amp;quot;slls&amp;quot;,&amp;quot;llssssll&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: [&amp;quot;bat&amp;quot;,&amp;quot;tab&amp;quot;,&amp;quot;cat&amp;quot;] Output: [[0,1],[1,0]] Explanation: The palindromes are [&amp;quot;battab&amp;quot;,&amp;quot;tabbat&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>H-Index</title>
    <link href="http://yoursite.com/2019/04/20/leetcodeQ274-1/"/>
    <id>http://yoursite.com/2019/04/20/leetcodeQ274-1/</id>
    <published>2019-04-20T16:19:42.000Z</published>
    <updated>2019-04-20T16:25:17.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-274-h-index"><a class="markdownIt-Anchor" href="#leetcode-q-274-h-index"></a> LeetCode Q 274 - H-Index</h1><p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has <strong>index h</strong> if h of his/her <strong>N papers</strong> have <strong>at least h citations each</strong>, and the other N − h papers have no more than h citations each.”</p><p>Similar question: <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Comparing with <a href="/2019/04/15/leetcodeQ275/" title="H-Index II">H-Index II</a>, the given citations is unsorted. We can still use <strong>binary search</strong> to solve this question as we did in leetcodeQ275. Then the <strong>time complexity</strong> is <strong>O(NlogN)</strong>. But we can optimize the solution using <strong>bucket sort (counting sort)</strong>. The <strong>time complexity</strong> becomes <strong>O(N)</strong>.</p><p>Assume n is the total number of papers, if we have n+1 buckets, number from 0 to n, then for any paper with reference corresponding to the index of the bucket, we increment the count for that bucket. The only exception is that for any paper with larger number of reference than n, we put in the n-th bucket.</p><p>Then we iterate from the back to the front of the buckets, whenever the total count exceeds the index of the bucket, meaning that we have the index number of papers that have reference greater than or equal to the index. Which will be our h-index result.</p><p>Some tricky cases: [5,5] -&gt; 2 [0,0] -&gt; 0</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (citations == <span class="keyword">null</span> || citations.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = citations.length;</span><br><span class="line"><span class="keyword">int</span>[] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[len + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> citation: citations) &#123;</span><br><span class="line"><span class="keyword">if</span> (citation &gt;= len) buckets[len]++;</span><br><span class="line"><span class="keyword">else</span> buckets[citation]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">count += buckets[i];</span><br><span class="line"><span class="keyword">if</span> (count &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-274-h-index&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-274-h-index&quot;&gt;&lt;/a&gt; LeetCode Q 274 - H-Index&lt;/h1&gt;
&lt;p&gt;Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.&lt;/p&gt;
&lt;p&gt;According to the definition of h-index on Wikipedia: “A scientist has &lt;strong&gt;index h&lt;/strong&gt; if h of his/her &lt;strong&gt;N papers&lt;/strong&gt; have &lt;strong&gt;at least h citations each&lt;/strong&gt;, and the other N − h papers have no more than h citations each.”&lt;/p&gt;
&lt;p&gt;Similar question: &lt;a href=&quot;/2019/04/15/leetcodeQ275/&quot; title=&quot;H-Index II&quot;&gt;H-Index II&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="Bucket Sort" scheme="http://yoursite.com/tags/Bucket-Sort/"/>
    
      <category term="Counting Sort" scheme="http://yoursite.com/tags/Counting-Sort/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number II</title>
    <link href="http://yoursite.com/2019/04/20/lintcodtQ776/"/>
    <id>http://yoursite.com/2019/04/20/lintcodtQ776/</id>
    <published>2019-04-20T15:24:13.000Z</published>
    <updated>2019-04-20T15:30:14.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-ii"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-ii"></a> LintCode Q 644 - Strobogrammatic Number II</h1><p>A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).<br>Find all strobogrammatic numbers that are of length = n.</p><a href="/2019/04/20/lintcodeQ644/" title="Strobogrammatic Number (Mirror Number)">Strobogrammatic Number (Mirror Number)</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>We expanded the target String <strong>from center to two sides</strong> by recursively calling the helper method.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case</span></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strs = helper(n - <span class="number">2</span>, target);</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line"><span class="keyword">if</span> (n != target) res.add(<span class="string">'0'</span> + str + <span class="string">'0'</span>);</span><br><span class="line">res.add(<span class="string">'1'</span> + str + <span class="string">'1'</span>);</span><br><span class="line">res.add(<span class="string">'6'</span> + str + <span class="string">'9'</span>);</span><br><span class="line">res.add(<span class="string">'8'</span> + str + <span class="string">'8'</span>);</span><br><span class="line">res.add(<span class="string">'9'</span> + str + <span class="string">'6'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-ii&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number II&lt;/h1&gt;
&lt;p&gt;A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).&lt;br&gt;
Find all strobogrammatic numbers that are of length = n.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodeQ644/&quot; title=&quot;Strobogrammatic Number (Mirror Number)&quot;&gt;Strobogrammatic Number (Mirror Number)&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>Strobogrammatic Number (Mirror Number)</title>
    <link href="http://yoursite.com/2019/04/20/lintcodeQ644/"/>
    <id>http://yoursite.com/2019/04/20/lintcodeQ644/</id>
    <published>2019-04-20T15:16:14.000Z</published>
    <updated>2019-04-20T15:25:35.072Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-644-strobogrammatic-number-mirror-number"><a class="markdownIt-Anchor" href="#lintcode-q-644-strobogrammatic-number-mirror-number"></a> LintCode Q 644 - Strobogrammatic Number (Mirror Number)</h1><p>GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.</p><p>Write a function to determine if a number is mirror. The number is represented as a string.</p><a href="/2019/04/20/lintcodtQ776/" title="Strobogrammatic Number II">Strobogrammatic Number II</a><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrobogrammatic</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">'0'</span>, <span class="string">'0'</span>); map.put(<span class="string">'1'</span>, <span class="string">'1'</span>); map.put(<span class="string">'6'</span>, <span class="string">'9'</span>); </span><br><span class="line">map.put(<span class="string">'9'</span>, <span class="string">'6'</span>); map.put(<span class="string">'8'</span>, <span class="string">'8'</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line"><span class="keyword">if</span> ( !map.containsKey(num.charAt(i)) || </span><br><span class="line">      map.get(num.charAt(i)) != map.get(num.charAt(j)))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">i++; j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-644-strobogrammatic-number-mirror-number&quot;&gt;&lt;/a&gt; LintCode Q 644 - Strobogrammatic Number (Mirror Number)&lt;/h1&gt;
&lt;p&gt;GA mirror number is a number that looks the same when rotated 180 degrees (looked at upside down).For example, the numbers “69”, “88”, and “818” are all mirror numbers.&lt;/p&gt;
&lt;p&gt;Write a function to determine if a number is mirror. The number is represented as a string.&lt;/p&gt;
&lt;a href=&quot;/2019/04/20/lintcodtQ776/&quot; title=&quot;Strobogrammatic Number II&quot;&gt;Strobogrammatic Number II&lt;/a&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Postorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ145/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ145/</id>
    <published>2019-04-19T23:08:55.000Z</published>
    <updated>2019-04-19T23:10:08.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-145-binary-tree-postorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-145-binary-tree-postorder-traversal"></a> LeetCode Q 145 - Binary Tree Postorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(<span class="number">0</span>, curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-145-binary-tree-postorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 145 - Binary Tree Postorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Preorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ144/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ144/</id>
    <published>2019-04-19T23:04:45.000Z</published>
    <updated>2019-04-19T23:10:58.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-144-binary-tree-preorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-144-binary-tree-preorder-traversal"></a> LeetCode Q 144 - Binary Tree Preorder Traversal</h1><p>Given a binary tree, return the <em>preorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ94/" title="Inorder Traversal">Inorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">stack.push(root);</span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">TreeNode curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line"><span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) stack.push(curr.right);</span><br><span class="line"><span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) stack.push(curr.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-144-binary-tree-preorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 144 - Binary Tree Preorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;preorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ94/&quot; title=&quot;Inorder Traversal&quot;&gt;Inorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Inorder Traversal</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ94/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ94/</id>
    <published>2019-04-19T22:55:54.000Z</published>
    <updated>2019-04-19T23:11:24.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-94-binary-tree-inorder-traversal"><a class="markdownIt-Anchor" href="#leetcode-q-94-binary-tree-inorder-traversal"></a> LeetCode Q 94 - Binary Tree Inorder Traversal</h1><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it <strong>iteratively</strong>?</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ144/" title="Preorder Traversal">Preorder Traversal</a>, <a href="/2019/04/19/leetcodeQ145/" title="Postorder Traversal">Postorder Traversal</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stact&lt;&gt;();</span><br><span class="line">TreeNode curr = root;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123; stack.push(curr); curr = curr.left; &#125;</span><br><span class="line">curr = stack.pop();</span><br><span class="line">res.add(curr.val);</span><br><span class="line">curr = curr.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-94-binary-tree-inorder-traversal&quot;&gt;&lt;/a&gt; LeetCode Q 94 - Binary Tree Inorder Traversal&lt;/h1&gt;
&lt;p&gt;Given a binary tree, return the &lt;em&gt;inorder&lt;/em&gt; traversal of its nodes’ values.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow up:&lt;/strong&gt; Recursive solution is trivial, could you do it &lt;strong&gt;iteratively&lt;/strong&gt;?&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ144/&quot; title=&quot;Preorder Traversal&quot;&gt;Preorder Traversal&lt;/a&gt;, &lt;a href=&quot;/2019/04/19/leetcodeQ145/&quot; title=&quot;Postorder Traversal&quot;&gt;Postorder Traversal&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Tree" scheme="http://yoursite.com/tags/Tree/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
  </entry>
  
  <entry>
    <title>Minimum Window Substring</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ76/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ76/</id>
    <published>2019-04-19T22:32:48.000Z</published>
    <updated>2019-04-19T22:55:31.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-76-minimum-window-substring"><a class="markdownIt-Anchor" href="#leetcode-q-76-minimum-window-substring"></a> LeetCode Q 76 - Minimum Window Substring</h1><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p><p>Example:<br><code>Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot; Output: &quot;BANC&quot;</code><br><strong>Note:</strong></p><ul><li>If there is no such window in S that covers all characters in T, return the empty string “”.</li><li>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-sliding-window-hashtable"><a class="markdownIt-Anchor" href="#solution-sliding-window-hashtable"></a> Solution : Sliding window + HashTable</h3><p><code>arr[]:</code> denotes how many letters are still in the string <strong>T</strong>. e.g. if t = “abc”, then in the array values of ‘a’, ‘b’ and ‘c’ are both 1.<br>So, during our traversal of the string <strong>S</strong>, when we encounter ‘a’, we update the table, changing the value of ‘a’ to be 0. Next time we encounter ‘a’, we change the value of ‘a’ to be -1 …</p><p><code>count:</code> denotes how many chars are still required to get a window in S that containing all letters in T. <code>if (count == 0)</code>, we update minLen.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (t.length() == <span class="number">0</span> || t.length() &gt; s.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: t.toCharArray()) arr[ch]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = t.length(), l = <span class="number">0</span>, r = <span class="number">0</span>, minLen = Integer.MAX_VALUE, head = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(r)] &gt; <span class="number">0</span>) count--;</span><br><span class="line">arr[s.charAt(r++)]--;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (r - l &lt; minLen) &#123; minLen = r - l; head = l; &#125;</span><br><span class="line"><span class="keyword">if</span> (arr[s.charAt(l)] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">arr[s.charAt(l++)]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(head, head + minLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-76-minimum-window-substring&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-76-minimum-window-substring&quot;&gt;&lt;/a&gt; LeetCode Q 76 - Minimum Window Substring&lt;/h1&gt;
&lt;p&gt;Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If there is no such window in S that covers all characters in T, return the empty string “”.&lt;/li&gt;
&lt;li&gt;If there is such window, you are guaranteed that there will always be only one unique minimum window in S.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Sliding Window" scheme="http://yoursite.com/tags/Sliding-Window/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ187</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ187/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ187/</id>
    <published>2019-04-19T22:24:42.000Z</published>
    <updated>2019-04-19T22:32:16.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-187-repeated-dna-sequences"><a class="markdownIt-Anchor" href="#leetcode-q-187-repeated-dna-sequences"></a> LeetCode Q 187 - Repeated DNA Sequences</h1><p>All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.</p><p>Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.</p><p>Example:<br><code>Input: s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot; Output: [&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>TODO: use Rabin–Karp algorithm to optimize the solution.</strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findRepeatedDnaSequences</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">Set&lt;String&gt; repeated = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!seen.add(s.substring(i, i + <span class="number">10</span>))) </span><br><span class="line">repeated.add(s.substring(i, i + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(repeated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-187-repeated-dna-sequences&quot;&gt;&lt;/a&gt; LeetCode Q 187 - Repeated DNA Sequences&lt;/h1&gt;
&lt;p&gt;All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: “ACGAATTCCG”. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.&lt;/p&gt;
&lt;p&gt;Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>leetcodeQ202</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ202/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ202/</id>
    <published>2019-04-19T22:22:40.000Z</published>
    <updated>2019-04-19T22:22:40.834Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcodeQ204</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ204/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ204/</id>
    <published>2019-04-19T22:15:51.000Z</published>
    <updated>2019-04-19T22:15:51.146Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Sentence Similarity</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ856/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ856/</id>
    <published>2019-04-19T21:57:35.000Z</published>
    <updated>2019-04-19T22:12:04.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-856-sentence-similarity"><a class="markdownIt-Anchor" href="#lintcode-q-856-sentence-similarity"></a> LintCode Q 856 -  Sentence Similarity</h1><p>Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.</p><p>For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].</p><p><strong>Note</strong> that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are <strong>not</strong> necessarily similar.</p><p>However, <strong>similarity is symmetric</strong>. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.</p><p>Also, a word is always <strong>similar with itself</strong>. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.</p><p>Finally, <strong>sentences can only be similar if they have the same number of words</strong>. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].</p><p>Similar Questions: <a href="/2019/04/19/leetcodeQ205/" title="Isomorphic Strings">Isomorphic Strings</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-hashmap"><a class="markdownIt-Anchor" href="#solution-hashmap"></a> Solution : HashMap</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSentenceSimilarity</span><span class="params">(String[] words1, String[] words2, List&lt;List&lt;String&gt;&gt; pairs)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (words1.length != words2.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the mapping, one word may mapping to many words</span></span><br><span class="line">Map&lt;String, HashSet&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// using Set&lt;String&gt; is wrong</span></span><br><span class="line">Set&lt;String&gt; set;</span><br><span class="line"><span class="keyword">for</span> (List&lt;String&gt; pair: pairs) &#123;</span><br><span class="line">set = map.getOrDefault(pair.get(<span class="number">0</span>), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">set.add(pair.get(<span class="number">1</span>));</span><br><span class="line">map.put(part.get(<span class="number">0</span>), set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (words1[i].equals(words2[i]))  <span class="comment">// a word is similar to itself</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> ( (map.get(words1[i]) == <span class="keyword">null</span> || !map.get(words1[i]).contains(words2[i])) &amp;&amp; </span><br><span class="line">     (map.get(words2[i]) == <span class="keyword">null</span> || !map.get(words2[i]).contains(words1[i])) )</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-856-sentence-similarity&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-856-sentence-similarity&quot;&gt;&lt;/a&gt; LintCode Q 856 -  Sentence Similarity&lt;/h1&gt;
&lt;p&gt;Given two sentences words1, words2 (each represented as an array of strings), and a list of similar word pairs pairs, determine if two sentences are similar.&lt;/p&gt;
&lt;p&gt;For example, words1 = great acting skills and words2 = fine drama talent are similar, if the similar word pairs are pairs = [[“great”, “fine”], [“acting”,“drama”], [“skills”,“talent”]].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the similarity relation is not transitive. For example, if “great” and “fine” are similar, and “fine” and “good” are similar, “great” and “good” are &lt;strong&gt;not&lt;/strong&gt; necessarily similar.&lt;/p&gt;
&lt;p&gt;However, &lt;strong&gt;similarity is symmetric&lt;/strong&gt;. For example, “great” and “fine” being similar is the same as “fine” and “great” being similar.&lt;/p&gt;
&lt;p&gt;Also, a word is always &lt;strong&gt;similar with itself&lt;/strong&gt;. For example, the sentences words1 = [“great”], words2 = [“great”], pairs = [] are similar, even though there are no specified similar word pairs.&lt;/p&gt;
&lt;p&gt;Finally, &lt;strong&gt;sentences can only be similar if they have the same number of words&lt;/strong&gt;. So a sentence like words1 = [“great”] can never be similar to words2 = [“doubleplus”,“good”].&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/leetcodeQ205/&quot; title=&quot;Isomorphic Strings&quot;&gt;Isomorphic Strings&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Isomorphic Strings</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ205/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ205/</id>
    <published>2019-04-19T21:09:39.000Z</published>
    <updated>2019-04-19T21:57:19.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-205-isomorphic-strings"><a class="markdownIt-Anchor" href="#leetcode-q-205-isomorphic-strings"></a> LeetCode Q 205 -  Isomorphic Strings</h1><p>Given two strings s and t, determine if they are isomorphic.</p><p>Two strings are isomorphic if the characters in s can be replaced to get t.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p><p>Similar Questions: <a href="/2019/04/19/lintcodeQ856/" title="Sentence Similarity">Sentence Similarity</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><h3 id="solution-1-hashmap"><a class="markdownIt-Anchor" href="#solution-1-hashmap"></a> Solution 1: HashMap</h3><p><code>key is the char, value is the corresponding char.</code><br><strong>One tricky is:</strong>  <code>if (map.containsValue(chs)) return false;</code><br>that is <strong>if we map ‘a’ to ‘b’, we cannot map ‘c’ to ‘b’ again.</strong><br>The mapping should be <strong>one-to-one</strong>.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> chs = s.charAt(i)), cht = t.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (map.containsKey(s.charAt(i))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.get(chs) == cht) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (map.containsValue(chs)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">map.put(chs, cht);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-use-two-arrays"><a class="markdownIt-Anchor" href="#solution-2-use-two-arrays"></a> Solution 2: Use two arrays</h3><p>Instead of using a map, we can use two arrays. First, we traverse strings s and t. At index i, we check<code>if (S[chs - 'a']) != T[cht - 'a']</code>. There are 3 cases.</p><ol><li>we never encountered <code>chs</code> and <code>cht</code> before, then their values should both be 0, then we cannot go in the <code>if</code> condition;</li><li>we encountered <code>chs</code> and <code>cht</code> before, then if their values is the same, then the chars <strong>mapping</strong> remains same as before, then we then we cannot go in the <code>if</code> condition;</li><li>if their values is not same, meaning previously we don’t <strong>mapping chs</strong> to <code>cht</code>, that is the current <strong>mapping</strong> is different with previous <strong>mapping</strong>, then return false;</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[] S = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>], T = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> chs = s.charAt(i), cht = t.charAt(j);</span><br><span class="line"><span class="keyword">if</span> (S[chs - <span class="string">'a'</span>] != T[cht - <span class="string">'a'</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">S[chs - <span class="string">'a'</span>] = i + <span class="number">1</span>; T[cht - <span class="string">'a'</span>] = i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-205-isomorphic-strings&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-205-isomorphic-strings&quot;&gt;&lt;/a&gt; LeetCode Q 205 -  Isomorphic Strings&lt;/h1&gt;
&lt;p&gt;Given two strings s and t, determine if they are isomorphic.&lt;/p&gt;
&lt;p&gt;Two strings are isomorphic if the characters in s can be replaced to get t.&lt;/p&gt;
&lt;p&gt;All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.&lt;/p&gt;
&lt;p&gt;Similar Questions: &lt;a href=&quot;/2019/04/19/lintcodeQ856/&quot; title=&quot;Sentence Similarity&quot;&gt;Sentence Similarity&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Generalized Abbreviation</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ779/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ779/</id>
    <published>2019-04-19T20:51:08.000Z</published>
    <updated>2019-04-19T21:54:01.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-779-generalized-abbreviation"><a class="markdownIt-Anchor" href="#lintcode-q-779-generalized-abbreviation"></a> LintCode Q 779 -  Generalized Abbreviation</h1><p>Write a function to generate the generalized abbreviations of a word.(order does not matter)</p><p>Example 1:<br><code>Input word = &quot;word&quot;, Output: [&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]</code><br>Example 2:<br><code>Input word = &quot;today&quot; Output: [&quot;1o1a1&quot;,&quot;1o1ay&quot;,&quot;1o2y&quot;,&quot;1o3&quot;,&quot;1od1y&quot;,&quot;1od2&quot;,&quot;1oda1&quot;,&quot;1oday&quot;,&quot;2d1y&quot;,&quot;2d2&quot;,&quot;2da1&quot;,&quot;2day&quot;,&quot;3a1&quot;,&quot;3ay&quot;,&quot;4y&quot;,&quot;5&quot;,&quot;t1d1y&quot;,&quot;t1d2&quot;,&quot;t1da1&quot;,&quot;t1day&quot;,&quot;t2a1&quot;,&quot;t2ay&quot;,&quot;t3y&quot;,&quot;t4&quot;,&quot;to1a1&quot;,&quot;to1ay&quot;,&quot;to2y&quot;,&quot;to3&quot;,&quot;tod1y&quot;,&quot;tod2&quot;,&quot;toda1&quot;,&quot;today&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>Use backtracking:</p><p><strong>Our choice:</strong> use a digit or some chars to represent a word.<br><strong>Our constraints:</strong> abbreviation should be valid, what is a valid abbrivation we can check <a href="/2019/04/19/lintcodeQ637/" title="Valid Word Abbreviation">Valid Word Abbreviation</a>.<br><strong>Our goal:</strong> generate abbreviations.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateAbbreviations</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">help(res, word, <span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(List&lt;String&gt; res, String word, <span class="keyword">int</span> pos, String curr, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="comment">// boundary case, our constraints</span></span><br><span class="line"><span class="keyword">if</span> (pos == word.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) curr = curr + count;</span><br><span class="line">res.add(curr);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// explore, out choice is using a number to represent a letter</span></span><br><span class="line"><span class="comment">// When calling it self, the pos should + 1 and count + 1 and curr string is unchanged.</span></span><br><span class="line">help(res, word, pos + <span class="number">1</span>, curr, count + <span class="number">1</span>); </span><br><span class="line"><span class="comment">// backtrack, we need to update the curr</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) curr = curr + count + word.charAt(pos);</span><br><span class="line"><span class="keyword">else</span> curr = curr + word.charAt(pos);</span><br><span class="line"><span class="comment">// explore, our choice is using the char at that position</span></span><br><span class="line"><span class="comment">// When calling it self, the pos should + 1, the count is now to be 0 and curr string is the updated one.</span></span><br><span class="line">help(res, word, pos + <span class="number">1</span>, curr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-779-generalized-abbreviation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-779-generalized-abbreviation&quot;&gt;&lt;/a&gt; LintCode Q 779 -  Generalized Abbreviation&lt;/h1&gt;
&lt;p&gt;Write a function to generate the generalized abbreviations of a word.(order does not matter)&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input word = &amp;quot;word&amp;quot;, Output: [&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input word = &amp;quot;today&amp;quot; Output: [&amp;quot;1o1a1&amp;quot;,&amp;quot;1o1ay&amp;quot;,&amp;quot;1o2y&amp;quot;,&amp;quot;1o3&amp;quot;,&amp;quot;1od1y&amp;quot;,&amp;quot;1od2&amp;quot;,&amp;quot;1oda1&amp;quot;,&amp;quot;1oday&amp;quot;,&amp;quot;2d1y&amp;quot;,&amp;quot;2d2&amp;quot;,&amp;quot;2da1&amp;quot;,&amp;quot;2day&amp;quot;,&amp;quot;3a1&amp;quot;,&amp;quot;3ay&amp;quot;,&amp;quot;4y&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;t1d1y&amp;quot;,&amp;quot;t1d2&amp;quot;,&amp;quot;t1da1&amp;quot;,&amp;quot;t1day&amp;quot;,&amp;quot;t2a1&amp;quot;,&amp;quot;t2ay&amp;quot;,&amp;quot;t3y&amp;quot;,&amp;quot;t4&amp;quot;,&amp;quot;to1a1&amp;quot;,&amp;quot;to1ay&amp;quot;,&amp;quot;to2y&amp;quot;,&amp;quot;to3&amp;quot;,&amp;quot;tod1y&amp;quot;,&amp;quot;tod2&amp;quot;,&amp;quot;toda1&amp;quot;,&amp;quot;today&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Valid Word Abbreviation</title>
    <link href="http://yoursite.com/2019/04/19/lintcodeQ637/"/>
    <id>http://yoursite.com/2019/04/19/lintcodeQ637/</id>
    <published>2019-04-19T20:39:48.000Z</published>
    <updated>2019-04-19T20:57:40.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lintcode-q-637-valid-word-abbreviation"><a class="markdownIt-Anchor" href="#lintcode-q-637-valid-word-abbreviation"></a> LintCode Q 637 - Valid Word Abbreviation</h1><p>Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.</p><p>A string such as “word” contains only the following valid abbreviations:</p><p><code>[&quot;word&quot;, &quot;1ord&quot;, &quot;w1rd&quot;, &quot;wo1d&quot;, &quot;wor1&quot;, &quot;2rd&quot;, &quot;w2d&quot;, &quot;wo2&quot;, &quot;1o1d&quot;, &quot;1or1&quot;, &quot;w1r1&quot;, &quot;1o2&quot;, &quot;2r1&quot;, &quot;3d&quot;, &quot;w3&quot;, &quot;4&quot;]</code></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p>This is a String matching question, we can use two pointers method.<br>Be careful about boundary cases. <strong>For example:</strong><br><code>the char is '0'</code>;</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validWordAbbreviation</span><span class="params">(String word, String abbr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (word.length() != abbr.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; word.length() &amp;&amp; j &lt; abbr.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(abbr.charAt(j))) &#123;</span><br><span class="line"><span class="keyword">if</span> (word.charAt(i++) != abbr.charAt(j++)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (abbr.charAt(j) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; abbr.length() &amp;&amp; abbr.charAt(j)) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + abbr.charAt(i) - <span class="string">'0'</span>; j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i += num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i == word.length() &amp;&amp; j == abbr.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;lintcode-q-637-valid-word-abbreviation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lintcode-q-637-valid-word-abbreviation&quot;&gt;&lt;/a&gt; LintCode Q 637 - Valid Word Abbreviation&lt;/h1&gt;
&lt;p&gt;Given a non-empty string word and an abbreviation abbr, return whether the string matches with the given abbreviation.&lt;/p&gt;
&lt;p&gt;A string such as “word” contains only the following valid abbreviations:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>Contains Duplicate II</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ219/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ219/</id>
    <published>2019-04-19T17:25:35.000Z</published>
    <updated>2019-04-19T17:38:13.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-217-contains-duplicate-ii"><a class="markdownIt-Anchor" href="#leetcode-q-217-contains-duplicate-ii"></a> LeetCode Q 217 - Contains Duplicate II</h1><p>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that <code>nums[i] = nums[j]</code> and the absolute difference between i and j is <strong>at most k</strong>.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong><font color="#06bcf9">Note: Don’t forget the update the index of duplicated number.</font></strong></p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!map.containsKey(nums[i])) map.put(nums[i], i);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Integer left = map.get(nums[i]);</span><br><span class="line"><span class="keyword">if</span> (i - left &lt;= k) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">else</span> map.put(nums[i], i); <span class="comment">// don't forget to update the position of nums[i]!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-217-contains-duplicate-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-217-contains-duplicate-ii&quot;&gt;&lt;/a&gt; LeetCode Q 217 - Contains Duplicate II&lt;/h1&gt;
&lt;p&gt;Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that &lt;code&gt;nums[i] = nums[j]&lt;/code&gt; and the absolute difference between i and j is &lt;strong&gt;at most k&lt;/strong&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Contains Duplicate</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ217/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ217/</id>
    <published>2019-04-19T17:23:23.000Z</published>
    <updated>2019-04-19T17:38:23.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-217-contains-duplicate"><a class="markdownIt-Anchor" href="#leetcode-q-217-contains-duplicate"></a> LeetCode Q 217 - Contains Duplicate</h1><p>Given an array of integers, find if the array contains any duplicates.</p><p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num: nums) </span><br><span class="line"><span class="keyword">if</span> (!set.add(num)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-217-contains-duplicate&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-217-contains-duplicate&quot;&gt;&lt;/a&gt; LeetCode Q 217 - Contains Duplicate&lt;/h1&gt;
&lt;p&gt;Given an array of integers, find if the array contains any duplicates.&lt;/p&gt;
&lt;p&gt;Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Valid Anagram</title>
    <link href="http://yoursite.com/2019/04/19/leetcodeQ242/"/>
    <id>http://yoursite.com/2019/04/19/leetcodeQ242/</id>
    <published>2019-04-19T17:15:04.000Z</published>
    <updated>2019-04-19T17:38:32.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-242-valid-anagram"><a class="markdownIt-Anchor" href="#leetcode-q-242-valid-anagram"></a> LeetCode Q 242 - Valid Anagram</h1><p>Given two strings s and t , write a function to determine if t is an anagram of s.</p><p>Similar question: <a href="/2019/04/18/leetcodeQ49/" title="Group Anagrams">Group Anagrams</a></p><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[] alphabet = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) alphabet[ch - <span class="string">'a'</span>]++; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: t.toCharArray()) alphabet[ch - <span class="string">'a'</span>]--;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (alphabet[i] != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-242-valid-anagram&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-242-valid-anagram&quot;&gt;&lt;/a&gt; LeetCode Q 242 - Valid Anagram&lt;/h1&gt;
&lt;p&gt;Given two strings s and t , write a function to determine if t is an anagram of s.&lt;/p&gt;
&lt;p&gt;Similar question: &lt;a href=&quot;/2019/04/18/leetcodeQ49/&quot; title=&quot;Group Anagrams&quot;&gt;Group Anagrams&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="HashTable" scheme="http://yoursite.com/tags/HashTable/"/>
    
  </entry>
  
  <entry>
    <title>Concated Words</title>
    <link href="http://yoursite.com/2019/04/18/leetcodeQ472/"/>
    <id>http://yoursite.com/2019/04/18/leetcodeQ472/</id>
    <published>2019-04-18T16:44:21.000Z</published>
    <updated>2019-04-18T17:10:46.506Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-472-concated-words"><a class="markdownIt-Anchor" href="#leetcode-q-472-concated-words"></a> LeetCode Q 472 - Concated Words</h1><p>Given a list of words (<strong>without duplicates</strong>), please write a program that returns all concatenated words in the given list of words.<br>A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.<br>E.g. Input: [“cat”,“cats”,“catsdogcats”,“dog”,“dogcatsdog”,“hippopotamuses”,“rat”,“ratcatdogcat”]<br>Output: [“catsdogcats”,“dogcatsdog”,“ratcatdogcat”]</p><a id="more"></a><h2 id="solution-trie-backtracking"><a class="markdownIt-Anchor" href="#solution-trie-backtracking"></a> Solution : Trie + Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (words == <span class="keyword">null</span> || words.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the trie</span></span><br><span class="line"><span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line"><span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">insert(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// search for concatenated word</span></span><br><span class="line"><span class="keyword">for</span> (String word: words) &#123;</span><br><span class="line"><span class="keyword">if</span> (word.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (isConcatenated(word, <span class="number">0</span>, <span class="number">0</span>)) res.add(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">TrieNode[] parent;</span><br><span class="line"><span class="keyword">boolean</span> is End;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123; parent = <span class="keyword">new</span> TrieNode[<span class="number">26</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line">node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use backtracking the check if the current word is a concatenated word</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConcatenated</span><span class="params">(String word, <span class="keyword">int</span> index, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Boundary case</span></span><br><span class="line"><span class="keyword">if</span> (index &gt;= word.length()) <span class="keyword">return</span> count &gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; word.length(); i++) &#123;</span><br><span class="line"><span class="keyword">char</span> ch = word.charAt(i);</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) <span class="comment">// our constraints</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span> (node.isEnd) &#123;</span><br><span class="line"><span class="keyword">if</span> (isConcatenated(word, i + <span class="number">1</span>, count + <span class="number">1</span>)) <span class="comment">// explore</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-472-concated-words&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-472-concated-words&quot;&gt;&lt;/a&gt; LeetCode Q 472 - Concated Words&lt;/h1&gt;
&lt;p&gt;Given a list of words (&lt;strong&gt;without duplicates&lt;/strong&gt;), please write a program that returns all concatenated words in the given list of words.&lt;br&gt;
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.&lt;br&gt;
E.g. Input: [“cat”,“cats”,“catsdogcats”,“dog”,“dogcatsdog”,“hippopotamuses”,“rat”,“ratcatdogcat”]&lt;br&gt;
Output: [“catsdogcats”,“dogcatsdog”,“ratcatdogcat”]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
</feed>
