<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tong Shi&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-29T17:48:32.652Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tong Shi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Word Search II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ212/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ212/</id>
    <published>2019-04-29T17:31:48.000Z</published>
    <updated>2019-04-29T17:48:32.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-212-word-search-ii"><a class="markdownIt-Anchor" href="#leetcode-q-212-word-search-ii"></a> LeetCode Q 212 - Word Search II</h1><p>Given a 2D board and a list of words from the dictionary, find all words in the board.<br>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p><p>Example:<br>Input:<br>board = [<br>[‘o’,‘a’,‘a’,‘n’],<br>[‘e’,‘t’,‘a’,‘e’],<br>[‘i’,‘h’,‘k’,‘r’],<br>[‘i’,‘f’,‘l’,‘v’]<br>]<br>words = [“oath”,“pea”,“eat”,“rain”]<br>Output: [“eat”,“oath”]</p><p><strong>Note:</strong></p><ul><li>All inputs are consist of lowercase letters a-z.</li><li>The values of words are distinct.</li></ul><a id="more"></a><h2 id="solution-trie-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-trie-dfs-backtracking"></a> Solution : Trie + DFS / Backtracking</h2><p>Compared with <a href="/2019/04/29/leetcodeQ79/" title="Word Search">Word Search</a>, we use DFS with a trie but a word.</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>() </span>&#123;</span><br><span class="line">TrieNode[] children;</span><br><span class="line"><span class="keyword">boolean</span> isEnd;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>.children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>]) </span><br><span class="line">node.children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line">node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">startWith</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">TrieNode node = root;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: word.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (node.children[ch - <span class="string">'a'</span>] == <span class="keyword">null</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">node = node.children[ch - <span class="string">'a'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node.isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; res;  <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line"></span><br><span class="line"><span class="comment">// build the trie</span></span><br><span class="line"><span class="keyword">for</span> (String word: words) trie.insert(word);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> [board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">dfs(board, <span class="string">""</span>, i, j, visited);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String curr, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || visited[row][col]) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">curr += board[row][col];</span><br><span class="line"><span class="keyword">if</span> (!startWith(curr)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (search(curr)) &#123; res.add(curr); <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line">dfs(board, row + <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row - <span class="number">1</span>, col, visited);</span><br><span class="line">dfs(board, row, col + <span class="number">1</span>, visited);</span><br><span class="line">dfs(board, row, col - <span class="number">1</span>, visited);</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-212-word-search-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-212-word-search-ii&quot;&gt;&lt;/a&gt; LeetCode Q 212 - Word Search II&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a list of words from the dictionary, find all words in the board.&lt;br&gt;
Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
Input:&lt;br&gt;
board = [&lt;br&gt;
[‘o’,‘a’,‘a’,‘n’],&lt;br&gt;
[‘e’,‘t’,‘a’,‘e’],&lt;br&gt;
[‘i’,‘h’,‘k’,‘r’],&lt;br&gt;
[‘i’,‘f’,‘l’,‘v’]&lt;br&gt;
]&lt;br&gt;
words = [“oath”,“pea”,“eat”,“rain”]&lt;br&gt;
Output: [“eat”,“oath”]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All inputs are consist of lowercase letters a-z.&lt;/li&gt;
&lt;li&gt;The values of words are distinct.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Trie" scheme="http://yoursite.com/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Word Search</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ79/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ79/</id>
    <published>2019-04-29T17:22:35.000Z</published>
    <updated>2019-04-29T17:31:23.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-79-word-search"><a class="markdownIt-Anchor" href="#leetcode-q-79-word-search"></a> LeetCode Q 79 - Word Search</h1><p>Given a 2D board and a word, find if the word exists in the grid.<br>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:<br>board =<br>[<br>[‘A’,‘B’,‘C’,‘E’],<br>[‘S’,‘F’,‘C’,‘S’],<br>[‘A’,‘D’,‘E’,‘E’]<br>]</p><p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p>**Time Complexity:**O(n^2 * 4 * 3^(k-1)) = O(n^2 * 3^k).</p><p>Explanation: We start the word search over all n^2 nodes. For the first letter of the word search we can move in 4 directions but for every later one there are only three options (you can’t move back onto yourself).</p><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] visited;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, <span class="number">0</span>, i, j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> pos, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (row &lt; <span class="number">0</span> || row == board.length || col &lt; <span class="number">0</span> || col &gt; board[<span class="number">0</span>].length || </span><br><span class="line">visited[row][col] || board[row][col] != word.charAt(pos)) </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">visited[row][col] = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (dfs(board, word, pos + <span class="number">1</span>, row - <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row + <span class="number">1</span>, col) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col - <span class="number">1</span>) || </span><br><span class="line">dfs(board, word, pos + <span class="number">1</span>, row, col + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">visited[row][col] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-79-word-search&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-79-word-search&quot;&gt;&lt;/a&gt; LeetCode Q 79 - Word Search&lt;/h1&gt;
&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;br&gt;
The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
board =&lt;br&gt;
[&lt;br&gt;
[‘A’,‘B’,‘C’,‘E’],&lt;br&gt;
[‘S’,‘F’,‘C’,‘S’],&lt;br&gt;
[‘A’,‘D’,‘E’,‘E’]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;Given word = “ABCCED”, return true.&lt;br&gt;
Given word = “SEE”, return true.&lt;br&gt;
Given word = “ABCB”, return false.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens II</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ52/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ52/</id>
    <published>2019-04-29T17:17:50.000Z</published>
    <updated>2019-04-29T17:22:58.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-52-n-queens-ii"><a class="markdownIt-Anchor" href="#leetcode-q-52-n-queens-ii"></a> LeetCode Q 52 - N-Queens II</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return the number of distinct solutions to the n-queens puzzle.</p><p>Example:<br><code>Input: 4 ; Output: 2</code><br>Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.<br>[<br>[&quot;.Q…&quot;,  // Solution 1<br>“…Q”,<br>“Q…”,<br>“…Q.”],</p><p>[&quot;…Q.&quot;,  // Solution 2<br>“Q…”,<br>“…Q”,<br>“.Q…”]<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, n, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">res++; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-52-n-queens-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-52-n-queens-ii&quot;&gt;&lt;/a&gt; LeetCode Q 52 - N-Queens II&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return the number of distinct solutions to the n-queens puzzle.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 ; Output: 2&lt;/code&gt;&lt;br&gt;
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.&lt;br&gt;
[&lt;br&gt;
[&amp;quot;.Q…&amp;quot;,  // Solution 1&lt;br&gt;
“…Q”,&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q.”],&lt;/p&gt;
&lt;p&gt;[&amp;quot;…Q.&amp;quot;,  // Solution 2&lt;br&gt;
“Q…”,&lt;br&gt;
“…Q”,&lt;br&gt;
“.Q…”]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>N-Queens</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ51/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ51/</id>
    <published>2019-04-29T16:57:30.000Z</published>
    <updated>2019-04-29T17:22:54.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-51-n-queens"><a class="markdownIt-Anchor" href="#leetcode-q-51-n-queens"></a> LeetCode Q 51 - N-Queens</h1><p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.<br>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p><p>Example:<br><code>Input: 4 Output: [ [&quot;.Q..&quot;, // Solution 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // Solution 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ]</code><br>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> N) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (N &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// build graph</span></span><br><span class="line"><span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[N][N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span>[] row: board) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j  = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line"> row[j] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">solve(board, N, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length)</span><br><span class="line">list.add(String.valueOf(board[i]));</span><br><span class="line">res.add(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; N; col++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][col] == <span class="string">'.'</span> &amp;&amp; isValid(board, N, row, col)) &#123;</span><br><span class="line">board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">solve(board, N, row + <span class="number">1</span>);</span><br><span class="line">board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> N, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line"><span class="comment">// check row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[row][j] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check col</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[i][col] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check diagonal</span></span><br><span class="line"><span class="keyword">int</span> r = row, c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check another diagonal</span></span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &lt; N &amp;&amp; c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r++][c--] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = row; c = col;</span><br><span class="line"><span class="keyword">while</span> (r &gt;= <span class="number">0</span> &amp;&amp; c &lt; N) &#123;</span><br><span class="line"><span class="keyword">if</span> (board[r--][c++] == <span class="string">'Q'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-51-n-queens&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-51-n-queens&quot;&gt;&lt;/a&gt; LeetCode Q 51 - N-Queens&lt;/h1&gt;
&lt;p&gt;The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.&lt;br&gt;
Given an integer n, return all distinct solutions to the n-queens puzzle.&lt;br&gt;
Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: 4 Output: [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;..Q.&amp;quot;], [&amp;quot;..Q.&amp;quot;, // Solution 2 &amp;quot;Q...&amp;quot;, &amp;quot;...Q&amp;quot;, &amp;quot;.Q..&amp;quot;] ]&lt;/code&gt;&lt;br&gt;
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Remove Invalid Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ301/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ301/</id>
    <published>2019-04-29T16:34:02.000Z</published>
    <updated>2019-04-29T16:56:29.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-301-remove-invalid-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-301-remove-invalid-parentheses"></a> LeetCode Q 301 - Remove Invalid Parentheses</h1><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.<br><strong>Note:</strong> The input string may contain letters other than the parentheses <code>(</code> and <code>)</code>.</p><p>Example 1:<br><code>Input: &quot;()())()&quot; ; Output: [&quot;()()()&quot;, &quot;(())()&quot;]</code><br>Example 2:<br><code>Input: &quot;(a)())()&quot; ; Output: [&quot;(a)()()&quot;, &quot;(a())()&quot;]</code><br>Example 3:<br><code>Input: &quot;)(&quot; ; Output: [&quot;&quot;]</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><ol><li>pre-process the String <code>s</code>, determine how many <code>(</code>s and <code>)</code>s we need to delete.</li><li>To avoid duplicates, use a set to store the result.</li><li>Backtrack finding the answer.<ul><li>corner cases: <code>if (rmL &lt; 0 || rmR &lt; 0 || open &lt; 0)</code> indicates an invalid string, we should return;</li><li>our goal(i.e. when to break the backtrack): <code>if (pos == s.length())</code> we should also stop the backtrack, and check<ul><li><code>if (rmL == 0 &amp;&amp; rmR == 0 &amp;&amp; open == 0)</code>, then update the result set;</li><li>else just ruturn;</li></ul></li><li>explore<ul><li>if current char is ‘(’ or ‘)’ we can either choose to <strong>use</strong> it or <strong>not</strong>.</li><li>if current char is a letter we update current string.</li></ul></li></ul></li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; res; <span class="comment">// avoid duplicates</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> rmL = <span class="number">0</span>, rmR = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: s.toCharArray()) &#123;</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">rmL++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL != <span class="number">0</span>) rmL--;</span><br><span class="line"><span class="keyword">else</span> rmR++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(s, <span class="number">0</span>, <span class="string">""</span>, rmL, rmR, open);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> pos, String curr, <span class="keyword">int</span> rmL, <span class="keyword">int</span> rmR, <span class="keyword">int</span> open)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (rmL &lt; <span class="number">0</span> || rmR &lt; <span class="number">0</span> || open &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == s.length()) &#123;</span><br><span class="line"><span class="keyword">if</span> (rmL == <span class="number">0</span> &amp;&amp; rmR == <span class="number">0</span> &amp;&amp; open == <span class="number">0</span>) res.add(curr);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = s.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open + <span class="number">1</span>); <span class="comment">// use '('</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL - <span class="number">1</span>, rmR, open); <span class="comment">// not use '('</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open - <span class="number">1</span>); <span class="comment">// use ')'</span></span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr, rmL, rmR - <span class="number">1</span>, open); <span class="comment">// not use ')'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfs(s, pos + <span class="number">1</span>, curr + ch, rmL, rmR, open);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-301-remove-invalid-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 301 - Remove Invalid Parentheses&lt;/h1&gt;
&lt;p&gt;Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The input string may contain letters other than the parentheses &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;()())()&amp;quot; ; Output: [&amp;quot;()()()&amp;quot;, &amp;quot;(())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;(a)())()&amp;quot; ; Output: [&amp;quot;(a)()()&amp;quot;, &amp;quot;(a())()&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;)(&amp;quot; ; Output: [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Generate Parentheses</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ22/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ22/</id>
    <published>2019-04-29T16:30:18.000Z</published>
    <updated>2019-04-29T16:33:43.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-22-generate-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-22-generate-parentheses"></a> LeetCode Q 22 - Generate Parentheses</h1><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:<br>[<br>“((()))”,<br>“(()())”,<br>“(())()”,<br>“()(())”,<br>“()()()”<br>]</p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">dfs(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; n || right &gt; n || left &lt; right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curr.length() == <span class="number">2</span> * n) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(n, left + <span class="number">1</span>, right, curr + <span class="string">'('</span>);</span><br><span class="line">dfs(n, left, right + <span class="number">1</span>, curr + <span class="string">')'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-22-generate-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-22-generate-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 22 - Generate Parentheses&lt;/h1&gt;
&lt;p&gt;Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&lt;/p&gt;
&lt;p&gt;For example, given n = 3, a solution set is:&lt;br&gt;
[&lt;br&gt;
“((()))”,&lt;br&gt;
“(()())”,&lt;br&gt;
“(())()”,&lt;br&gt;
“()(())”,&lt;br&gt;
“()()()”&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Letter Case Permutation</title>
    <link href="http://yoursite.com/2019/04/29/leetcodeQ784/"/>
    <id>http://yoursite.com/2019/04/29/leetcodeQ784/</id>
    <published>2019-04-29T16:11:58.000Z</published>
    <updated>2019-04-29T16:29:39.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-784-letter-case-permutation"><a class="markdownIt-Anchor" href="#leetcode-q-784-letter-case-permutation"></a> LeetCode Q 784 - Letter Case Permutation</h1><p>Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.</p><p>Examples:<br><code>Input: S = &quot;a1b2&quot; ; Output: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</code></p><p><code>Input: S = &quot;3z4&quot; ; Output: [&quot;3z4&quot;, &quot;3Z4&quot;]</code></p><p><code>Input: S = &quot;12345&quot; ; Output: [&quot;12345&quot;]</code></p><p><strong>Note:</strong></p><ul><li>S will be a string with length between 1 and 12.</li><li>S will consist only of letters or digits.</li></ul><a id="more"></a><h2 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution :</h2><h3 id="solution-1-dfs-backtracking"><a class="markdownIt-Anchor" href="#solution-1-dfs-backtracking"></a> Solution 1 : DFS / Backtracking</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(S, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String S, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pos == S.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch = S.charAt(pos);</span><br><span class="line"><span class="keyword">if</span> (Character.isLetter(ch)) &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toUpperCase(ch));</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + Character.toLowerCase(ch));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">backtrack(S, pos + <span class="number">1</span>, curr + ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="solution-2-bfs"><a class="markdownIt-Anchor" href="#solution-2-bfs"></a> Solution 2 : BFS</h3><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">Queue&lt;String&gt; que= <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">que.offer(S);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Character.isDigit(S.charAt(i))) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = que.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">String str = que.poll();</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"></span><br><span class="line">chs[i] = Character.toUpperCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">chs[i] = Character.toLowerCase(chs[i]);</span><br><span class="line">que.offer(String.valueOf(chs));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;(que);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-784-letter-case-permutation&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-784-letter-case-permutation&quot;&gt;&lt;/a&gt; LeetCode Q 784 - Letter Case Permutation&lt;/h1&gt;
&lt;p&gt;Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.  Return a list of all possible strings we could create.&lt;/p&gt;
&lt;p&gt;Examples:&lt;br&gt;
&lt;code&gt;Input: S = &amp;quot;a1b2&amp;quot; ; Output: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;3z4&amp;quot; ; Output: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Input: S = &amp;quot;12345&amp;quot; ; Output: [&amp;quot;12345&amp;quot;]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S will be a string with length between 1 and 12.&lt;/li&gt;
&lt;li&gt;S will consist only of letters or digits.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>Permutations II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQQ47/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQQ47/</id>
    <published>2019-04-28T21:28:10.000Z</published>
    <updated>2019-04-29T12:06:38.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-47-permutations-ii"><a class="markdownIt-Anchor" href="#leetcode-q-47-permutations-ii"></a> LeetCode Q 47 - Permutations II</h1><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p><p>Example:<br><code>Input: [1,1,2]</code><br>Output:<br>[<br>[1,1,2],<br>[1,2,1],<br>[2,1,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Tips:</strong></p><ul><li>Use an extra boolean array <code>boolean[] used</code> to indicate whether the value is added to list.</li><li>Sort the array <code>int[] nums</code> to make sure we can skip the same value.</li><li><strong>When a number has the same value with its previous, we can use this number only if his previous is used.</strong></li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] || i &gt; <span class="number">0</span> &amp;&amp; nums[i] = nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">visited[i] = <span class="keyword">true</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp, visited);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">visited[i] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-47-permutations-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-47-permutations-ii&quot;&gt;&lt;/a&gt; LeetCode Q 47 - Permutations II&lt;/h1&gt;
&lt;p&gt;Given a collection of numbers that might contain duplicates, return all possible unique permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,1,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,1,2],&lt;br&gt;
[1,2,1],&lt;br&gt;
[2,1,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>Permutations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ46/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ46/</id>
    <published>2019-04-28T21:25:40.000Z</published>
    <updated>2019-04-29T16:12:23.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-46-permutations"><a class="markdownIt-Anchor" href="#leetcode-q-46-permutations"></a> LeetCode Q 46 - Permutations</h1><p>Given a collection of <strong>distinct</strong> integers, return all possible permutations.</p><p>Example:<br><code>Input: [1,2,3]</code><br>Output:<br>[<br>[1,2,3],<br>[1,3,2],<br>[2,1,3],<br>[2,3,1],<br>[3,1,2],<br>[3,2,1]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(nums[i])) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-46-permutations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-46-permutations&quot;&gt;&lt;/a&gt; LeetCode Q 46 - Permutations&lt;/h1&gt;
&lt;p&gt;Given a collection of &lt;strong&gt;distinct&lt;/strong&gt; integers, return all possible permutations.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3,2],&lt;br&gt;
[2,1,3],&lt;br&gt;
[2,3,1],&lt;br&gt;
[3,1,2],&lt;br&gt;
[3,2,1]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Permutation" scheme="http://yoursite.com/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>Subsets II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ90/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ90/</id>
    <published>2019-04-28T21:22:53.000Z</published>
    <updated>2019-04-28T21:25:00.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets-ii"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets-ii"></a> LeetCode Q 78 - Subsets II</h1><p>Given a collection of integers that might contain duplicates, <em><strong>nums</strong></em>, return all possible subsets (the power set).</p><p><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: [1,2,2]</code><br>Output:<br>[<br>[2],<br>[1],<br>[1,2,2],<br>[2,2],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != pos &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets-ii&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets II&lt;/h1&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, &lt;em&gt;&lt;strong&gt;nums&lt;/strong&gt;&lt;/em&gt;, return all possible subsets (the power set).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: [1,2,2]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2],&lt;br&gt;
[1],&lt;br&gt;
[1,2,2],&lt;br&gt;
[2,2],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Subsets</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ78/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ78/</id>
    <published>2019-04-28T21:21:07.000Z</published>
    <updated>2019-04-28T21:22:28.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-78-subsets"><a class="markdownIt-Anchor" href="#leetcode-q-78-subsets"></a> LeetCode Q 78 - Subsets</h1><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br><strong>Note:</strong> The solution set must not contain duplicate subsets.</p><p>Example:<br><code>Input: nums = [1,2,3]</code><br>Output:<br>[<br>[3],<br>[1],<br>[2],<br>[1,2,3],<br>[1,3],<br>[2,3],<br>[1,2],<br>[]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">backtrack(nums, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-78-subsets&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-78-subsets&quot;&gt;&lt;/a&gt; LeetCode Q 78 - Subsets&lt;/h1&gt;
&lt;p&gt;Given a set of distinct integers, nums, return all possible subsets (the power set).&lt;br&gt;
&lt;strong&gt;Note:&lt;/strong&gt; The solution set must not contain duplicate subsets.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: nums = [1,2,3]&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[3],&lt;br&gt;
[1],&lt;br&gt;
[2],&lt;br&gt;
[1,2,3],&lt;br&gt;
[1,3],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum III</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ216/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ216/</id>
    <published>2019-04-28T21:17:33.000Z</published>
    <updated>2019-04-28T21:20:41.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-216-combination-sum-iii"><a class="markdownIt-Anchor" href="#leetcode-q-216-combination-sum-iii"></a> LeetCode Q 216 - Combination Sum III</h1><p>Find all possible combinations of <em><strong>k</strong></em> numbers that add up to a number <em><strong>n</strong></em>, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p><p><strong>Note:</strong></p><ul><li>All numbers will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: k = 3, n = 7 ; Output: [[1,2,4]]</code><br>Example 2:<br><code>Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(k, target, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k || target &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, target - i, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-216-combination-sum-iii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-216-combination-sum-iii&quot;&gt;&lt;/a&gt; LeetCode Q 216 - Combination Sum III&lt;/h1&gt;
&lt;p&gt;Find all possible combinations of &lt;em&gt;&lt;strong&gt;k&lt;/strong&gt;&lt;/em&gt; numbers that add up to a number &lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 7 ; Output: [[1,2,4]]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: k = 3, n = 9 ; Output: [[1,2,6], [1,3,5], [2,3,4]]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combinations</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ77/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ77/</id>
    <published>2019-04-28T21:13:16.000Z</published>
    <updated>2019-04-28T21:19:38.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-77-combinations"><a class="markdownIt-Anchor" href="#leetcode-q-77-combinations"></a> LeetCode Q 77 - Combinations</h1><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p><p>Example:<br><code>Input: n = 4, k = 2</code><br>Output:<br>[<br>[2,4],<br>[3,4],<br>[2,3],<br>[1,2],<br>[1,3],<br>[1,4],<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> || k.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(n, k, <span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> pos, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.size() &gt; k) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!temp.contains(i)) &#123;</span><br><span class="line">temp.add(i);</span><br><span class="line">backtrack(n, k, i + <span class="number">1</span>, temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-77-combinations&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-77-combinations&quot;&gt;&lt;/a&gt; LeetCode Q 77 - Combinations&lt;/h1&gt;
&lt;p&gt;Given two integers n and k, return all possible combinations of k numbers out of 1 … n.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: n = 4, k = 2&lt;/code&gt;&lt;br&gt;
Output:&lt;br&gt;
[&lt;br&gt;
[2,4],&lt;br&gt;
[3,4],&lt;br&gt;
[2,3],&lt;br&gt;
[1,2],&lt;br&gt;
[1,3],&lt;br&gt;
[1,4],&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum II</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ40/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ40/</id>
    <published>2019-04-28T21:09:18.000Z</published>
    <updated>2019-04-28T21:14:42.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum-ii"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum-ii"></a> LeetCode Q 39 - Combination Sum II</h1><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>Each number in candidates may <strong>only be used once</strong> in the combination.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [10,1,2,7,6,1,5], target = 8,</code><br>A solution set is:<br>[<br>[1, 7],<br>[1, 2, 5],<br>[2, 6],<br>[1, 1, 6]<br>]<br>Example 2:<br><code>Input: candidates = [2,5,2,1,2], target = 5,</code><br>A solution set is:<br>[<br>[1,2,2],<br>[5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (cand == <span class="keyword">null</span> || cand.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">Arrays.sort(cand);</span><br><span class="line">backtrack(cand, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] cand, <span class="keyword">int</span> target, <span class="keyword">int</span> index, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; cand.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; cand[i] = cand[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum-ii&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum-ii&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum II&lt;/h1&gt;
&lt;p&gt;Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
Each number in candidates may &lt;strong&gt;only be used once&lt;/strong&gt; in the combination.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [10,1,2,7,6,1,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1, 7],&lt;br&gt;
[1, 2, 5],&lt;br&gt;
[2, 6],&lt;br&gt;
[1, 1, 6]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,5,2,1,2], target = 5,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[1,2,2],&lt;br&gt;
[5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Combination Sum</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ39/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ39/</id>
    <published>2019-04-28T21:05:38.000Z</published>
    <updated>2019-04-28T21:09:00.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-39-combination-sum"><a class="markdownIt-Anchor" href="#leetcode-q-39-combination-sum"></a> LeetCode Q 39 - Combination Sum</h1><p>Given a <strong>set</strong> of candidate numbers (candidates) <strong>(without duplicates)</strong> and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The <strong>same</strong> repeated number may be chosen from candidates unlimited number of times.</p><p><strong>Note:</strong></p><ul><li>All numbers (including target) will be positive integers.</li><li>The solution set must not contain duplicate combinations.</li></ul><p>Example 1:<br><code>Input: candidates = [2,3,6,7], target = 7,</code><br>A solution set is:<br>[<br>[7],<br>[2,2,3]<br>]<br>Example 2:<br><code>Input: candidates = [2,3,5], target = 8,</code><br>A solution set is:<br>[<br>[2,2,2,2],<br>[2,3,3],<br>[3,5]<br>]</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (can == <span class="keyword">null</span> || can.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(can, target, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] can, <span class="keyword">int</span> target, <span class="keyword">int</span> index, <span class="keyword">int</span> currSum, List&lt;Integer&gt; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currSum == target) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currSum &gt; target) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; can.length; i++) &#123;</span><br><span class="line">temp.add(can[i]);</span><br><span class="line">backtrack(can, target, i, currSum + can[i], temp);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-39-combination-sum&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-39-combination-sum&quot;&gt;&lt;/a&gt; LeetCode Q 39 - Combination Sum&lt;/h1&gt;
&lt;p&gt;Given a &lt;strong&gt;set&lt;/strong&gt; of candidate numbers (candidates) &lt;strong&gt;(without duplicates)&lt;/strong&gt; and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.&lt;br&gt;
The &lt;strong&gt;same&lt;/strong&gt; repeated number may be chosen from candidates unlimited number of times.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All numbers (including target) will be positive integers.&lt;/li&gt;
&lt;li&gt;The solution set must not contain duplicate combinations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,6,7], target = 7,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[7],&lt;br&gt;
[2,2,3]&lt;br&gt;
]&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: candidates = [2,3,5], target = 8,&lt;/code&gt;&lt;br&gt;
A solution set is:&lt;br&gt;
[&lt;br&gt;
[2,2,2,2],&lt;br&gt;
[2,3,3],&lt;br&gt;
[3,5]&lt;br&gt;
]&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Letter Combinations of a Phone Number</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ17/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ17/</id>
    <published>2019-04-28T21:01:18.000Z</published>
    <updated>2019-04-28T21:08:14.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-17-letter-combinations-of-a-phone-number"><a class="markdownIt-Anchor" href="#leetcode-q-17-letter-combinations-of-a-phone-number"></a> LeetCode Q 17 - Letter Combinations of a Phone Number</h1><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>Example:<br><code>Input: &quot;23&quot; ;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</code></p><p><strong>Note:</strong> Although the above answer is in lexicographical order, your answer could be in any order you want.</p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] KEYS = &#123; <span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span> &#125;;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(digits, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits, <span class="keyword">int</span> pos, String curr)</span> </span>&#123;</span><br><span class="line"><span class="comment">// corner cases</span></span><br><span class="line"><span class="keyword">if</span> (pos == digits.length()) &#123;</span><br><span class="line">res.add(curr); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String letters = KEYS[digits.charAt(pos) - <span class="string">'0'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> letter: letters.toCharArray())</span><br><span class="line">backtrack(digits, pos + <span class="number">1</span>, curr + letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-17-letter-combinations-of-a-phone-number&quot;&gt;&lt;/a&gt; LeetCode Q 17 - Letter Combinations of a Phone Number&lt;/h1&gt;
&lt;p&gt;Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;23&amp;quot; ;Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;].&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Although the above answer is in lexicographical order, your answer could be in any order you want.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
  <entry>
    <title>Split Array into Fibonacci Sequence</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ842/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ842/</id>
    <published>2019-04-28T17:21:58.000Z</published>
    <updated>2019-04-28T21:04:38.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-842-split-array-into-fibonacci-sequence"><a class="markdownIt-Anchor" href="#leetcode-q-842-split-array-into-fibonacci-sequence"></a> LeetCode Q 842 - Split Array into Fibonacci Sequence</h1><p>Given a string <code>S</code> of digits, such as <code>S = &quot;123456579&quot;</code>, we can split it into a <em>Fibonacci-like</em> sequence <code>[123, 456, 579]</code>.<br>Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:</p><ul><li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>, (that is, each integer fits a 32-bit signed integer type);</li><li><code>F.length &gt;= 3</code>;</li><li>and <code>F[i] + F[i+1] = F[i+2]</code> for all <code>0 &lt;= i &lt; F.length - 2</code>.<br>Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.</li></ul><p>Return any Fibonacci-like sequence split from S, or return <code>[]</code> if it cannot be done.</p><p>Example 1:<br><code>Input: &quot;123456579&quot; ; Output: [123,456,579]</code><br>Example 2:<br><code>Input: &quot;11235813&quot; ; Output: [1,1,2,3,5,8,13]</code><br>Example 3:<br><code>Input: &quot;112358130&quot; ; Output: []</code><br>Explanation: The task is impossible.<br>Example 4:<br><code>Input: &quot;0123&quot; ; Output: []</code><br>Explanation: Leading zeroes are not allowed, so “01”, “2”, “3” is not valid.<br>Example 5:<br><code>Input: &quot;1101111&quot; ; Output: [110, 1, 111]</code><br>Explanation: The output [11, 0, 11, 11] would also be accepted.</p><p><strong>Note:</strong></p><ul><li>1 &lt;= S.length &lt;= 200</li><li>S contains only digits.</li></ul><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p>The <strong>key</strong> is <strong>handling corner cases</strong>:</p><ul><li>Remove elements with leading zero</li><li>The element in the sequence should be at most Integer.MAX_VALUE</li><li>The sequence should has at least 3 elements</li><li>If current number is larger than the sum of previous two elements, stop backtracking</li><li>If we find a valid sequence, stop backtracking</li></ul><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">splitIntoFibonacci</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">backtrack(S, res, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(String s, List&lt;Integer&gt; res, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index == s.length() &amp;&amp; res.size() &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="comment">// a number with leading 0s but not '0' is invalid</span></span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; s.charAt(index) == <span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> num = Long.parseLong(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (num &gt; Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> size = res.size();</span><br><span class="line"><span class="keyword">if</span> (size &gt;= <span class="number">2</span> &amp;&amp; num &gt; res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &lt; <span class="number">2</span> || num == res.get(size-<span class="number">1</span>) + res.get(size-<span class="number">2</span>)) &#123;</span><br><span class="line">    res.add((<span class="keyword">int</span>)num);</span><br><span class="line">    <span class="comment">// If we find a valid sequence, stop backtracking</span></span><br><span class="line">    <span class="keyword">if</span> (backtrack(s, res, i + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-842-split-array-into-fibonacci-sequence&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-842-split-array-into-fibonacci-sequence&quot;&gt;&lt;/a&gt; LeetCode Q 842 - Split Array into Fibonacci Sequence&lt;/h1&gt;
&lt;p&gt;Given a string &lt;code&gt;S&lt;/code&gt; of digits, such as &lt;code&gt;S = &amp;quot;123456579&amp;quot;&lt;/code&gt;, we can split it into a &lt;em&gt;Fibonacci-like&lt;/em&gt; sequence &lt;code&gt;[123, 456, 579]&lt;/code&gt;.&lt;br&gt;
Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1&lt;/code&gt;, (that is, each integer fits a 32-bit signed integer type);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F.length &amp;gt;= 3&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;F[i] + F[i+1] = F[i+2]&lt;/code&gt; for all &lt;code&gt;0 &amp;lt;= i &amp;lt; F.length - 2&lt;/code&gt;.&lt;br&gt;
Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return any Fibonacci-like sequence split from S, or return &lt;code&gt;[]&lt;/code&gt; if it cannot be done.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;123456579&amp;quot; ; Output: [123,456,579]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;11235813&amp;quot; ; Output: [1,1,2,3,5,8,13]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;112358130&amp;quot; ; Output: []&lt;/code&gt;&lt;br&gt;
Explanation: The task is impossible.&lt;br&gt;
Example 4:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;0123&amp;quot; ; Output: []&lt;/code&gt;&lt;br&gt;
Explanation: Leading zeroes are not allowed, so “01”, “2”, “3” is not valid.&lt;br&gt;
Example 5:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;1101111&amp;quot; ; Output: [110, 1, 111]&lt;/code&gt;&lt;br&gt;
Explanation: The output [11, 0, 11, 11] would also be accepted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= S.length &amp;lt;= 200&lt;/li&gt;
&lt;li&gt;S contains only digits.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Expression Add Operators</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ282/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ282/</id>
    <published>2019-04-28T16:58:59.000Z</published>
    <updated>2019-04-28T21:02:16.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-282-expression-add-operators"><a class="markdownIt-Anchor" href="#leetcode-q-282-expression-add-operators"></a> LeetCode Q 282 - Expression Add Operators</h1><p>Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.</p><p>Example 1:<br><code>Input: num = &quot;123&quot;, target = 6 ; Output: [&quot;1+2+3&quot;, &quot;1*2*3&quot;]</code><br>Example 2:<br><code>Input: num = &quot;232&quot;, target = 8 ; Output: [&quot;2*3+2&quot;, &quot;2+3*2&quot;]</code><br>Example 3:<br><code>Input: num = &quot;105&quot;, target = 5 ; Output: [&quot;1*0+5&quot;,&quot;10-5&quot;]</code><br>Example 4:<br><code>Input: num = &quot;00&quot;, target = 0 ; Output: [&quot;0+0&quot;, &quot;0-0&quot;, &quot;0*0&quot;]</code><br>Example 5:<br><code>Input: num = &quot;3456237490&quot;, target = 9191 ; Output: []</code></p><a id="more"></a><h2 id="solution-dfs"><a class="markdownIt-Anchor" href="#solution-dfs"></a> Solution : DFS</h2><ol><li><strong>Corner Cases:</strong></li></ol><ul><li>if current position is 0, we can only use it as a single digit number, should be 0</li><li>if it is not a single digit number with leading 0, it should be considered as an invalid number</li></ul><ol start="2"><li><strong>How to do multiplication?</strong><br>we should subtract previous number, and then add current multiplication result to the subtraction result</li></ol><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addOperators</span><span class="params">(String num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (num == <span class="keyword">null</span> || num.length() == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">dfs(num, target, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String num, <span class="keyword">int</span> target, String exp, <span class="keyword">int</span> index, <span class="keyword">long</span> prev, <span class="keyword">long</span> calVal)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == num.length() &amp;&amp; calVal == target) &#123;</span><br><span class="line">res.add(exp); <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i != index &amp;&amp; num.charAt(index) == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> num = Long.parseLong(s.substring(index, i));</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">dfs(num, target, exp + num, i, num, num);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dfs(num, target, exp + <span class="string">"+"</span> + num, i, num, calVal + num);</span><br><span class="line">dfs(num, target, exp + <span class="string">"-"</span> + num, i, -num, calVal - num);</span><br><span class="line">dfs(num, target, exp + <span class="string">"*"</span> + num, i, prev * num, calVal - prev + prev * num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-282-expression-add-operators&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-282-expression-add-operators&quot;&gt;&lt;/a&gt; LeetCode Q 282 - Expression Add Operators&lt;/h1&gt;
&lt;p&gt;Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;123&amp;quot;, target = 6 ; Output: [&amp;quot;1+2+3&amp;quot;, &amp;quot;1*2*3&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 2:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;232&amp;quot;, target = 8 ; Output: [&amp;quot;2*3+2&amp;quot;, &amp;quot;2+3*2&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 3:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;105&amp;quot;, target = 5 ; Output: [&amp;quot;1*0+5&amp;quot;,&amp;quot;10-5&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 4:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;00&amp;quot;, target = 0 ; Output: [&amp;quot;0+0&amp;quot;, &amp;quot;0-0&amp;quot;, &amp;quot;0*0&amp;quot;]&lt;/code&gt;&lt;br&gt;
Example 5:&lt;br&gt;
&lt;code&gt;Input: num = &amp;quot;3456237490&amp;quot;, target = 9191 ; Output: []&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>Different Ways to Add Parentheses</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ241/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ241/</id>
    <published>2019-04-28T16:48:52.000Z</published>
    <updated>2019-04-28T21:02:06.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-241-different-ways-to-add-parentheses"><a class="markdownIt-Anchor" href="#leetcode-q-241-different-ways-to-add-parentheses"></a> LeetCode Q 241 - Different Ways to Add Parentheses</h1><p>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p><p>Example 1:<br><code>Input: &quot;2-1-1&quot; ; Output: [0, 2]</code><br>Explanation:<br><code>((2-1)-1) = 0 , (2-(1-1)) = 2</code></p><p>Example 2:<br><code>Input: &quot;2*3-4*5&quot; ; Output: [-34, -14, -10, -10, 10]</code><br>Explanation:<br><code>(2*(3-(4*5))) = -34 , ((2*3)-(4*5)) = -14 , ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 , (((2*3)-4)*5) = 10</code></p><a id="more"></a><h2 id="solution-divide-and-conquer"><a class="markdownIt-Anchor" href="#solution-divide-and-conquer"></a> Solution : Divide and Conquer</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (input.charAt(i) == <span class="string">'+'</span> || input.charAt(i) == <span class="string">'-'</span> || input.charAt(i) == <span class="string">'*'</span>) &#123;</span><br><span class="line">List&lt;Integer&gt; left = diffWaysToCompute(input.substring(<span class="number">0</span>, i));</span><br><span class="line">List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num1: left) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num2: right) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) res.add(num1 + num2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'-'</span>) res.add(num1 - num2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">'+'</span>) res.add(num1 * num2); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.size() == <span class="number">0</span>) </span><br><span class="line">res.add(Integer.parseInt(input));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-241-different-ways-to-add-parentheses&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-241-different-ways-to-add-parentheses&quot;&gt;&lt;/a&gt; LeetCode Q 241 - Different Ways to Add Parentheses&lt;/h1&gt;
&lt;p&gt;Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;2-1-1&amp;quot; ; Output: [0, 2]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;((2-1)-1) = 0 , (2-(1-1)) = 2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;2*3-4*5&amp;quot; ; Output: [-34, -14, -10, -10, 10]&lt;/code&gt;&lt;br&gt;
Explanation:&lt;br&gt;
&lt;code&gt;(2*(3-(4*5))) = -34 , ((2*3)-(4*5)) = -14 , ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 , (((2*3)-4)*5) = 10&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="Partition" scheme="http://yoursite.com/tags/Partition/"/>
    
  </entry>
  
  <entry>
    <title>Palindrome Partitioning</title>
    <link href="http://yoursite.com/2019/04/28/leetcodeQ131/"/>
    <id>http://yoursite.com/2019/04/28/leetcodeQ131/</id>
    <published>2019-04-28T16:36:58.000Z</published>
    <updated>2019-04-28T16:51:15.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-q-131-palindrome-partitioning"><a class="markdownIt-Anchor" href="#leetcode-q-131-palindrome-partitioning"></a> LeetCode Q 131 - Palindrome Partitioning</h1><p>Given a string s, partition s such that every substring of the partition is a palindrome.<br>Return all possible palindrome partitioning of s.</p><p>Example:<br><code>Input: &quot;aab&quot; Output: [ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;] ]</code></p><a id="more"></a><h2 id="solution-backtracking"><a class="markdownIt-Anchor" href="#solution-backtracking"></a> Solution : Backtracking</h2><p><strong>Code:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">backtrack(s, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, List&lt;String&gt; temp, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">res.add(<span class="keyword">new</span> ArrayList(temp)); <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; s.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPalindromic(s, index, i)) &#123;</span><br><span class="line">temp.add(s.substring(index, i + <span class="number">1</span>));</span><br><span class="line">backtrack(s, temp, i + <span class="number">1</span>);</span><br><span class="line">temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span> <span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">left++; right--;</span><br><span class="line">&#125;</span><br><span class="line">retur <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-q-131-palindrome-partitioning&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#leetcode-q-131-palindrome-partitioning&quot;&gt;&lt;/a&gt; LeetCode Q 131 - Palindrome Partitioning&lt;/h1&gt;
&lt;p&gt;Given a string s, partition s such that every substring of the partition is a palindrome.&lt;br&gt;
Return all possible palindrome partitioning of s.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;
&lt;code&gt;Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="Combination" scheme="http://yoursite.com/tags/Combination/"/>
    
  </entry>
  
</feed>
